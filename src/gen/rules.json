[
  {
    "name": "airflow-variable-name-task-id-mismatch",
    "code": "AIR001",
    "linter": "Airflow",
    "summary": "Task variable name should match the `task_id`: \"{task_id}\"",
    "message_formats": [
      "Task variable name should match the `task_id`: \"{task_id}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that the task variable name matches the `task_id` value for\nAirflow Operators.\n\n## Why is this bad?\nWhen initializing an Airflow Operator, for consistency, the variable\nname should match the `task_id` value. This makes it easier to\nfollow the flow of the DAG.\n\n## Example\n```python\nfrom airflow.operators import PythonOperator\n\n\nincorrect_name = PythonOperator(task_id=\"my_task\")\n```\n\nUse instead:\n```python\nfrom airflow.operators import PythonOperator\n\n\nmy_task = PythonOperator(task_id=\"my_task\")\n```\n"
  },
  {
    "name": "missing-copyright-notice",
    "code": "CPY001",
    "linter": "Copyright-related rules",
    "summary": "Missing copyright notice at top of file",
    "message_formats": [
      "Missing copyright notice at top of file"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the absence of copyright notices within Python files.\n\n## Why is this bad?\nIn some codebases, it's common to have a license header at the top of every\nfile. This rule ensures that the license header is present.\n"
  },
  {
    "name": "commented-out-code",
    "code": "ERA001",
    "linter": "eradicate",
    "summary": "Found commented-out code",
    "message_formats": [
      "Found commented-out code"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for commented-out Python code.\n\n## Why is this bad?\nCommented-out code is dead code, and is often included inadvertently.\nIt should be removed.\n\n## Example\n```python\n# print('foo')\n```\n\n## Options\n- `task-tags`\n"
  },
  {
    "name": "sys-version-slice3",
    "code": "YTT101",
    "linter": "flake8-2020",
    "summary": "`sys.version[:3]` referenced (python3.10), use `sys.version_info`",
    "message_formats": [
      "`sys.version[:3]` referenced (python3.10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `sys.version[:3]`.\n\n## Why is this bad?\nIf the current major or minor version consists of multiple digits,\n`sys.version[:3]` will truncate the version number (e.g., `\"3.10\"` would\nbecome `\"3.1\"`). This is likely unintended, and can lead to subtle bugs if\nthe version string is used to test against a specific Python version.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\n## Example\n```python\nimport sys\n\nsys.version[:3]  # Evaluates to \"3.1\" on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info[:2]  # Evaluates to (3, 10) on Python 3.10.\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version2",
    "code": "YTT102",
    "linter": "flake8-2020",
    "summary": "`sys.version[2]` referenced (python3.10), use `sys.version_info`",
    "message_formats": [
      "`sys.version[2]` referenced (python3.10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `sys.version[2]`.\n\n## Why is this bad?\nIf the current major or minor version consists of multiple digits,\n`sys.version[2]` will select the first digit of the minor number only\n(e.g., `\"3.10\"` would evaluate to `\"1\"`). This is likely unintended, and\ncan lead to subtle bugs if the version is used to test against a minor\nversion number.\n\nInstead, use `sys.version_info.minor` to access the current minor version\nnumber.\n\n## Example\n```python\nimport sys\n\nsys.version[2]  # Evaluates to \"1\" on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.minor}\"  # Evaluates to \"10\" on Python 3.10.\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version-cmp-str3",
    "code": "YTT103",
    "linter": "flake8-2020",
    "summary": "`sys.version` compared to string (python3.10), use `sys.version_info`",
    "message_formats": [
      "`sys.version` compared to string (python3.10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons that test `sys.version` against string literals,\nsuch that the comparison will evaluate to `False` on Python 3.10 or later.\n\n## Why is this bad?\nComparing `sys.version` to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically. For example, `sys.version > \"3.9\"` will evaluate to `False`\nwhen using Python 3.10, as `\"3.10\"` is lexicographically \"less\" than\n`\"3.9\"`.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\n## Example\n```python\nimport sys\n\nsys.version > \"3.9\"  # `False` on Python 3.10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info > (3, 9)  # `True` on Python 3.10.\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version-info0-eq3",
    "code": "YTT201",
    "linter": "flake8-2020",
    "summary": "`sys.version_info[0] == 3` referenced (python4), use `>=`",
    "message_formats": [
      "`sys.version_info[0] == 3` referenced (python4), use `>=`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for equality comparisons against the major version returned by\n`sys.version_info` (e.g., `sys.version_info[0] == 3`).\n\n## Why is this bad?\nUsing `sys.version_info[0] == 3` to verify that the major version is\nPython 3 or greater will fail if the major version number is ever\nincremented (e.g., to Python 4). This is likely unintended, as code\nthat uses this comparison is likely intended to be run on Python 2,\nbut would now run on Python 4 too.\n\nInstead, use `>=` to check if the major version number is 3 or greater,\nto future-proof the code.\n\n## Example\n```python\nimport sys\n\nif sys.version_info[0] == 3:\n    ...\nelse:\n    print(\"Python 2\")  # This will be printed on Python 4.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info >= (3,):\n    ...\nelse:\n    print(\"Python 2\")  # This will not be printed on Python 4.\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "six-py3",
    "code": "YTT202",
    "linter": "flake8-2020",
    "summary": "`six.PY3` referenced (python4), use `not six.PY2`",
    "message_formats": [
      "`six.PY3` referenced (python4), use `not six.PY2`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `six.PY3`.\n\n## Why is this bad?\n`six.PY3` will evaluate to `False` on Python 4 and greater. This is likely\nunintended, and may cause code intended to run on Python 2 to run on Python 4\ntoo.\n\nInstead, use `not six.PY2` to validate that the current Python major version is\n_not_ equal to 2, to future-proof the code.\n\n## Example\n```python\nimport six\n\nsix.PY3  # `False` on Python 4.\n```\n\nUse instead:\n```python\nimport six\n\nnot six.PY2  # `True` on Python 4.\n```\n\n## References\n- [PyPI: `six`](https://pypi.org/project/six/)\n- [Six documentation: `six.PY2`](https://six.readthedocs.io/#six.PY2)\n- [Six documentation: `six.PY3`](https://six.readthedocs.io/#six.PY3)\n"
  },
  {
    "name": "sys-version-info1-cmp-int",
    "code": "YTT203",
    "linter": "flake8-2020",
    "summary": "`sys.version_info[1]` compared to integer (python4), compare `sys.version_info` to tuple",
    "message_formats": [
      "`sys.version_info[1]` compared to integer (python4), compare `sys.version_info` to tuple"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons that test `sys.version_info[1]` against an integer.\n\n## Why is this bad?\nComparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\nInstead, compare `sys.version_info` to a tuple, including the major and\nminor version numbers, to future-proof the code.\n\n## Example\n```python\nimport sys\n\nif sys.version_info[1] < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version-info-minor-cmp-int",
    "code": "YTT204",
    "linter": "flake8-2020",
    "summary": "`sys.version_info.minor` compared to integer (python4), compare `sys.version_info` to tuple",
    "message_formats": [
      "`sys.version_info.minor` compared to integer (python4), compare `sys.version_info` to tuple"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons that test `sys.version_info.minor` against an integer.\n\n## Why is this bad?\nComparisons based on the current minor version number alone can cause\nsubtle bugs and would likely lead to unintended effects if the Python\nmajor version number were ever incremented (e.g., to Python 4).\n\nInstead, compare `sys.version_info` to a tuple, including the major and\nminor version numbers, to future-proof the code.\n\n## Example\n```python\nimport sys\n\nif sys.version_info.minor < 7:\n    print(\"Python 3.6 or earlier.\")  # This will be printed on Python 4.0.\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info < (3, 7):\n    print(\"Python 3.6 or earlier.\")\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version0",
    "code": "YTT301",
    "linter": "flake8-2020",
    "summary": "`sys.version[0]` referenced (python10), use `sys.version_info`",
    "message_formats": [
      "`sys.version[0]` referenced (python10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `sys.version[0]`.\n\n## Why is this bad?\nIf the current major or minor version consists of multiple digits,\n`sys.version[0]` will select the first digit of the major version number\nonly (e.g., `\"3.10\"` would evaluate to `\"1\"`). This is likely unintended,\nand can lead to subtle bugs if the version string is used to test against a\nmajor version number.\n\nInstead, use `sys.version_info.major` to access the current major version\nnumber.\n\n## Example\n```python\nimport sys\n\nsys.version[0]  # If using Python 10, this evaluates to \"1\".\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version-cmp-str10",
    "code": "YTT302",
    "linter": "flake8-2020",
    "summary": "`sys.version` compared to string (python10), use `sys.version_info`",
    "message_formats": [
      "`sys.version` compared to string (python10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons that test `sys.version` against string literals,\nsuch that the comparison would fail if the major version number were\never incremented to Python 10 or higher.\n\n## Why is this bad?\nComparing `sys.version` to a string is error-prone and may cause subtle\nbugs, as the comparison will be performed lexicographically, not\nsemantically.\n\nInstead, use `sys.version_info` to access the current major and minor\nversion numbers as a tuple, which can be compared to other tuples\nwithout issue.\n\n## Example\n```python\nimport sys\n\nsys.version >= \"3\"  # `False` on Python 10.\n```\n\nUse instead:\n```python\nimport sys\n\nsys.version_info >= (3,)  # `True` on Python 10.\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "sys-version-slice1",
    "code": "YTT303",
    "linter": "flake8-2020",
    "summary": "`sys.version[:1]` referenced (python10), use `sys.version_info`",
    "message_formats": [
      "`sys.version[:1]` referenced (python10), use `sys.version_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `sys.version[:1]`.\n\n## Why is this bad?\nIf the major version number consists of more than one digit, this will\nselect the first digit of the major version number only (e.g., `\"10.0\"`\nwould evaluate to `\"1\"`). This is likely unintended, and can lead to subtle\nbugs in future versions of Python if the version string is used to test\nagainst a specific major version number.\n\nInstead, use `sys.version_info.major` to access the current major version\nnumber.\n\n## Example\n```python\nimport sys\n\nsys.version[:1]  # If using Python 10, this evaluates to \"1\".\n```\n\nUse instead:\n```python\nimport sys\n\nf\"{sys.version_info.major}\"  # If using Python 10, this evaluates to \"10\".\n```\n\n## References\n- [Python documentation: `sys.version`](https://docs.python.org/3/library/sys.html#sys.version)\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "missing-type-function-argument",
    "code": "ANN001",
    "linter": "flake8-annotations",
    "summary": "Missing type annotation for function argument `{name}`",
    "message_formats": [
      "Missing type annotation for function argument `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that function arguments have type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\n## Example\n```python\ndef foo(x):\n    ...\n```\n\nUse instead:\n```python\ndef foo(x: int):\n    ...\n```\n"
  },
  {
    "name": "missing-type-args",
    "code": "ANN002",
    "linter": "flake8-annotations",
    "summary": "Missing type annotation for `*{name}`",
    "message_formats": [
      "Missing type annotation for `*{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that function `*args` arguments have type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\n## Example\n```python\ndef foo(*args):\n    ...\n```\n\nUse instead:\n```python\ndef foo(*args: int):\n    ...\n```\n"
  },
  {
    "name": "missing-type-kwargs",
    "code": "ANN003",
    "linter": "flake8-annotations",
    "summary": "Missing type annotation for `**{name}`",
    "message_formats": [
      "Missing type annotation for `**{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that function `**kwargs` arguments have type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\n## Example\n```python\ndef foo(**kwargs):\n    ...\n```\n\nUse instead:\n```python\ndef foo(**kwargs: int):\n    ...\n```\n"
  },
  {
    "name": "missing-type-self",
    "code": "ANN101",
    "linter": "flake8-annotations",
    "summary": "Missing type annotation for `{name}` in method",
    "message_formats": [
      "Missing type annotation for `{name}` in method"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that instance method `self` arguments have type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nNote that many type checkers will infer the type of `self` automatically, so this\nannotation is not strictly necessary.\n\n## Example\n```python\nclass Foo:\n    def bar(self):\n        ...\n```\n\nUse instead:\n```python\nclass Foo:\n    def bar(self: \"Foo\"):\n        ...\n```\n"
  },
  {
    "name": "missing-type-cls",
    "code": "ANN102",
    "linter": "flake8-annotations",
    "summary": "Missing type annotation for `{name}` in classmethod",
    "message_formats": [
      "Missing type annotation for `{name}` in classmethod"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that class method `cls` arguments have type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the types of function arguments. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany provided arguments match expectation.\n\nNote that many type checkers will infer the type of `cls` automatically, so this\nannotation is not strictly necessary.\n\n## Example\n```python\nclass Foo:\n    @classmethod\n    def bar(cls):\n        ...\n```\n\nUse instead:\n```python\nclass Foo:\n    @classmethod\n    def bar(cls: Type[\"Foo\"]):\n        ...\n```\n"
  },
  {
    "name": "missing-return-type-undocumented-public-function",
    "code": "ANN201",
    "linter": "flake8-annotations",
    "summary": "Missing return type annotation for public function `{name}`",
    "message_formats": [
      "Missing return type annotation for public function `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that public functions and methods have return type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\n## Example\n```python\ndef add(a, b):\n    return a + b\n```\n\nUse instead:\n```python\ndef add(a: int, b: int) -> int:\n    return a + b\n```\n"
  },
  {
    "name": "missing-return-type-private-function",
    "code": "ANN202",
    "linter": "flake8-annotations",
    "summary": "Missing return type annotation for private function `{name}`",
    "message_formats": [
      "Missing return type annotation for private function `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that private functions and methods have return type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\n## Example\n```python\ndef _add(a, b):\n    return a + b\n```\n\nUse instead:\n```python\ndef _add(a: int, b: int) -> int:\n    return a + b\n```\n"
  },
  {
    "name": "missing-return-type-special-method",
    "code": "ANN204",
    "linter": "flake8-annotations",
    "summary": "Missing return type annotation for special method `{name}`",
    "message_formats": [
      "Missing return type annotation for special method `{name}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks that \"special\" methods, like `__init__`, `__new__`, and `__call__`, have\nreturn type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\nNote that type checkers often allow you to omit the return type annotation for\n`__init__` methods, as long as at least one argument has a type annotation. To\nopt-in to this behavior, use the `mypy-init-return` setting in your `pyproject.toml`\nor `ruff.toml` file:\n\n```toml\n[tool.ruff.flake8-annotations]\nmypy-init-return = true\n```\n\n## Example\n```python\nclass Foo:\n    def __init__(self, x: int):\n        self.x = x\n```\n\nUse instead:\n```python\nclass Foo:\n    def __init__(self, x: int) -> None:\n        self.x = x\n```\n"
  },
  {
    "name": "missing-return-type-static-method",
    "code": "ANN205",
    "linter": "flake8-annotations",
    "summary": "Missing return type annotation for staticmethod `{name}`",
    "message_formats": [
      "Missing return type annotation for staticmethod `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that static methods have return type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\n## Example\n```python\nclass Foo:\n    @staticmethod\n    def bar():\n        return 1\n```\n\nUse instead:\n```python\nclass Foo:\n    @staticmethod\n    def bar() -> int:\n        return 1\n```\n"
  },
  {
    "name": "missing-return-type-class-method",
    "code": "ANN206",
    "linter": "flake8-annotations",
    "summary": "Missing return type annotation for classmethod `{name}`",
    "message_formats": [
      "Missing return type annotation for classmethod `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that class methods have return type annotations.\n\n## Why is this bad?\nType annotations are a good way to document the return types of functions. They also\nhelp catch bugs, when used alongside a type checker, by ensuring that the types of\nany returned values, and the types expected by callers, match expectation.\n\n## Example\n```python\nclass Foo:\n    @classmethod\n    def bar(cls):\n        return 1\n```\n\nUse instead:\n```python\nclass Foo:\n    @classmethod\n    def bar(cls) -> int:\n        return 1\n```\n"
  },
  {
    "name": "any-type",
    "code": "ANN401",
    "linter": "flake8-annotations",
    "summary": "Dynamically typed expressions (typing.Any) are disallowed in `{name}`",
    "message_formats": [
      "Dynamically typed expressions (typing.Any) are disallowed in `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that an expression is annotated with a more specific type than\n`Any`.\n\n## Why is this bad?\n`Any` is a special type indicating an unconstrained type. When an\nexpression is annotated with type `Any`, type checkers will allow all\noperations on it.\n\nIt's better to be explicit about the type of an expression, and to use\n`Any` as an \"escape hatch\" only when it is really needed.\n\n## Example\n```python\ndef foo(x: Any):\n    ...\n```\n\nUse instead:\n```python\ndef foo(x: int):\n    ...\n```\n\n## References\n- [PEP 484](https://www.python.org/dev/peps/pep-0484/#the-any-type)\n- [`typing.Any`](https://docs.python.org/3/library/typing.html#typing.Any)\n- [Mypy: The Any type](https://mypy.readthedocs.io/en/stable/kinds_of_types.html#the-any-type)\n"
  },
  {
    "name": "blocking-http-call-in-async-function",
    "code": "ASYNC100",
    "linter": "flake8-async",
    "summary": "Async functions should not call blocking HTTP methods",
    "message_formats": [
      "Async functions should not call blocking HTTP methods"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that async functions do not contain blocking HTTP calls.\n\n## Why is this bad?\nBlocking an async function via a blocking HTTP call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\nHTTP response, negating the benefits of asynchronous programming.\n\nInstead of making a blocking HTTP call, use an asynchronous HTTP client\nlibrary such as `aiohttp` or `httpx`.\n\n## Example\n```python\nasync def fetch():\n    urllib.request.urlopen(\"https://example.com/foo/bar\").read()\n```\n\nUse instead:\n```python\nasync def fetch():\n    async with aiohttp.ClientSession() as session:\n        async with session.get(\"https://example.com/foo/bar\") as resp:\n            ...\n```\n"
  },
  {
    "name": "open-sleep-or-subprocess-in-async-function",
    "code": "ASYNC101",
    "linter": "flake8-async",
    "summary": "Async functions should not call `open`, `time.sleep`, or `subprocess` methods",
    "message_formats": [
      "Async functions should not call `open`, `time.sleep`, or `subprocess` methods"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that async functions do not contain calls to `open`, `time.sleep`,\nor `subprocess` methods.\n\n## Why is this bad?\nBlocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function.\n\n## Example\n```python\nasync def foo():\n    time.sleep(1000)\n```\n\nUse instead:\n```python\nasync def foo():\n    await asyncio.sleep(1000)\n```\n"
  },
  {
    "name": "blocking-os-call-in-async-function",
    "code": "ASYNC102",
    "linter": "flake8-async",
    "summary": "Async functions should not call synchronous `os` methods",
    "message_formats": [
      "Async functions should not call synchronous `os` methods"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that async functions do not contain calls to blocking synchronous\nprocess calls via the `os` module.\n\n## Why is this bad?\nBlocking an async function via a blocking call will block the entire\nevent loop, preventing it from executing other tasks while waiting for the\ncall to complete, negating the benefits of asynchronous programming.\n\nInstead of making a blocking call, use an equivalent asynchronous library\nor function.\n\n## Example\n```python\nasync def foo():\n    os.popen()\n```\n\nUse instead:\n```python\ndef foo():\n    os.popen()\n```\n"
  },
  {
    "name": "assert",
    "code": "S101",
    "linter": "flake8-bandit",
    "summary": "Use of `assert` detected",
    "message_formats": [
      "Use of `assert` detected"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of the `assert` keyword.\n\n## Why is this bad?\nAssertions are removed when Python is run with optimization requested\n(i.e., when the `-O` flag is present), which is a common practice in\nproduction environments. As such, assertions should not be used for runtime\nvalidation of user input or to enforce  interface constraints.\n\nConsider raising a meaningful error instead of using `assert`.\n\n## Example\n```python\nassert x > 0, \"Expected positive value.\"\n```\n\nUse instead:\n```python\nif x <= 0:\n    raise ValueError(\"Expected positive value.\")\n```\n"
  },
  {
    "name": "exec-builtin",
    "code": "S102",
    "linter": "flake8-bandit",
    "summary": "Use of `exec` detected",
    "message_formats": [
      "Use of `exec` detected"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "bad-file-permissions",
    "code": "S103",
    "linter": "flake8-bandit",
    "summary": "`os.chmod` setting a permissive mask `{mask:#o}` on file or directory",
    "message_formats": [
      "`os.chmod` setting a permissive mask `{mask:#o}` on file or directory"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-bind-all-interfaces",
    "code": "S104",
    "linter": "flake8-bandit",
    "summary": "Possible binding to all interfaces",
    "message_formats": [
      "Possible binding to all interfaces"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-password-string",
    "code": "S105",
    "linter": "flake8-bandit",
    "summary": "Possible hardcoded password assigned to: \"{}\"",
    "message_formats": [
      "Possible hardcoded password assigned to: \"{}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-password-func-arg",
    "code": "S106",
    "linter": "flake8-bandit",
    "summary": "Possible hardcoded password assigned to argument: \"{}\"",
    "message_formats": [
      "Possible hardcoded password assigned to argument: \"{}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-password-default",
    "code": "S107",
    "linter": "flake8-bandit",
    "summary": "Possible hardcoded password assigned to function default: \"{}\"",
    "message_formats": [
      "Possible hardcoded password assigned to function default: \"{}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-temp-file",
    "code": "S108",
    "linter": "flake8-bandit",
    "summary": "Probable insecure usage of temporary file or directory: \"{}\"",
    "message_formats": [
      "Probable insecure usage of temporary file or directory: \"{}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "try-except-pass",
    "code": "S110",
    "linter": "flake8-bandit",
    "summary": "`try`-`except`-`pass` detected, consider logging the exception",
    "message_formats": [
      "`try`-`except`-`pass` detected, consider logging the exception"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "try-except-continue",
    "code": "S112",
    "linter": "flake8-bandit",
    "summary": "`try`-`except`-`continue` detected, consider logging the exception",
    "message_formats": [
      "`try`-`except`-`continue` detected, consider logging the exception"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "request-without-timeout",
    "code": "S113",
    "linter": "flake8-bandit",
    "summary": "Probable use of requests call with timeout set to `{value}`",
    "message_formats": [
      "Probable use of requests call with timeout set to `{value}`",
      "Probable use of requests call without timeout"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-pickle-usage",
    "code": "S301",
    "linter": "flake8-bandit",
    "summary": "`pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue",
    "message_formats": [
      "`pickle` and modules that wrap it can be unsafe when used to deserialize untrusted data, possible security issue"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-marshal-usage",
    "code": "S302",
    "linter": "flake8-bandit",
    "summary": "Deserialization with the `marshal` module is possibly dangerous",
    "message_formats": [
      "Deserialization with the `marshal` module is possibly dangerous"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-insecure-hash-usage",
    "code": "S303",
    "linter": "flake8-bandit",
    "summary": "Use of insecure MD2, MD4, MD5, or SHA1 hash function",
    "message_formats": [
      "Use of insecure MD2, MD4, MD5, or SHA1 hash function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-insecure-cipher-usage",
    "code": "S304",
    "linter": "flake8-bandit",
    "summary": "Use of insecure cipher, replace with a known secure cipher such as AES",
    "message_formats": [
      "Use of insecure cipher, replace with a known secure cipher such as AES"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-insecure-cipher-mode-usage",
    "code": "S305",
    "linter": "flake8-bandit",
    "summary": "Use of insecure cipher mode, replace with a known secure cipher such as AES",
    "message_formats": [
      "Use of insecure cipher mode, replace with a known secure cipher such as AES"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-mktemp-usage",
    "code": "S306",
    "linter": "flake8-bandit",
    "summary": "Use of insecure and deprecated function (`mktemp`)",
    "message_formats": [
      "Use of insecure and deprecated function (`mktemp`)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-eval-usage",
    "code": "S307",
    "linter": "flake8-bandit",
    "summary": "Use of possibly insecure function; consider using `ast.literal_eval`",
    "message_formats": [
      "Use of possibly insecure function; consider using `ast.literal_eval`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-mark-safe-usage",
    "code": "S308",
    "linter": "flake8-bandit",
    "summary": "Use of `mark_safe` may expose cross-site scripting vulnerabilities",
    "message_formats": [
      "Use of `mark_safe` may expose cross-site scripting vulnerabilities"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-url-open-usage",
    "code": "S310",
    "linter": "flake8-bandit",
    "summary": "Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected.",
    "message_formats": [
      "Audit URL open for permitted schemes. Allowing use of `file:` or custom schemes is often unexpected."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-non-cryptographic-random-usage",
    "code": "S311",
    "linter": "flake8-bandit",
    "summary": "Standard pseudo-random generators are not suitable for cryptographic purposes",
    "message_formats": [
      "Standard pseudo-random generators are not suitable for cryptographic purposes"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-telnet-usage",
    "code": "S312",
    "linter": "flake8-bandit",
    "summary": "Telnet-related functions are being called. Telnet is considered insecure. Use SSH or some other encrypted protocol.",
    "message_formats": [
      "Telnet-related functions are being called. Telnet is considered insecure. Use SSH or some other encrypted protocol."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xmlc-element-tree-usage",
    "code": "S313",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-element-tree-usage",
    "code": "S314",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-expat-reader-usage",
    "code": "S315",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-expat-builder-usage",
    "code": "S316",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-sax-usage",
    "code": "S317",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-mini-dom-usage",
    "code": "S318",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xml-pull-dom-usage",
    "code": "S319",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-xmle-tree-usage",
    "code": "S320",
    "linter": "flake8-bandit",
    "summary": "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents",
    "message_formats": [
      "Using `xml` to parse untrusted data is known to be vulnerable to XML attacks; use `defusedxml` equivalents"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-ftp-lib-usage",
    "code": "S321",
    "linter": "flake8-bandit",
    "summary": "FTP-related functions are being called. FTP is considered insecure. Use SSH/SFTP/SCP or some other encrypted protocol.",
    "message_formats": [
      "FTP-related functions are being called. FTP is considered insecure. Use SSH/SFTP/SCP or some other encrypted protocol."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "suspicious-unverified-context-usage",
    "code": "S323",
    "linter": "flake8-bandit",
    "summary": "Python allows using an insecure context via the `_create_unverified_context` that reverts to the previous behavior that does not validate certificates or perform hostname checks.",
    "message_formats": [
      "Python allows using an insecure context via the `_create_unverified_context` that reverts to the previous behavior that does not validate certificates or perform hostname checks."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hashlib-insecure-hash-function",
    "code": "S324",
    "linter": "flake8-bandit",
    "summary": "Probable use of insecure hash functions in `hashlib`: `{string}`",
    "message_formats": [
      "Probable use of insecure hash functions in `hashlib`: `{string}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "request-with-no-cert-validation",
    "code": "S501",
    "linter": "flake8-bandit",
    "summary": "Probable use of `{string}` call with `verify=False` disabling SSL certificate checks",
    "message_formats": [
      "Probable use of `{string}` call with `verify=False` disabling SSL certificate checks"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "unsafe-yaml-load",
    "code": "S506",
    "linter": "flake8-bandit",
    "summary": "Probable use of unsafe loader `{name}` with `yaml.load`. Allows instantiation of arbitrary objects. Consider `yaml.safe_load`.",
    "message_formats": [
      "Probable use of unsafe loader `{name}` with `yaml.load`. Allows instantiation of arbitrary objects. Consider `yaml.safe_load`.",
      "Probable use of unsafe `yaml.load`. Allows instantiation of arbitrary objects. Consider `yaml.safe_load`."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "snmp-insecure-version",
    "code": "S508",
    "linter": "flake8-bandit",
    "summary": "The use of SNMPv1 and SNMPv2 is insecure. Use SNMPv3 if able.",
    "message_formats": [
      "The use of SNMPv1 and SNMPv2 is insecure. Use SNMPv3 if able."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "snmp-weak-cryptography",
    "code": "S509",
    "linter": "flake8-bandit",
    "summary": "You should not use SNMPv3 without encryption. `noAuthNoPriv` & `authNoPriv` is insecure.",
    "message_formats": [
      "You should not use SNMPv3 without encryption. `noAuthNoPriv` & `authNoPriv` is insecure."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "paramiko-call",
    "code": "S601",
    "linter": "flake8-bandit",
    "summary": "Possible shell injection via Paramiko call; check inputs are properly sanitized",
    "message_formats": [
      "Possible shell injection via Paramiko call; check inputs are properly sanitized"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "subprocess-popen-with-shell-equals-true",
    "code": "S602",
    "linter": "flake8-bandit",
    "summary": "`subprocess` call with `shell=True` seems safe, but may be changed in the future; consider rewriting without `shell`",
    "message_formats": [
      "`subprocess` call with `shell=True` seems safe, but may be changed in the future; consider rewriting without `shell`",
      "`subprocess` call with `shell=True` identified, security issue"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "subprocess-without-shell-equals-true",
    "code": "S603",
    "linter": "flake8-bandit",
    "summary": "`subprocess` call: check for execution of untrusted input",
    "message_formats": [
      "`subprocess` call: check for execution of untrusted input"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-with-shell-equals-true",
    "code": "S604",
    "linter": "flake8-bandit",
    "summary": "Function call with `shell=True` parameter identified, security issue",
    "message_formats": [
      "Function call with `shell=True` parameter identified, security issue"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "start-process-with-a-shell",
    "code": "S605",
    "linter": "flake8-bandit",
    "summary": "Starting a process with a shell: seems safe, but may be changed in the future; consider rewriting without `shell`",
    "message_formats": [
      "Starting a process with a shell: seems safe, but may be changed in the future; consider rewriting without `shell`",
      "Starting a process with a shell, possible injection detected"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "start-process-with-no-shell",
    "code": "S606",
    "linter": "flake8-bandit",
    "summary": "Starting a process without a shell",
    "message_formats": [
      "Starting a process without a shell"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "start-process-with-partial-path",
    "code": "S607",
    "linter": "flake8-bandit",
    "summary": "Starting a process with a partial executable path",
    "message_formats": [
      "Starting a process with a partial executable path"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "hardcoded-sql-expression",
    "code": "S608",
    "linter": "flake8-bandit",
    "summary": "Possible SQL injection vector through string-based query construction",
    "message_formats": [
      "Possible SQL injection vector through string-based query construction"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for strings that resemble SQL statements involved in some form\nstring building operation.\n\n## Why is this bad?\nSQL injection is a common attack vector for web applications. Directly\ninterpolating user input into SQL statements should always be avoided.\nInstead, favor parameterized queries, in which the SQL statement is\nprovided separately from its parameters, as supported by `psycopg3`\nand other database drivers and ORMs.\n\n## Example\n```python\nquery = \"DELETE FROM foo WHERE id = '%s'\" % identifier\n```\n\n## References\n- [B608: Test for SQL injection](https://bandit.readthedocs.io/en/latest/plugins/b608_hardcoded_sql_expressions.html)\n- [psycopg3: Server-side binding](https://www.psycopg.org/psycopg3/docs/basic/from_pg2.html#server-side-binding)\n"
  },
  {
    "name": "unix-command-wildcard-injection",
    "code": "S609",
    "linter": "flake8-bandit",
    "summary": "Possible wildcard injection in call due to `*` usage",
    "message_formats": [
      "Possible wildcard injection in call due to `*` usage"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-config-insecure-listen",
    "code": "S612",
    "linter": "flake8-bandit",
    "summary": "Use of insecure `logging.config.listen` detected",
    "message_formats": [
      "Use of insecure `logging.config.listen` detected"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "jinja2-autoescape-false",
    "code": "S701",
    "linter": "flake8-bandit",
    "summary": "Using jinja2 templates with `autoescape=False` is dangerous and can lead to XSS. Ensure `autoescape=True` or use the `select_autoescape` function.",
    "message_formats": [
      "Using jinja2 templates with `autoescape=False` is dangerous and can lead to XSS. Ensure `autoescape=True` or use the `select_autoescape` function.",
      "By default, jinja2 sets `autoescape` to `False`. Consider using `autoescape=True` or the `select_autoescape` function to mitigate XSS vulnerabilities."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "blind-except",
    "code": "BLE001",
    "linter": "flake8-blind-except",
    "summary": "Do not catch blind exception: `{name}`",
    "message_formats": [
      "Do not catch blind exception: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `except` clauses that catch all exceptions.\n\n## Why is this bad?\nOverly broad `except` clauses can lead to unexpected behavior, such as\ncatching `KeyboardInterrupt` or `SystemExit` exceptions that prevent the\nuser from exiting the program.\n\nInstead of catching all exceptions, catch only those that are expected to\nbe raised in the `try` block.\n\n## Example\n```python\ntry:\n    foo()\nexcept BaseException:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    foo()\nexcept FileNotFoundError:\n    ...\n```\n\n## References\n- [Python documentation: The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)\n- [Python documentation: Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)\n"
  },
  {
    "name": "boolean-positional-arg-in-function-definition",
    "code": "FBT001",
    "linter": "flake8-boolean-trap",
    "summary": "Boolean positional arg in function definition",
    "message_formats": [
      "Boolean positional arg in function definition"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for boolean positional arguments in function definitions.\n\n## Why is this bad?\nCalling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller, and to future\nreaders of the code.\n\nThe use of a boolean will also limit the function to only two possible\nbehaviors, which makes the function difficult to extend in the future.\n\n## Example\n```python\nfrom math import ceil, floor\n\n\ndef round_number(number: float, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, True)  # What does `True` mean?\nround_number(1.5, False)  # What does `False` mean?\n```\n\nInstead, refactor into separate implementations:\n```python\nfrom math import ceil, floor\n\n\ndef round_up(number: float) -> int:\n    return ceil(number)\n\n\ndef round_down(number: float) -> int:\n    return floor(number)\n\n\nround_up(1.5)\nround_down(1.5)\n```\n\nOr, refactor to use an `Enum`:\n```python\nfrom enum import Enum\n\n\nclass RoundingMethod(Enum):\n    UP = 1\n    DOWN = 2\n\n\ndef round_number(value: float, method: RoundingMethod) -> float:\n    ...\n```\n\n## References\n- [Python documentation: Calls](https://docs.python.org/3/reference/expressions.html#calls)\n- [_How to Avoid The Boolean Trap_ by Adam Johnson](https://adamj.eu/tech/2021/07/10/python-type-hints-how-to-avoid-the-boolean-trap/)\n"
  },
  {
    "name": "boolean-default-value-in-function-definition",
    "code": "FBT002",
    "linter": "flake8-boolean-trap",
    "summary": "Boolean default value in function definition",
    "message_formats": [
      "Boolean default value in function definition"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of booleans as default values in function definitions.\n\n## Why is this bad?\nCalling a function with boolean default means that the keyword argument\nargument can be omitted, which makes the function call ambiguous.\n\nInstead, define the relevant argument as keyword-only.\n\n## Example\n```python\nfrom math import ceil, floor\n\n\ndef round_number(number: float, *, up: bool = True) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5)\nround_number(1.5, up=False)\n```\n\nUse instead:\n```python\nfrom math import ceil, floor\n\n\ndef round_number(number: float, *, up: bool) -> int:\n    return ceil(number) if up else floor(number)\n\n\nround_number(1.5, up=True)\nround_number(1.5, up=False)\n```\n\n## References\n- [Python documentation: Calls](https://docs.python.org/3/reference/expressions.html#calls)\n- [_How to Avoid The Boolean Trap_ by Adam Johnson](https://adamj.eu/tech/2021/07/10/python-type-hints-how-to-avoid-the-boolean-trap/)\n"
  },
  {
    "name": "boolean-positional-value-in-function-call",
    "code": "FBT003",
    "linter": "flake8-boolean-trap",
    "summary": "Boolean positional value in function call",
    "message_formats": [
      "Boolean positional value in function call"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for boolean positional arguments in function calls.\n\n## Why is this bad?\nCalling a function with boolean positional arguments is confusing as the\nmeaning of the boolean value is not clear to the caller, and to future\nreaders of the code.\n\n## Example\n```python\ndef foo(flag: bool) -> None:\n    ...\n\n\nfoo(True)\n```\n\nUse instead:\n```python\ndef foo(flag: bool) -> None:\n    ...\n\n\nfoo(flag=True)\n```\n\n## References\n- [Python documentation: Calls](https://docs.python.org/3/reference/expressions.html#calls)\n- [_How to Avoid The Boolean Trap_ by Adam Johnson](https://adamj.eu/tech/2021/07/10/python-type-hints-how-to-avoid-the-boolean-trap/)\n"
  },
  {
    "name": "unary-prefix-increment",
    "code": "B002",
    "linter": "flake8-bugbear",
    "summary": "Python does not support the unary prefix increment",
    "message_formats": [
      "Python does not support the unary prefix increment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of the unary prefix increment operator (e.g., `++n`).\n\n## Why is this bad?\nPython does not support the unary prefix increment operator. Writing `++n`\nis equivalent to `+(+(n))`, which is equivalent to `n`.\n\n## Example\n```python\n++n\n```\n\nUse instead:\n```python\nn += 1\n```\n\n## References\n- [Python documentation: Unary arithmetic and bitwise operations](https://docs.python.org/3/reference/expressions.html#unary-arithmetic-and-bitwise-operations)\n- [Python documentation: Augmented assignment statements](https://docs.python.org/3/reference/simple_stmts.html#augmented-assignment-statements)\n"
  },
  {
    "name": "assignment-to-os-environ",
    "code": "B003",
    "linter": "flake8-bugbear",
    "summary": "Assigning to `os.environ` doesn't clear the environment",
    "message_formats": [
      "Assigning to `os.environ` doesn't clear the environment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for assignments to `os.environ`.\n\n## Why is this bad?\nIn Python, `os.environ` is a mapping that represents the environment of the\ncurrent process.\n\nHowever, reassigning to `os.environ` does not clear the environment. Instead,\nit merely updates the `os.environ` for the current process. This can lead to\nunexpected behavior, especially when running the program in a subprocess.\n\nInstead, use `os.environ.clear()` to clear the environment, or use the\n`env` argument of `subprocess.Popen` to pass a custom environment to\na subprocess.\n\n## Example\n```python\nimport os\n\nos.environ = {\"foo\": \"bar\"}\n```\n\nUse instead:\n```python\nimport os\n\nos.environ.clear()\nos.environ[\"foo\"] = \"bar\"\n```\n\n## References\n- [Python documentation: `os.environ`](https://docs.python.org/3/library/os.html#os.environ)\n- [Python documentation: `subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen)\n"
  },
  {
    "name": "unreliable-callable-check",
    "code": "B004",
    "linter": "flake8-bugbear",
    "summary": "Using `hasattr(x, '__call__')` to test if x is callable is unreliable. Use `callable(x)` for consistent results.",
    "message_formats": [
      "Using `hasattr(x, '__call__')` to test if x is callable is unreliable. Use `callable(x)` for consistent results."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `hasattr` to test if an object is callable (e.g.,\n`hasattr(obj, \"__call__\")`).\n\n## Why is this bad?\nUsing `hasattr` is an unreliable mechanism for testing if an object is\ncallable. If `obj` implements a custom `__getattr__`, or if its `__call__`\nis itself not callable, you may get misleading results.\n\nInstead, use `callable(obj)` to test if `obj` is callable.\n\n## Example\n```python\nhasattr(obj, \"__call__\")\n```\n\nUse instead:\n```python\ncallable(obj)\n```\n\n## References\n- [Python documentation: `callable`](https://docs.python.org/3/library/functions.html#callable)\n- [Python documentation: `hasattr`](https://docs.python.org/3/library/functions.html#hasattr)\n- [Python documentation: `__getattr__`](https://docs.python.org/3/reference/datamodel.html#object.__getattr__)\n- [Python documentation: `__call__`](https://docs.python.org/3/reference/datamodel.html#object.__call__)\n"
  },
  {
    "name": "strip-with-multi-characters",
    "code": "B005",
    "linter": "flake8-bugbear",
    "summary": "Using `.strip()` with multi-character strings is misleading the reader",
    "message_formats": [
      "Using `.strip()` with multi-character strings is misleading the reader"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of multi-character strings in `.strip()`, `.lstrip()`, and\n`.rstrip()` calls.\n\n## Why is this bad?\nAll characters in the call to `.strip()`, `.lstrip()`, or `.rstrip()` are\nremoved from the leading and trailing ends of the string. If the string\ncontains multiple characters, the reader may be misled into thinking that\na prefix or suffix is being removed, rather than a set of characters.\n\nIn Python 3.9 and later, you can use `str#removeprefix` and\n`str#removesuffix` to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\n## Example\n```python\n\"abcba\".strip(\"ab\")  # \"c\"\n```\n\nUse instead:\n```python\n\"abcba\".removeprefix(\"ab\").removesuffix(\"ba\")  # \"c\"\n```\n\n## References\n- [Python documentation: `str.strip`](https://docs.python.org/3/library/stdtypes.html#str.strip)\n"
  },
  {
    "name": "mutable-argument-default",
    "code": "B006",
    "linter": "flake8-bugbear",
    "summary": "Do not use mutable data structures for argument defaults",
    "message_formats": [
      "Do not use mutable data structures for argument defaults"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of mutable objects as function argument defaults.\n\n## Why is this bad?\nFunction defaults are evaluated once, when the function is defined.\n\nThe same mutable object is then shared across all calls to the function.\nIf the object is modified, those modifications will persist across calls,\nwhich can lead to unexpected behavior.\n\nInstead, prefer to use immutable data structures, or take `None` as a\ndefault, and initialize a new mutable object inside the function body\nfor each call.\n\n## Example\n```python\ndef add_to_list(item, some_list=[]):\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [0, 1]\n```\n\nUse instead:\n```python\ndef add_to_list(item, some_list=None):\n    if some_list is None:\n        some_list = []\n    some_list.append(item)\n    return some_list\n\n\nl1 = add_to_list(0)  # [0]\nl2 = add_to_list(1)  # [1]\n```\n\n## References\n- [Python documentation: Default Argument Values](https://docs.python.org/3/tutorial/controlflow.html#default-argument-values)\n"
  },
  {
    "name": "unused-loop-control-variable",
    "code": "B007",
    "linter": "flake8-bugbear",
    "summary": "Loop control variable `{name}` not used within loop body",
    "message_formats": [
      "Loop control variable `{name}` not used within loop body",
      "Loop control variable `{name}` may not be used within loop body"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for unused variables in loops (e.g., `for` and `while` statements).\n\n## Why is this bad?\nDefining a variable in a loop statement that is never used can confuse\nreaders.\n\nIf the variable is intended to be unused (e.g., to facilitate\ndestructuring of a tuple or other object), prefix it with an underscore\nto indicate the intent. Otherwise, remove the variable entirely.\n\n## Example\n```python\nfor i, j in foo:\n    bar(i)\n```\n\nUse instead:\n```python\nfor i, _j in foo:\n    bar(i)\n```\n\n## References\n- [PEP 8: Naming Conventions](https://peps.python.org/pep-0008/#naming-conventions)\n"
  },
  {
    "name": "function-call-in-default-argument",
    "code": "B008",
    "linter": "flake8-bugbear",
    "summary": "Do not perform function call `{name}` in argument defaults",
    "message_formats": [
      "Do not perform function call `{name}` in argument defaults",
      "Do not perform function call in argument defaults"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function calls in default function arguments.\n\n## Why is this bad?\nAny function call that's used in a default argument will only be performed\nonce, at definition time. The returned value will then be reused by all\ncalls to the function, which can lead to unexpected behaviour.\n\n## Example\n```python\ndef create_list() -> list[int]:\n    return [1, 2, 3]\n\n\ndef mutable_default(arg: list[int] = create_list()) -> list[int]:\n    arg.append(4)\n    return arg\n```\n\nUse instead:\n```python\ndef better(arg: list[int] | None = None) -> list[int]:\n    if arg is None:\n        arg = create_list()\n\n    arg.append(4)\n    return arg\n```\n\n## Options\n- `flake8-bugbear.extend-immutable-calls`\n"
  },
  {
    "name": "get-attr-with-constant",
    "code": "B009",
    "linter": "flake8-bugbear",
    "summary": "Do not call `getattr` with a constant attribute value. It is not any safer than normal property access.",
    "message_formats": [
      "Do not call `getattr` with a constant attribute value. It is not any safer than normal property access."
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `getattr` that take a constant attribute value as an\nargument (e.g., `getattr(obj, \"foo\")`).\n\n## Why is this bad?\n`getattr` is used to access attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over `getattr` calls, as the former is\nmore concise and idiomatic.\n\n\n## Example\n```python\ngetattr(obj, \"foo\")\n```\n\nUse instead:\n```python\nobj.foo\n```\n\n## References\n- [Python documentation: `getattr`](https://docs.python.org/3/library/functions.html#getattr)\n"
  },
  {
    "name": "set-attr-with-constant",
    "code": "B010",
    "linter": "flake8-bugbear",
    "summary": "Do not call `setattr` with a constant attribute value. It is not any safer than normal property access.",
    "message_formats": [
      "Do not call `setattr` with a constant attribute value. It is not any safer than normal property access."
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `setattr` that take a constant attribute value as an\nargument (e.g., `setattr(obj, \"foo\", 42)`).\n\n## Why is this bad?\n`setattr` is used to set attributes dynamically. If the attribute is\ndefined as a constant, it is no safer than a typical property access. When\npossible, prefer property access over `setattr` calls, as the former is\nmore concise and idiomatic.\n\n## Example\n```python\nsetattr(obj, \"foo\", 42)\n```\n\nUse instead:\n```python\nobj.foo = 42\n```\n\n## References\n- [Python documentation: `setattr`](https://docs.python.org/3/library/functions.html#setattr)\n"
  },
  {
    "name": "assert-false",
    "code": "B011",
    "linter": "flake8-bugbear",
    "summary": "Do not `assert False` (`python -O` removes these calls), raise `AssertionError()`",
    "message_formats": [
      "Do not `assert False` (`python -O` removes these calls), raise `AssertionError()`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `assert False`.\n\n## Why is this bad?\nPython removes `assert` statements when running in optimized mode\n(`python -O`), making `assert False` an unreliable means of\nraising an `AssertionError`.\n\nInstead, raise an `AssertionError` directly.\n\n## Example\n```python\nassert False\n```\n\nUse instead:\n```python\nraise AssertionError\n```\n\n## References\n- [Python documentation: `assert`](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement)\n"
  },
  {
    "name": "jump-statement-in-finally",
    "code": "B012",
    "linter": "flake8-bugbear",
    "summary": "`{name}` inside `finally` blocks cause exceptions to be silenced",
    "message_formats": [
      "`{name}` inside `finally` blocks cause exceptions to be silenced"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `break`, `continue`, and `return` statements in `finally`\nblocks.\n\n## Why is this bad?\nThe use of `break`, `continue`, and `return` statements in `finally` blocks\ncan cause exceptions to be silenced.\n\n`finally` blocks execute regardless of whether an exception is raised. If a\n`break`, `continue`, or `return` statement is reached in a `finally` block,\nany exception raised in the `try` or `except` blocks will be silenced.\n\n## Example\n```python\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n    finally:\n        return 299792458  # `ValueError` is silenced\n```\n\nUse instead:\n```python\ndef speed(distance, time):\n    try:\n        return distance / time\n    except ZeroDivisionError:\n        raise ValueError(\"Time cannot be zero\")\n```\n\n## References\n- [Python documentation: The `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)\n"
  },
  {
    "name": "redundant-tuple-in-exception-handler",
    "code": "B013",
    "linter": "flake8-bugbear",
    "summary": "A length-one tuple literal is redundant. Write `except {name}` instead of `except ({name},)`.",
    "message_formats": [
      "A length-one tuple literal is redundant. Write `except {name}` instead of `except ({name},)`."
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for single-element tuples in exception handlers (e.g.,\n`except (ValueError,):`).\n\n## Why is this bad?\nA tuple with a single element can be more concisely and idiomatically\nexpressed as a single value.\n\n## Example\n```python\ntry:\n    ...\nexcept (ValueError,):\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError:\n    ...\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n"
  },
  {
    "name": "duplicate-handler-exception",
    "code": "B014",
    "linter": "flake8-bugbear",
    "summary": "Exception handler with duplicate exception: `{name}`",
    "message_formats": [
      "Exception handler with duplicate exception: `{name}`",
      "Exception handler with duplicate exceptions: {names}"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for exception handlers that catch duplicate exceptions.\n\n## Why is this bad?\nIncluding the same exception multiple times in the same handler is redundant,\nas the first exception will catch the exception, making the second exception\nunreachable. The same applies to exception hierarchies, as a handler for a\nparent exception (like `Exception`) will also catch child exceptions (like\n`ValueError`).\n\n## Example\n```python\ntry:\n    ...\nexcept (Exception, ValueError):  # `Exception` includes `ValueError`.\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept Exception:\n    ...\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n- [Python documentation: Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)\n"
  },
  {
    "name": "useless-comparison",
    "code": "B015",
    "linter": "flake8-bugbear",
    "summary": "Pointless comparison. This comparison does nothing but waste CPU instructions. Either prepend `assert` or remove it.",
    "message_formats": [
      "Pointless comparison. This comparison does nothing but waste CPU instructions. Either prepend `assert` or remove it."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for useless comparisons.\n\n## Why is this bad?\nUseless comparisons have no effect on the program, and are often included\nby mistake. If the comparison is intended to enforce an invariant, prepend\nthe comparison with an `assert`. Otherwise, remove it entirely.\n\n## Example\n```python\nfoo == bar\n```\n\nUse instead:\n```python\nassert foo == bar, \"`foo` and `bar` should be equal.\"\n```\n\n## References\n- [Python documentation: `assert` statement](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement)\n"
  },
  {
    "name": "raise-literal",
    "code": "B016",
    "linter": "flake8-bugbear",
    "summary": "Cannot raise a literal. Did you intend to return it or raise an Exception?",
    "message_formats": [
      "Cannot raise a literal. Did you intend to return it or raise an Exception?"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `raise` statements that raise a literal value.\n\n## Why is this bad?\n`raise` must be followed by an exception instance or an exception class,\nand exceptions must be instances of `BaseException` or a subclass thereof.\nRaising a literal will raise a `TypeError` at runtime.\n\n## Example\n```python\nraise \"foo\"\n```\n\nUse instead:\n```python\nraise Exception(\"foo\")\n```\n\n## References\n- [Python documentation: `raise` statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement)\n"
  },
  {
    "name": "assert-raises-exception",
    "code": "B017",
    "linter": "flake8-bugbear",
    "summary": "`assertRaises(Exception)` should be considered evil",
    "message_formats": [
      "`assertRaises(Exception)` should be considered evil",
      "`pytest.raises(Exception)` should be considered evil"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `self.assertRaises(Exception)` or `pytest.raises(Exception)`.\n\n## Why is this bad?\nThese forms catch every `Exception`, which can lead to tests passing even\nif, e.g., the code being tested is never executed due to a typo.\n\nEither assert for a more specific exception (builtin or custom), or use\n`assertRaisesRegex` or `pytest.raises(..., match=<REGEX>)` respectively.\n\n## Example\n```python\nself.assertRaises(Exception, foo)\n```\n\nUse instead:\n```python\nself.assertRaises(SomeSpecificException, foo)\n```\n"
  },
  {
    "name": "useless-expression",
    "code": "B018",
    "linter": "flake8-bugbear",
    "summary": "Found useless expression. Either assign it to a variable or remove it.",
    "message_formats": [
      "Found useless expression. Either assign it to a variable or remove it.",
      "Found useless attribute access. Either assign it to a variable or remove it."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for useless expressions.\n\n## Why is this bad?\nUseless expressions have no effect on the program, and are often included\nby mistake. Assign a useless expression to a variable, or remove it\nentirely.\n\n## Example\n```python\n1 + 1\n```\n\nUse instead:\n```python\nfoo = 1 + 1\n```\n"
  },
  {
    "name": "cached-instance-method",
    "code": "B019",
    "linter": "flake8-bugbear",
    "summary": "Use of `functools.lru_cache` or `functools.cache` on methods can lead to memory leaks",
    "message_formats": [
      "Use of `functools.lru_cache` or `functools.cache` on methods can lead to memory leaks"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of the `functools.lru_cache` and `functools.cache`\ndecorators on methods.\n\n## Why is this bad?\nUsing the `functools.lru_cache` and `functools.cache` decorators on methods\ncan lead to memory leaks, as the global cache will retain a reference to\nthe instance, preventing it from being garbage collected.\n\nInstead, refactor the method to depend only on its arguments and not on the\ninstance of the class, or use the `@lru_cache` decorator on a function\noutside of the class.\n\n## Example\n```python\nfrom functools import lru_cache\n\n\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    @lru_cache\n    def squared(self):\n        return square(self.value)\n```\n\nUse instead:\n```python\nfrom functools import lru_cache\n\n\n@lru_cache\ndef square(x: int) -> int:\n    return x * x\n\n\nclass Number:\n    value: int\n\n    def squared(self):\n        return square(self.value)\n```\n\n## References\n- [Python documentation: `functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache)\n- [Python documentation: `functools.cache`](https://docs.python.org/3/library/functools.html#functools.cache)\n- [don't lru_cache methods!](https://www.youtube.com/watch?v=sVjtp6tGo0g)\n"
  },
  {
    "name": "loop-variable-overrides-iterator",
    "code": "B020",
    "linter": "flake8-bugbear",
    "summary": "Loop control variable `{name}` overrides iterable it iterates",
    "message_formats": [
      "Loop control variable `{name}` overrides iterable it iterates"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for loop control variables that override the loop iterable.\n\n## Why is this bad?\nLoop control variables should not override the loop iterable, as this can\nlead to confusing behavior.\n\nInstead, use a distinct variable name for any loop control variables.\n\n## Example\n```python\nitems = [1, 2, 3]\n\nfor items in items:\n    print(items)\n```\n\nUse instead:\n```python\nitems = [1, 2, 3]\n\nfor item in items:\n    print(item)\n```\n\n## References\n- [Python documentation: The `for` statement](https://docs.python.org/3/reference/compound_stmts.html#the-for-statement)\n"
  },
  {
    "name": "f-string-docstring",
    "code": "B021",
    "linter": "flake8-bugbear",
    "summary": "f-string used as docstring. Python will interpret this as a joined string, rather than a docstring.",
    "message_formats": [
      "f-string used as docstring. Python will interpret this as a joined string, rather than a docstring."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that are written via f-strings.\n\n## Why is this bad?\nPython will interpret the f-string as a joined string, rather than as a\ndocstring. As such, the \"docstring\" will not be accessible via the\n`__doc__` attribute, nor will it be picked up by any automated\ndocumentation tooling.\n\n## Example\n```python\ndef foo():\n    f\"\"\"Not a docstring.\"\"\"\n```\n\nUse instead:\n```python\ndef foo():\n    \"\"\"A docstring.\"\"\"\n```\n\n## References\n- [PEP 257](https://peps.python.org/pep-0257/)\n- [Python documentation: Formatted string literals](https://docs.python.org/3/reference/lexical_analysis.html#f-strings)\n"
  },
  {
    "name": "useless-contextlib-suppress",
    "code": "B022",
    "linter": "flake8-bugbear",
    "summary": "No arguments passed to `contextlib.suppress`. No exceptions will be suppressed and therefore this context manager is redundant",
    "message_formats": [
      "No arguments passed to `contextlib.suppress`. No exceptions will be suppressed and therefore this context manager is redundant"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `contextlib.suppress` without arguments.\n\n## Why is this bad?\n`contextlib.suppress` is a context manager that suppresses exceptions. It takes,\nas arguments, the exceptions to suppress within the enclosed block. If no\nexceptions are specified, then the context manager won't suppress any\nexceptions, and is thus redundant.\n\nConsider adding exceptions to the `contextlib.suppress` call, or removing the\ncontext manager entirely.\n\n## Example\n```python\nimport contextlib\n\nwith contextlib.suppress():\n    foo()\n```\n\nUse instead:\n```python\nimport contextlib\n\nwith contextlib.suppress(Exception):\n    foo()\n```\n\n## References\n- [Python documentation: contextlib.suppress](https://docs.python.org/3/library/contextlib.html#contextlib.suppress)\n"
  },
  {
    "name": "function-uses-loop-variable",
    "code": "B023",
    "linter": "flake8-bugbear",
    "summary": "Function definition does not bind loop variable `{name}`",
    "message_formats": [
      "Function definition does not bind loop variable `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function definitions that use a loop variable.\n\n## Why is this bad?\nThe loop variable is not bound in the function definition, so it will always\nhave the value it had in the last iteration when the function is called.\n\nInstead, consider using a default argument to bind the loop variable at\nfunction definition time. Or, use `functools.partial`.\n\n## Example\n```python\nadders = [lambda x: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [3, 3, 3]\n```\n\nUse instead:\n```python\nadders = [lambda x, i=i: x + i for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n```\n\nOr:\n```python\nfrom functools import partial\n\nadders = [partial(lambda x, i: x + i, i) for i in range(3)]\nvalues = [adder(1) for adder in adders]  # [1, 2, 3]\n```\n\n## References\n- [The Hitchhiker's Guide to Python: Late Binding Closures](https://docs.python-guide.org/writing/gotchas/#late-binding-closures)\n- [Python documentation: functools.partial](https://docs.python.org/3/library/functools.html#functools.partial)\n"
  },
  {
    "name": "abstract-base-class-without-abstract-method",
    "code": "B024",
    "linter": "flake8-bugbear",
    "summary": "`{name}` is an abstract base class, but it has no abstract methods",
    "message_formats": [
      "`{name}` is an abstract base class, but it has no abstract methods"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for abstract classes without abstract methods.\n\n## Why is this bad?\nAbstract base classes are used to define interfaces. If they have no abstract\nmethods, they are not useful.\n\nIf the class is not meant to be used as an interface, it should not be an\nabstract base class. Remove the `ABC` base class from the class definition,\nor add an abstract method to the class.\n\n## Example\n```python\nfrom abc import ABC\n\n\nclass Foo(ABC):\n    def method(self):\n        bar()\n```\n\nUse instead:\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Foo(ABC):\n    @abstractmethod\n    def method(self):\n        bar()\n```\n\n## References\n- [Python documentation: `abc`](https://docs.python.org/3/library/abc.html)\n"
  },
  {
    "name": "duplicate-try-block-exception",
    "code": "B025",
    "linter": "flake8-bugbear",
    "summary": "try-except block with duplicate exception `{name}`",
    "message_formats": [
      "try-except block with duplicate exception `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `try-except` blocks with duplicate exception handlers.\n\n## Why is this bad?\nDuplicate exception handlers are redundant, as the first handler will catch\nthe exception, making the second handler unreachable.\n\n## Example\n```python\ntry:\n    ...\nexcept ValueError:\n    ...\nexcept ValueError:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError:\n    ...\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n"
  },
  {
    "name": "star-arg-unpacking-after-keyword-arg",
    "code": "B026",
    "linter": "flake8-bugbear",
    "summary": "Star-arg unpacking after a keyword argument is strongly discouraged",
    "message_formats": [
      "Star-arg unpacking after a keyword argument is strongly discouraged"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function calls that use star-argument unpacking after providing a\nkeyword argument\n\n## Why is this bad?\nIn Python, you can use star-argument unpacking to pass a list or tuple of\narguments to a function.\n\nProviding a star-argument after a keyword argument can lead to confusing\nbehavior, and is only supported for backwards compatibility.\n\n## Example\n```python\ndef foo(x, y, z):\n    return x, y, z\n\n\nfoo(1, 2, 3)  # (1, 2, 3)\nfoo(1, *[2, 3])  # (1, 2, 3)\n# foo(x=1, *[2, 3])  # TypeError\n# foo(y=2, *[1, 3])  # TypeError\nfoo(z=3, *[1, 2])  # (1, 2, 3)  # No error, but confusing!\n```\n\nUse instead:\n```python\ndef foo(x, y, z):\n    return x, y, z\n\n\nfoo(1, 2, 3)  # (1, 2, 3)\nfoo(x=1, y=2, z=3)  # (1, 2, 3)\nfoo(*[1, 2, 3])  # (1, 2, 3)\nfoo(*[1, 2], 3)  # (1, 2, 3)\n```\n\n## References\n- [Python documentation: Calls](https://docs.python.org/3/reference/expressions.html#calls)\n- [Disallow iterable argument unpacking after a keyword argument?](https://github.com/python/cpython/issues/82741)\n"
  },
  {
    "name": "empty-method-without-abstract-decorator",
    "code": "B027",
    "linter": "flake8-bugbear",
    "summary": "`{name}` is an empty method in an abstract base class, but has no abstract decorator",
    "message_formats": [
      "`{name}` is an empty method in an abstract base class, but has no abstract decorator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for empty methods in abstract base classes without an abstract\ndecorator.\n\n## Why is this bad?\nEmpty methods in abstract base classes without an abstract decorator are\nindicative of unfinished code or a mistake.\n\nInstead, add an abstract method decorated to indicate that it is abstract,\nor implement the method.\n\n## Example\n```python\nfrom abc import ABC\n\n\nclass Foo(ABC):\n    def method(self):\n        ...\n```\n\nUse instead:\n```python\nfrom abc import ABC, abstractmethod\n\n\nclass Foo(ABC):\n    @abstractmethod\n    def method(self):\n        ...\n```\n\n## References\n- [Python documentation: abc](https://docs.python.org/3/library/abc.html)\n"
  },
  {
    "name": "no-explicit-stacklevel",
    "code": "B028",
    "linter": "flake8-bugbear",
    "summary": "No explicit `stacklevel` keyword argument found",
    "message_formats": [
      "No explicit `stacklevel` keyword argument found"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `warnings.warn` calls without an explicit `stacklevel` keyword\nargument.\n\n## Why is this bad?\nThe `warnings.warn` method uses a `stacklevel` of 1 by default, which\nlimits the rendered stack trace to that of the line on which the\n`warn` method is called.\n\nIt's recommended to use a `stacklevel` of 2 or higher, give the caller\nmore context about the warning.\n\n## Example\n```python\nwarnings.warn(\"This is a warning\")\n```\n\nUse instead:\n```python\nwarnings.warn(\"This is a warning\", stacklevel=2)\n```\n"
  },
  {
    "name": "except-with-empty-tuple",
    "code": "B029",
    "linter": "flake8-bugbear",
    "summary": "Using `except ():` with an empty tuple does not catch anything; add exceptions to handle",
    "message_formats": [
      "Using `except ():` with an empty tuple does not catch anything; add exceptions to handle"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for exception handlers that catch an empty tuple.\n\n## Why is this bad?\nAn exception handler that catches an empty tuple will not catch anything,\nand is indicative of a mistake. Instead, add exceptions to the `except`\nclause.\n\n## Example\n```python\ntry:\n    1 / 0\nexcept ():\n    ...\n```\n\nUse instead:\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n"
  },
  {
    "name": "except-with-non-exception-classes",
    "code": "B030",
    "linter": "flake8-bugbear",
    "summary": "`except` handlers should only be exception classes or tuples of exception classes",
    "message_formats": [
      "`except` handlers should only be exception classes or tuples of exception classes"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for exception handlers that catch non-exception classes.\n\n## Why is this bad?\nCatching classes that do not inherit from `BaseException` will raise a\n`TypeError`.\n\n## Example\n```python\ntry:\n    1 / 0\nexcept 1:\n    ...\n```\n\nUse instead:\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    ...\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n- [Python documentation: Built-in Exceptions](https://docs.python.org/3/library/exceptions.html#built-in-exceptions)\n"
  },
  {
    "name": "reuse-of-groupby-generator",
    "code": "B031",
    "linter": "flake8-bugbear",
    "summary": "Using the generator returned from `itertools.groupby()` more than once will do nothing on the second usage",
    "message_formats": [
      "Using the generator returned from `itertools.groupby()` more than once will do nothing on the second usage"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for multiple usage of the generator returned from\n`itertools.groupby()`.\n\n## Why is this bad?\nUsing the generator more than once will do nothing on the second usage.\nIf that data is needed later, it should be stored as a list.\n\n## Examples:\n```python\nimport itertools\n\nfor name, group in itertools.groupby(data):\n    for _ in range(5):\n        do_something_with_the_group(group)\n```\n\nUse instead:\n```python\nimport itertools\n\nfor name, group in itertools.groupby(data):\n    values = list(group)\n    for _ in range(5):\n        do_something_with_the_group(values)\n```\n"
  },
  {
    "name": "unintentional-type-annotation",
    "code": "B032",
    "linter": "flake8-bugbear",
    "summary": "Possible unintentional type annotation (using `:`). Did you mean to assign (using `=`)?",
    "message_formats": [
      "Possible unintentional type annotation (using `:`). Did you mean to assign (using `=`)?"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the unintentional use of type annotations.\n\n## Why is this bad?\nThe use of a colon (`:`) in lieu of an assignment (`=`) can be syntactically valid, but\nis almost certainly a mistake when used in a subscript or attribute assignment.\n\n## Example\n```python\na[\"b\"]: 1\n```\n\nUse instead:\n```python\na[\"b\"] = 1\n```\n"
  },
  {
    "name": "duplicate-value",
    "code": "B033",
    "linter": "flake8-bugbear",
    "summary": "Sets should not contain duplicate item `{value}`",
    "message_formats": [
      "Sets should not contain duplicate item `{value}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for set literals that contain duplicate items.\n\n## Why is this bad?\nIn Python, sets are unordered collections of unique elements. Including a\nduplicate item in a set literal is redundant, as the duplicate item will be\nreplaced with a single item at runtime.\n\n## Example\n```python\n{1, 2, 3, 1}\n```\n\nUse instead:\n```python\n{1, 2, 3}\n```\n"
  },
  {
    "name": "raise-without-from-inside-except",
    "code": "B904",
    "linter": "flake8-bugbear",
    "summary": "Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling",
    "message_formats": [
      "Within an `except` clause, raise exceptions with `raise ... from err` or `raise ... from None` to distinguish them from errors in exception handling"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `raise` statements in exception handlers that lack a `from`\nclause.\n\n## Why is this bad?\nIn Python, `raise` can be used with or without an exception from which the\ncurrent exception is derived. This is known as exception chaining. When\nprinting the stack trace, chained exceptions are displayed in such a way\nso as make it easier to trace the exception back to its root cause.\n\nWhen raising an exception from within an `except` clause, always include a\n`from` clause to facilitate exception chaining. If the exception is not\nchained, it will be difficult to trace the exception back to its root cause.\n\n## Example\n```python\ntry:\n    ...\nexcept FileNotFoundError:\n    if ...:\n        raise RuntimeError(\"...\")\n    else:\n        raise UserWarning(\"...\")\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept FileNotFoundError as exc:\n    if ...:\n        raise RuntimeError(\"...\") from None\n    else:\n        raise UserWarning(\"...\") from exc\n```\n\n## References\n- [Python documentation: `raise` statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement)\n"
  },
  {
    "name": "zip-without-explicit-strict",
    "code": "B905",
    "linter": "flake8-bugbear",
    "summary": "`zip()` without an explicit `strict=` parameter",
    "message_formats": [
      "`zip()` without an explicit `strict=` parameter"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `zip` calls without an explicit `strict` parameter.\n\n## Why is this bad?\nBy default, if the iterables passed to `zip` are of different lengths, the\nresulting iterator will be silently truncated to the length of the shortest\niterable. This can lead to subtle bugs.\n\nUse the `strict` parameter to raise a `ValueError` if the iterables are of\nnon-uniform length.\n\n## Example\n```python\nzip(a, b)\n```\n\nUse instead:\n```python\nzip(a, b, strict=True)\n```\n\n## References\n- [Python documentation: `zip`](https://docs.python.org/3/library/functions.html#zip)\n"
  },
  {
    "name": "builtin-variable-shadowing",
    "code": "A001",
    "linter": "flake8-builtins",
    "summary": "Variable `{name}` is shadowing a Python builtin",
    "message_formats": [
      "Variable `{name}` is shadowing a Python builtin"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for variable (and function) assignments that use the same name\nas a builtin.\n\n## Why is this bad?\nReusing a builtin name for the name of a variable increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the variable for the\nbuiltin and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`flake8-builtins.builtins-ignorelist`] configuration option.\n\n## Example\n```python\ndef find_max(list_of_lists):\n    max = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            max = max(max, value)  # TypeError: 'int' object is not callable\n    return max\n```\n\nUse instead:\n```python\ndef find_max(list_of_lists):\n    result = 0\n    for flat_list in list_of_lists:\n        for value in flat_list:\n            result = max(result, value)\n    return result\n```\n\n## Options\n- `flake8-builtins.builtins-ignorelist`\n\n## References\n- [_Why is it a bad idea to name a variable `id` in Python?_](https://stackoverflow.com/questions/77552/id-is-a-bad-variable-name-in-python)\n"
  },
  {
    "name": "builtin-argument-shadowing",
    "code": "A002",
    "linter": "flake8-builtins",
    "summary": "Argument `{name}` is shadowing a Python builtin",
    "message_formats": [
      "Argument `{name}` is shadowing a Python builtin"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for any function arguments that use the same name as a builtin.\n\n## Why is this bad?\nReusing a builtin name for the name of an argument increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the argument for the\nbuiltin and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`flake8-builtins.builtins-ignorelist`] configuration option.\n\n## Example\n```python\ndef remove_duplicates(list, list2):\n    result = set()\n    for value in list:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)  # TypeError: 'list' object is not callable\n```\n\nUse instead:\n```python\ndef remove_duplicates(list1, list2):\n    result = set()\n    for value in list1:\n        result.add(value)\n    for value in list2:\n        result.add(value)\n    return list(result)\n```\n\n## Options\n- `flake8-builtins.builtins-ignorelist`\n\n## References\n- [_Is it bad practice to use a built-in function name as an attribute or method identifier?_](https://stackoverflow.com/questions/9109333/is-it-bad-practice-to-use-a-built-in-function-name-as-an-attribute-or-method-ide)\n- [_Why is it a bad idea to name a variable `id` in Python?_](https://stackoverflow.com/questions/77552/id-is-a-bad-variable-name-in-python)\n"
  },
  {
    "name": "builtin-attribute-shadowing",
    "code": "A003",
    "linter": "flake8-builtins",
    "summary": "Class attribute `{name}` is shadowing a Python builtin",
    "message_formats": [
      "Class attribute `{name}` is shadowing a Python builtin"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for any class attributes that use the same name as a builtin.\n\n## Why is this bad?\nReusing a builtin name for the name of an attribute increases the\ndifficulty of reading and maintaining the code, and can cause\nnon-obvious errors, as readers may mistake the attribute for the\nbuiltin and vice versa.\n\nBuiltins can be marked as exceptions to this rule via the\n[`flake8-builtins.builtins-ignorelist`] configuration option, or\nconverted to the appropriate dunder method.\n\n## Example\n```python\nclass Shadow:\n    def int():\n        return 0\n```\n\nUse instead:\n```python\nclass Shadow:\n    def to_int():\n        return 0\n```\n\nOr:\n```python\nclass Shadow:\n    # Callable as `int(shadow)`\n    def __int__():\n        return 0\n```\n\n## Options\n- `flake8-builtins.builtins-ignorelist`\n\n## References\n- [_Is it bad practice to use a built-in function name as an attribute or method identifier?_](https://stackoverflow.com/questions/9109333/is-it-bad-practice-to-use-a-built-in-function-name-as-an-attribute-or-method-ide)\n- [_Why is it a bad idea to name a variable `id` in Python?_](https://stackoverflow.com/questions/77552/id-is-a-bad-variable-name-in-python)\n"
  },
  {
    "name": "missing-trailing-comma",
    "code": "COM812",
    "linter": "flake8-commas",
    "summary": "Trailing comma missing",
    "message_formats": [
      "Trailing comma missing"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the absence of trailing commas.\n\n## Why is this bad?\nThe presence of a trailing comma can reduce diff size when parameters or\nelements are added or removed from function calls, function definitions,\nliterals, etc.\n\n## Example\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2\n}\n```\n\nUse instead:\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\n```\n"
  },
  {
    "name": "trailing-comma-on-bare-tuple",
    "code": "COM818",
    "linter": "flake8-commas",
    "summary": "Trailing comma on bare tuple prohibited",
    "message_formats": [
      "Trailing comma on bare tuple prohibited"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of trailing commas on bare (i.e., unparenthesized)\ntuples.\n\n## Why is this bad?\nThe presence of a misplaced comma will cause Python to interpret the value\nas a tuple, which can lead to unexpected behaviour.\n\n## Example\n```python\nimport json\n\n\nfoo = json.dumps({\"bar\": 1}),\n```\n\nUse instead:\n```python\nimport json\n\n\nfoo = json.dumps({\"bar\": 1})\n```\n\nIn the event that a tuple is intended, then use instead:\n```python\nimport json\n\n\nfoo = (json.dumps({\"bar\": 1}),)\n```\n"
  },
  {
    "name": "prohibited-trailing-comma",
    "code": "COM819",
    "linter": "flake8-commas",
    "summary": "Trailing comma prohibited",
    "message_formats": [
      "Trailing comma prohibited"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the presence of prohibited trailing commas.\n\n## Why is this bad?\nTrailing commas are not essential in some cases and can therefore be viewed\nas unnecessary.\n\n## Example\n```python\nfoo = (1, 2, 3,)\n```\n\nUse instead:\n```python\nfoo = (1, 2, 3)\n```\n"
  },
  {
    "name": "unnecessary-generator-list",
    "code": "C400",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary generator (rewrite as a `list` comprehension)",
    "message_formats": [
      "Unnecessary generator (rewrite as a `list` comprehension)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary generators that can be rewritten as `list`\ncomprehensions.\n\n## Why is this bad?\nIt is unnecessary to use `list` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\n## Examples\n```python\nlist(f(x) for x in foo)\n```\n\nUse instead:\n```python\n[f(x) for x in foo]\n```\n"
  },
  {
    "name": "unnecessary-generator-set",
    "code": "C401",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary generator (rewrite as a `set` comprehension)",
    "message_formats": [
      "Unnecessary generator (rewrite as a `set` comprehension)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary generators that can be rewritten as `set`\ncomprehensions.\n\n## Why is this bad?\nIt is unnecessary to use `set` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\n## Examples\n```python\nset(f(x) for x in foo)\n```\n\nUse instead:\n```python\n{f(x) for x in foo}\n```\n"
  },
  {
    "name": "unnecessary-generator-dict",
    "code": "C402",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary generator (rewrite as a `dict` comprehension)",
    "message_formats": [
      "Unnecessary generator (rewrite as a `dict` comprehension)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary generators that can be rewritten as `dict`\ncomprehensions.\n\n## Why is this bad?\nIt is unnecessary to use `dict` around a generator expression, since\nthere are equivalent comprehensions for these types. Using a\ncomprehension is clearer and more idiomatic.\n\n## Examples\n```python\ndict((x, f(x)) for x in foo)\n```\n\nUse instead:\n```python\n{x: f(x) for x in foo}\n```\n"
  },
  {
    "name": "unnecessary-list-comprehension-set",
    "code": "C403",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `list` comprehension (rewrite as a `set` comprehension)",
    "message_formats": [
      "Unnecessary `list` comprehension (rewrite as a `set` comprehension)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary list comprehensions.\n\n## Why is this bad?\nIt's unnecessary to use a list comprehension inside a call to `set`,\nsince there is an equivalent comprehension for this type.\n\n## Examples\n```python\nset([f(x) for x in foo])\n```\n\nUse instead:\n```python\n{f(x) for x in foo}\n```\n"
  },
  {
    "name": "unnecessary-list-comprehension-dict",
    "code": "C404",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `list` comprehension (rewrite as a `dict` comprehension)",
    "message_formats": [
      "Unnecessary `list` comprehension (rewrite as a `dict` comprehension)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary list comprehensions.\n\n## Why is this bad?\nIt's unnecessary to use a list comprehension inside a call to `dict`,\nsince there is an equivalent comprehension for this type.\n\n## Examples\n```python\ndict([(x, f(x)) for x in foo])\n```\n\nUse instead:\n```python\n{x: f(x) for x in foo}\n```\n"
  },
  {
    "name": "unnecessary-literal-set",
    "code": "C405",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{obj_type}` literal (rewrite as a `set` literal)",
    "message_formats": [
      "Unnecessary `{obj_type}` literal (rewrite as a `set` literal)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `set` calls that take unnecessary `list` or `tuple` literals\nas arguments.\n\n## Why is this bad?\nIt's unnecessary to use a list or tuple literal within a call to `set`.\nInstead, the expression can be rewritten as a set literal.\n\n## Examples\n```python\nset([1, 2])\nset((1, 2))\nset([])\n```\n\nUse instead:\n```python\n{1, 2}\n{1, 2}\nset()\n```\n"
  },
  {
    "name": "unnecessary-literal-dict",
    "code": "C406",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{obj_type}` literal (rewrite as a `dict` literal)",
    "message_formats": [
      "Unnecessary `{obj_type}` literal (rewrite as a `dict` literal)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `list` or `tuple` literals.\n\n## Why is this bad?\nIt's unnecessary to use a list or tuple literal within a call to `dict`.\nIt can be rewritten as a dict literal (`{}`).\n\n## Examples\n```python\ndict([(1, 2), (3, 4)])\ndict(((1, 2), (3, 4)))\ndict([])\n```\n\nUse instead:\n```python\n{1: 2, 3: 4}\n{1: 2, 3: 4}\n{}\n```\n"
  },
  {
    "name": "unnecessary-collection-call",
    "code": "C408",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{obj_type}` call (rewrite as a literal)",
    "message_formats": [
      "Unnecessary `{obj_type}` call (rewrite as a literal)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `dict`, `list` or `tuple` calls that can be\nrewritten as empty literals.\n\n## Why is this bad?\nIt's unnecessary to call e.g., `dict()` as opposed to using an empty\nliteral (`{}`). The former is slower because the name `dict` must be\nlooked up in the global scope in case it has been rebound.\n\n## Examples\n```python\ndict()\ndict(a=1, b=2)\nlist()\ntuple()\n```\n\nUse instead:\n```python\n{}\n{\"a\": 1, \"b\": 2}\n[]\n()\n```\n"
  },
  {
    "name": "unnecessary-literal-within-tuple-call",
    "code": "C409",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{literal}` literal passed to `tuple()` (rewrite as a `tuple` literal)",
    "message_formats": [
      "Unnecessary `{literal}` literal passed to `tuple()` (rewrite as a `tuple` literal)",
      "Unnecessary `{literal}` literal passed to `tuple()` (remove the outer call to `tuple()`)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `tuple` calls that take unnecessary list or tuple literals as\narguments.\n\n## Why is this bad?\nIt's unnecessary to use a list or tuple literal within a `tuple()` call,\nsince there is a literal syntax for these types.\n\nIf a list literal was passed, then it should be rewritten as a `tuple`\nliteral. Otherwise, if a tuple literal was passed, then the outer call\nto `list()` should be removed.\n\n## Examples\n```python\ntuple([1, 2])\ntuple((1, 2))\n```\n\nUse instead:\n```python\n(1, 2)\n(1, 2)\n```\n"
  },
  {
    "name": "unnecessary-literal-within-list-call",
    "code": "C410",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{literal}` literal passed to `list()` (remove the outer call to `list()`)",
    "message_formats": [
      "Unnecessary `{literal}` literal passed to `list()` (remove the outer call to `list()`)",
      "Unnecessary `{literal}` literal passed to `list()` (rewrite as a `list` literal)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `list` calls that take unnecessary list or tuple literals as\narguments.\n\n## Why is this bad?\nIt's unnecessary to use a list or tuple literal within a `list()` call,\nsince there is a literal syntax for these types.\n\nIf a list literal is passed in, then the outer call to `list()` should be\nremoved. Otherwise, if a tuple literal is passed in, then it should be\nrewritten as a `list` literal.\n\n## Examples\n```python\nlist([1, 2])\nlist((1, 2))\n```\n\nUse instead:\n```python\n[1, 2]\n[1, 2]\n```\n"
  },
  {
    "name": "unnecessary-list-call",
    "code": "C411",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `list` call (remove the outer call to `list()`)",
    "message_formats": [
      "Unnecessary `list` call (remove the outer call to `list()`)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `list` calls around list comprehensions.\n\n## Why is this bad?\nIt is redundant to use a `list` call around a list comprehension.\n\n## Examples\n```python\nlist([f(x) for x in foo])\n```\n\nUse instead\n```python\n[f(x) for x in foo]\n```\n"
  },
  {
    "name": "unnecessary-call-around-sorted",
    "code": "C413",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{func}` call around `sorted()`",
    "message_formats": [
      "Unnecessary `{func}` call around `sorted()`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `list` or `reversed` calls around `sorted`\ncalls.\n\n## Why is this bad?\nIt is unnecessary to use `list` around `sorted`, as the latter already\nreturns a list.\n\nIt is also unnecessary to use `reversed` around `sorted`, as the latter\nhas a `reverse` argument that can be used in lieu of an additional\n`reversed` call.\n\nIn both cases, it's clearer to avoid the redundant call.\n\n## Examples\n```python\nreversed(sorted(iterable))\n```\n\nUse instead:\n```python\nsorted(iterable, reverse=True)\n```\n"
  },
  {
    "name": "unnecessary-double-cast-or-process",
    "code": "C414",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{inner}` call within `{outer}()`",
    "message_formats": [
      "Unnecessary `{inner}` call within `{outer}()`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `list`, `reversed`, `set`, `sorted`, and `tuple`\ncall within `list`, `set`, `sorted`, and `tuple` calls.\n\n## Why is this bad?\nIt's unnecessary to double-cast or double-process iterables by wrapping\nthe listed functions within an additional `list`, `set`, `sorted`, or\n`tuple` call. Doing so is redundant and can be confusing for readers.\n\n## Examples\n```python\nlist(tuple(iterable))\n```\n\nUse instead:\n```python\nlist(iterable)\n```\n\nThis rule applies to a variety of functions, including `list`, `reversed`,\n`set`, `sorted`, and `tuple`. For example:\n\n- Instead of `list(list(iterable))`, use `list(iterable)`.\n- Instead of `list(tuple(iterable))`, use `list(iterable)`.\n- Instead of `tuple(list(iterable))`, use `tuple(iterable)`.\n- Instead of `tuple(tuple(iterable))`, use `tuple(iterable)`.\n- Instead of `set(set(iterable))`, use `set(iterable)`.\n- Instead of `set(list(iterable))`, use `set(iterable)`.\n- Instead of `set(tuple(iterable))`, use `set(iterable)`.\n- Instead of `set(sorted(iterable))`, use `set(iterable)`.\n- Instead of `set(reversed(iterable))`, use `set(iterable)`.\n- Instead of `sorted(list(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(tuple(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(sorted(iterable))`, use `sorted(iterable)`.\n- Instead of `sorted(reversed(iterable))`, use `sorted(iterable)`.\n"
  },
  {
    "name": "unnecessary-subscript-reversal",
    "code": "C415",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary subscript reversal of iterable within `{func}()`",
    "message_formats": [
      "Unnecessary subscript reversal of iterable within `{func}()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unnecessary subscript reversal of iterable.\n\n## Why is this bad?\nIt's unnecessary to reverse the order of an iterable when passing it\ninto `reversed()`, `set()` or `sorted()` functions as they will change\nthe order of the elements again.\n\n## Examples\n```python\nreversed(iterable[::-1])\nset(iterable[::-1])\nsorted(iterable)[::-1]\n```\n\nUse instead:\n```python\nreversed(iterable)\nset(iterable)\nsorted(iterable, reverse=True)\n```\n"
  },
  {
    "name": "unnecessary-comprehension",
    "code": "C416",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `{obj_type}` comprehension (rewrite using `{obj_type}()`)",
    "message_formats": [
      "Unnecessary `{obj_type}` comprehension (rewrite using `{obj_type}()`)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `dict`, `list`, and `set` comprehension.\n\n## Why is this bad?\nIt's unnecessary to use a `dict`/`list`/`set` comprehension to build a\ndata structure if the elements are unchanged. Wrap the iterable with\n`dict()`, `list()`, or `set()` instead.\n\n## Examples\n```python\n{a: b for a, b in iterable}\n[x for x in iterable]\n{x for x in iterable}\n```\n\nUse instead:\n```python\ndict(iterable)\nlist(iterable)\nset(iterable)\n```\n"
  },
  {
    "name": "unnecessary-map",
    "code": "C417",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `map` usage (rewrite using a generator expression)",
    "message_formats": [
      "Unnecessary `map` usage (rewrite using a generator expression)",
      "Unnecessary `map` usage (rewrite using a `{obj_type}` comprehension)"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for unnecessary `map` calls with `lambda` functions.\n\n## Why is this bad?\nUsing `map(func, iterable)` when `func` is a `lambda` is slower than\nusing a generator expression or a comprehension, as the latter approach\navoids the function call overhead, in addition to being more readable.\n\n## Examples\n```python\nmap(lambda x: x + 1, iterable)\n```\n\nUse instead:\n```python\n(x + 1 for x in iterable)\n```\n\nThis rule also applies to `map` calls within `list`, `set`, and `dict`\ncalls. For example:\n\n- Instead of `list(map(lambda num: num * 2, nums))`, use\n  `[num * 2 for num in nums]`.\n- Instead of `set(map(lambda num: num % 2 == 0, nums))`, use\n  `{num % 2 == 0 for num in nums}`.\n- Instead of `dict(map(lambda v: (v, v ** 2), values))`, use\n  `{v: v ** 2 for v in values}`.\n"
  },
  {
    "name": "unnecessary-literal-within-dict-call",
    "code": "C418",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary `dict` {kind} passed to `dict()` (remove the outer call to `dict()`)",
    "message_formats": [
      "Unnecessary `dict` {kind} passed to `dict()` (remove the outer call to `dict()`)"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `dict` calls that take unnecessary `dict` literals or `dict`\ncomprehensions as arguments.\n\n## Why is this bad?\nIt's unnecessary to wrap a `dict` literal or comprehension within a `dict`\ncall, since the literal or comprehension syntax already returns a `dict`.\n\n## Examples\n```python\ndict({})\ndict({\"a\": 1})\n```\n\nUse instead:\n```python\n{}\n{\"a\": 1}\n```\n"
  },
  {
    "name": "unnecessary-comprehension-any-all",
    "code": "C419",
    "linter": "flake8-comprehensions",
    "summary": "Unnecessary list comprehension.",
    "message_formats": [
      "Unnecessary list comprehension."
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for unnecessary list comprehensions passed to `any` and `all`.\n\n## Why is this bad?\n`any` and `all` take any iterators, including generators. Converting a generator to a list\nby way of a list comprehension is unnecessary and reduces performance due to the\noverhead of creating the list.\n\nFor example, compare the performance of `all` with a list comprehension against that\nof a generator (~40x faster here):\n\n```console\nIn [1]: %timeit all([i for i in range(1000)])\n8.14 s  25.4 ns per loop (mean  std. dev. of 7 runs, 100,000 loops each)\n\nIn [2]: %timeit all(i for i in range(1000))\n212 ns  0.892 ns per loop (mean  std. dev. of 7 runs, 1,000,000 loops each)\n```\n\n## Examples\n```python\nany([x.id for x in bar])\nall([x.id for x in bar])\n```\n\nUse instead:\n```python\nany(x.id for x in bar)\nall(x.id for x in bar)\n```\n"
  },
  {
    "name": "call-datetime-without-tzinfo",
    "code": "DTZ001",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime()` without `tzinfo` argument is not allowed",
    "message_formats": [
      "The use of `datetime.datetime()` without `tzinfo` argument is not allowed"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-today",
    "code": "DTZ002",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.today()` is not allowed, use `datetime.datetime.now(tz=)` instead",
    "message_formats": [
      "The use of `datetime.datetime.today()` is not allowed, use `datetime.datetime.now(tz=)` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-utcnow",
    "code": "DTZ003",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.utcnow()` is not allowed, use `datetime.datetime.now(tz=)` instead",
    "message_formats": [
      "The use of `datetime.datetime.utcnow()` is not allowed, use `datetime.datetime.now(tz=)` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-utcfromtimestamp",
    "code": "DTZ004",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.utcfromtimestamp()` is not allowed, use `datetime.datetime.fromtimestamp(ts, tz=)` instead",
    "message_formats": [
      "The use of `datetime.datetime.utcfromtimestamp()` is not allowed, use `datetime.datetime.fromtimestamp(ts, tz=)` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-now-without-tzinfo",
    "code": "DTZ005",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.now()` without `tz` argument is not allowed",
    "message_formats": [
      "The use of `datetime.datetime.now()` without `tz` argument is not allowed"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-fromtimestamp",
    "code": "DTZ006",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.fromtimestamp()` without `tz` argument is not allowed",
    "message_formats": [
      "The use of `datetime.datetime.fromtimestamp()` without `tz` argument is not allowed"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-datetime-strptime-without-zone",
    "code": "DTZ007",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.datetime.strptime()` without %z must be followed by `.replace(tzinfo=)` or `.astimezone()`",
    "message_formats": [
      "The use of `datetime.datetime.strptime()` without %z must be followed by `.replace(tzinfo=)` or `.astimezone()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-date-today",
    "code": "DTZ011",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.date.today()` is not allowed, use `datetime.datetime.now(tz=).date()` instead",
    "message_formats": [
      "The use of `datetime.date.today()` is not allowed, use `datetime.datetime.now(tz=).date()` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "call-date-fromtimestamp",
    "code": "DTZ012",
    "linter": "flake8-datetimez",
    "summary": "The use of `datetime.date.fromtimestamp()` is not allowed, use `datetime.datetime.fromtimestamp(ts, tz=).date()` instead",
    "message_formats": [
      "The use of `datetime.date.fromtimestamp()` is not allowed, use `datetime.datetime.fromtimestamp(ts, tz=).date()` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "debugger",
    "code": "T100",
    "linter": "flake8-debugger",
    "summary": "Trace found: `{name}` used",
    "message_formats": [
      "Trace found: `{name}` used",
      "Import for `{name}` found"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of debugger calls and imports.\n\n## Why is this bad?\nDebugger calls and imports should be used for debugging purposes only. The\npresence of a debugger call or import in production code is likely a\nmistake and may cause unintended behavior, such as exposing sensitive\ninformation or causing the program to hang.\n\nInstead, consider using a logging library to log information about the\nprogram's state, and writing tests to verify that the program behaves\nas expected.\n\n## Example\n```python\ndef foo():\n    breakpoint()\n```\n\n## References\n- [Python documentation: `pdb`  The Python Debugger](https://docs.python.org/3/library/pdb.html)\n- [Python documentation: `logging`  Logging facility for Python](https://docs.python.org/3/library/logging.html)\n"
  },
  {
    "name": "django-nullable-model-string-field",
    "code": "DJ001",
    "linter": "flake8-django",
    "summary": "Avoid using `null=True` on string-based fields such as {field_name}",
    "message_formats": [
      "Avoid using `null=True` on string-based fields such as {field_name}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks nullable string-based fields (like `CharField` and `TextField`)\nin Django models.\n\n## Why is this bad?\nIf a string-based field is nullable, then your model will have two possible\nrepresentations for \"no data\": `None` and the empty string. This can lead to\nconfusion, as clients of the API have to check for both `None` and the\nempty string when trying to determine if the field has data.\n\nThe Django convention is to use the empty string in lieu of `None` for\nstring-based fields.\n\n## Example\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, null=True)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255, default=\"\")\n```\n"
  },
  {
    "name": "django-locals-in-render-function",
    "code": "DJ003",
    "linter": "flake8-django",
    "summary": "Avoid passing `locals()` as context to a `render` function",
    "message_formats": [
      "Avoid passing `locals()` as context to a `render` function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of `locals()` in `render` functions.\n\n## Why is this bad?\nUsing `locals()` can expose internal variables or other unintentional\ndata to the rendered template.\n\n## Example\n```python\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    return render(request, \"app/index.html\", locals())\n```\n\nUse instead:\n```python\nfrom django.shortcuts import render\n\n\ndef index(request):\n    posts = Post.objects.all()\n    context = {\"posts\": posts}\n    return render(request, \"app/index.html\", context)\n```\n"
  },
  {
    "name": "django-exclude-with-model-form",
    "code": "DJ006",
    "linter": "flake8-django",
    "summary": "Do not use `exclude` with `ModelForm`, use `fields` instead",
    "message_formats": [
      "Do not use `exclude` with `ModelForm`, use `fields` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of `exclude` in Django `ModelForm` classes.\n\n## Why is this bad?\nIf a `ModelForm` includes the `exclude` attribute, any new field that\nis added to the model will automatically be exposed for modification.\n\n## Example\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        exclude = [\"author\"]\n```\n\nUse instead:\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n```\n"
  },
  {
    "name": "django-all-with-model-form",
    "code": "DJ007",
    "linter": "flake8-django",
    "summary": "Do not use `__all__` with `ModelForm`, use `fields` instead",
    "message_formats": [
      "Do not use `__all__` with `ModelForm`, use `fields` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of `fields = \"__all__\"` in Django `ModelForm`\nclasses.\n\n## Why is this bad?\nIf a `ModelForm` includes the `fields = \"__all__\"` attribute, any new\nfield that is added to the model will automatically be exposed for\nmodification.\n\n## Example\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = \"__all__\"\n```\n\nUse instead:\n```python\nfrom django.forms import ModelForm\n\n\nclass PostForm(ModelForm):\n    class Meta:\n        model = Post\n        fields = [\"title\", \"content\"]\n```\n"
  },
  {
    "name": "django-model-without-dunder-str",
    "code": "DJ008",
    "linter": "flake8-django",
    "summary": "Model does not define `__str__` method",
    "message_formats": [
      "Model does not define `__str__` method"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that `__str__` method is defined in Django models.\n\n## Why is this bad?\nDjango models should define `__str__` method to return a string representation\nof the model instance, as Django calls this method to display the object in\nthe Django Admin and elsewhere.\n\nModels without `__str__` method will display a non-meaningful representation\nof the object in the Django Admin.\n\n## Example\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass MyModel(models.Model):\n    field = models.CharField(max_length=255)\n\n    def __str__(self):\n        return f\"{self.field}\"\n```\n"
  },
  {
    "name": "django-unordered-body-content-in-model",
    "code": "DJ012",
    "linter": "flake8-django",
    "summary": "Order of model's inner classes, methods, and fields does not follow the Django Style Guide: {elem_type} should come before {before}",
    "message_formats": [
      "Order of model's inner classes, methods, and fields does not follow the Django Style Guide: {elem_type} should come before {before}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the order of Model's inner classes, methods, and fields as per\nthe [Django Style Guide].\n\n## Why is this bad?\nThe [Django Style Guide] specifies that the order of Model inner classes,\nattributes and methods should be as follows:\n\n1. All database fields\n2. Custom manager attributes\n3. `class Meta`\n4. `def __str__()`\n5. `def save()`\n6. `def get_absolute_url()`\n7. Any custom methods\n\n## Examples\n```python\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n```\n\nUse instead:\n```python\nfrom django.db import models\n\n\nclass StrBeforeFieldModel(models.Model):\n    first_name = models.CharField(max_length=32)\n    last_name = models.CharField(max_length=40)\n\n    class Meta:\n        verbose_name = \"test\"\n        verbose_name_plural = \"tests\"\n\n    def __str__(self):\n        return \"foobar\"\n```\n\n[Django Style Guide]: https://docs.djangoproject.com/en/dev/internals/contributing/writing-code/coding-style/#model-style\n"
  },
  {
    "name": "django-non-leading-receiver-decorator",
    "code": "DJ013",
    "linter": "flake8-django",
    "summary": "`@receiver` decorator must be on top of all the other decorators",
    "message_formats": [
      "`@receiver` decorator must be on top of all the other decorators"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that Django's `@receiver` decorator is listed first, prior to\nany other decorators.\n\n## Why is this bad?\nDjango's `@receiver` decorator is special in that it does not return\na wrapped function. Rather, `@receiver` connects the decorated function\nto a signal. If any other decorators are listed before `@receiver`,\nthe decorated function will not be connected to the signal.\n\n## Example\n```python\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@transaction.atomic\n@receiver(post_save, sender=MyModel)\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n```\n\nUse instead:\n```python\nfrom django.dispatch import receiver\nfrom django.db.models.signals import post_save\n\n\n@receiver(post_save, sender=MyModel)\n@transaction.atomic\ndef my_handler(sender, instance, created, **kwargs):\n    pass\n```\n"
  },
  {
    "name": "raw-string-in-exception",
    "code": "EM101",
    "linter": "flake8-errmsg",
    "summary": "Exception must not use a string literal, assign to variable first",
    "message_formats": [
      "Exception must not use a string literal, assign to variable first"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the use of string literals in exception constructors.\n\n## Why is this bad?\nPython includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using a string literal, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\n## Example\nGiven:\n```python\nraise RuntimeError(\"'Some value' is incorrect\")\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"Some value is incorrect\")\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nmsg = \"'Some value' is incorrect\"\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```\n"
  },
  {
    "name": "f-string-in-exception",
    "code": "EM102",
    "linter": "flake8-errmsg",
    "summary": "Exception must not use an f-string literal, assign to variable first",
    "message_formats": [
      "Exception must not use an f-string literal, assign to variable first"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the use of f-strings in exception constructors.\n\n## Why is this bad?\nPython includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using an f-string, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\n## Example\nGiven:\n```python\nsub = \"Some value\"\nraise RuntimeError(f\"{sub!r} is incorrect\")\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(f\"{sub!r} is incorrect\")\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nsub = \"Some value\"\nmsg = f\"{sub!r} is incorrect\"\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```\n"
  },
  {
    "name": "dot-format-in-exception",
    "code": "EM103",
    "linter": "flake8-errmsg",
    "summary": "Exception must not use a `.format()` string directly, assign to variable first",
    "message_formats": [
      "Exception must not use a `.format()` string directly, assign to variable first"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the use of `.format` calls on string literals in exception\nconstructors.\n\n## Why is this bad?\nPython includes the `raise` in the default traceback (and formatters\nlike Rich and IPython do too).\n\nBy using a `.format` call, the error message will be duplicated in the\ntraceback, which can make the traceback less readable.\n\n## Example\nGiven:\n```python\nsub = \"Some value\"\nraise RuntimeError(\"'{}' is incorrect\".format(sub))\n```\n\nPython will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 2, in <module>\n    raise RuntimeError(\"'{}' is incorrect\".format(sub))\nRuntimeError: 'Some value' is incorrect\n```\n\nInstead, assign the string to a variable:\n```python\nsub = \"Some value\"\nmsg = \"'{}' is incorrect\".format(sub)\nraise RuntimeError(msg)\n```\n\nWhich will produce a traceback like:\n```console\nTraceback (most recent call last):\n  File \"tmp.py\", line 3, in <module>\n    raise RuntimeError(msg)\nRuntimeError: 'Some value' is incorrect\n```\n"
  },
  {
    "name": "shebang-not-executable",
    "code": "EXE001",
    "linter": "flake8-executable",
    "summary": "Shebang is present but file is not executable",
    "message_formats": [
      "Shebang is present but file is not executable"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for a shebang directive in a file that is not executable.\n\n## Why is this bad?\nIn Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe presence of a shebang suggests that a file is intended to be\nexecutable. If a file contains a shebang but is not executable, then the\nshebang is misleading, or the file is missing the executable bit.\n\nIf the file is meant to be executable, add a shebang; otherwise, remove the\nexecutable bit from the file.\n\n_This rule is only available on Unix-like systems._\n\n## References\n- [Python documentation: Executable Python Scripts](https://docs.python.org/3/tutorial/appendix.html#executable-python-scripts)\n"
  },
  {
    "name": "shebang-missing-executable-file",
    "code": "EXE002",
    "linter": "flake8-executable",
    "summary": "The file is executable but no shebang is present",
    "message_formats": [
      "The file is executable but no shebang is present"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for executable `.py` files that do not have a shebang.\n\n## Why is this bad?\nIn Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nIf a `.py` file is executable, but does not have a shebang, it may be run\nwith the wrong interpreter, or fail to run at all.\n\nIf the file is meant to be executable, add a shebang; otherwise, remove the\nexecutable bit from the file.\n\n_This rule is only available on Unix-like systems._\n\n## References\n- [Python documentation: Executable Python Scripts](https://docs.python.org/3/tutorial/appendix.html#executable-python-scripts)\n"
  },
  {
    "name": "shebang-missing-python",
    "code": "EXE003",
    "linter": "flake8-executable",
    "summary": "Shebang should contain `python`",
    "message_formats": [
      "Shebang should contain `python`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for a shebang directive in `.py` files that does not contain `python`.\n\n## Why is this bad?\nIn Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nFor Python scripts, the shebang must contain `python` to indicate that the\nscript should be executed as a Python script. If the shebang does not\ncontain `python`, then the file will be executed with the default\ninterpreter, which is likely a mistake.\n\n## Example\n```python\n#!/usr/bin/env bash\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\n```\n\n## References\n- [Python documentation: Executable Python Scripts](https://docs.python.org/3/tutorial/appendix.html#executable-python-scripts)\n"
  },
  {
    "name": "shebang-leading-whitespace",
    "code": "EXE004",
    "linter": "flake8-executable",
    "summary": "Avoid whitespace before shebang",
    "message_formats": [
      "Avoid whitespace before shebang"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for whitespace before a shebang directive.\n\n## Why is this bad?\nIn Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe shebang's `#!` prefix must be the first two characters of a file. The\npresence of whitespace before the shebang will cause the shebang to be\nignored, which is likely a mistake.\n\n## Example\n```python\n #!/usr/bin/env python3\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\n```\n\n## References\n- [Python documentation: Executable Python Scripts](https://docs.python.org/3/tutorial/appendix.html#executable-python-scripts)\n"
  },
  {
    "name": "shebang-not-first-line",
    "code": "EXE005",
    "linter": "flake8-executable",
    "summary": "Shebang should be at the beginning of the file",
    "message_formats": [
      "Shebang should be at the beginning of the file"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for a shebang directive that is not at the beginning of the file.\n\n## Why is this bad?\nIn Python, a shebang (also known as a hashbang) is the first line of a\nscript, which specifies the interpreter that should be used to run the\nscript.\n\nThe shebang's `#!` prefix must be the first two characters of a file. If\nthe shebang is not at the beginning of the file, it will be ignored, which\nis likely a mistake.\n\n## Example\n```python\nfoo = 1\n#!/usr/bin/env python3\n```\n\nUse instead:\n```python\n#!/usr/bin/env python3\nfoo = 1\n```\n\n## References\n- [Python documentation: Executable Python Scripts](https://docs.python.org/3/tutorial/appendix.html#executable-python-scripts)\n"
  },
  {
    "name": "line-contains-fixme",
    "code": "FIX001",
    "linter": "flake8-fixme",
    "summary": "Line contains FIXME",
    "message_formats": [
      "Line contains FIXME"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "line-contains-todo",
    "code": "FIX002",
    "linter": "flake8-fixme",
    "summary": "Line contains TODO",
    "message_formats": [
      "Line contains TODO"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "line-contains-xxx",
    "code": "FIX003",
    "linter": "flake8-fixme",
    "summary": "Line contains XXX",
    "message_formats": [
      "Line contains XXX"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "line-contains-hack",
    "code": "FIX004",
    "linter": "flake8-fixme",
    "summary": "Line contains HACK",
    "message_formats": [
      "Line contains HACK"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "future-rewritable-type-annotation",
    "code": "FA100",
    "linter": "flake8-future-annotations",
    "summary": "Missing `from __future__ import annotations`, but uses `{name}`",
    "message_formats": [
      "Missing `from __future__ import annotations`, but uses `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for missing `from __future__ import annotations` imports upon\ndetecting type annotations that can be written more succinctly under\nPEP 563.\n\n## Why is this bad?\nPEP 563 enabled the use of a number of convenient type annotations, such as\n`list[str]` instead of `List[str]`, or `str | None` instead of\n`Optional[str]`. However, these annotations are only available on Python\n3.9 and higher, _unless_ the `from __future__ import annotations` import is present.\n\nBy adding the `__future__` import, the pyupgrade rules can automatically\nmigrate existing code to use the new syntax, even for older Python versions.\nThis rule thus pairs well with pyupgrade and with Ruff's pyupgrade rules.\n\n## Example\n```python\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None:\n    ...\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import List, Dict, Optional\n\n\ndef func(obj: Dict[str, Optional[int]]) -> None:\n    ...\n```\n\nAfter running the additional pyupgrade rules:\n```python\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None:\n    ...\n```\n\n## Options\n- `target-version`\n"
  },
  {
    "name": "future-required-type-annotation",
    "code": "FA102",
    "linter": "flake8-future-annotations",
    "summary": "Missing `from __future__ import annotations`, but uses {reason}",
    "message_formats": [
      "Missing `from __future__ import annotations`, but uses {reason}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of PEP 585- and PEP 604-style type annotations in Python\nmodules that lack the required `from __future__ import annotations` import\nfor compatibility with older Python versions.\n\n## Why is this bad?\nUsing PEP 585 and PEP 604 style annotations without a `from __future__ import\nannotations` import will cause runtime errors on Python versions prior to\n3.9 and 3.10, respectively.\n\nBy adding the `__future__` import, the interpreter will no longer interpret\nannotations at evaluation time, making the code compatible with both past\nand future Python versions.\n\n## Example\n```python\ndef func(obj: dict[str, int | None]) -> None:\n    ...\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\n\ndef func(obj: dict[str, int | None]) -> None:\n    ...\n```\n"
  },
  {
    "name": "f-string-in-get-text-func-call",
    "code": "INT001",
    "linter": "flake8-gettext",
    "summary": "f-string is resolved before function call; consider `_(\"string %s\") % arg`",
    "message_formats": [
      "f-string is resolved before function call; consider `_(\"string %s\") % arg`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "format-in-get-text-func-call",
    "code": "INT002",
    "linter": "flake8-gettext",
    "summary": "`format` method argument is resolved before function call; consider `_(\"string %s\") % arg`",
    "message_formats": [
      "`format` method argument is resolved before function call; consider `_(\"string %s\") % arg`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "printf-in-get-text-func-call",
    "code": "INT003",
    "linter": "flake8-gettext",
    "summary": "printf-style format is resolved before function call; consider `_(\"string %s\") % arg`",
    "message_formats": [
      "printf-style format is resolved before function call; consider `_(\"string %s\") % arg`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "single-line-implicit-string-concatenation",
    "code": "ISC001",
    "linter": "flake8-implicit-str-concat",
    "summary": "Implicitly concatenated string literals on one line",
    "message_formats": [
      "Implicitly concatenated string literals on one line"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for implicitly concatenated strings on a single line.\n\n## Why is this bad?\nWhile it is valid Python syntax to concatenate multiple string or byte\nliterals implicitly (via whitespace delimiters), it is unnecessary and\nnegatively affects code readability.\n\nIn some cases, the implicit concatenation may also be unintentional, as\nautoformatters are capable of introducing single-line implicit\nconcatenations when collapsing long lines.\n\n## Example\n```python\nz = \"The quick \" \"brown fox.\"\n```\n\nUse instead:\n```python\nz = \"The quick brown fox.\"\n```\n"
  },
  {
    "name": "multi-line-implicit-string-concatenation",
    "code": "ISC002",
    "linter": "flake8-implicit-str-concat",
    "summary": "Implicitly concatenated string literals over multiple lines",
    "message_formats": [
      "Implicitly concatenated string literals over multiple lines"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for implicitly concatenated strings that span multiple lines.\n\n## Why is this bad?\nFor string literals that wrap across multiple lines, [PEP 8] recommends\nthe use of implicit string concatenation within parentheses instead of\nusing a backslash for line continuation, as the former is more readable\nthan the latter.\n\nBy default, this rule will only trigger if the string literal is\nconcatenated via a backslash. To disallow implicit string concatenation\naltogether, set the `flake8-implicit-str-concat.allow-multiline` option\nto `false`.\n\n## Example\n```python\nz = \"The quick brown fox jumps over the lazy \"\\\n    \"dog.\"\n```\n\nUse instead:\n```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog.\"\n)\n```\n\n## Options\n- `flake8-implicit-str-concat.allow-multiline`\n\n[PEP 8]: https://peps.python.org/pep-0008/#maximum-line-length\n"
  },
  {
    "name": "explicit-string-concatenation",
    "code": "ISC003",
    "linter": "flake8-implicit-str-concat",
    "summary": "Explicitly concatenated string should be implicitly concatenated",
    "message_formats": [
      "Explicitly concatenated string should be implicitly concatenated"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for string literals that are explicitly concatenated (using the\n`+` operator).\n\n## Why is this bad?\nFor string literals that wrap across multiple lines, implicit string\nconcatenation within parentheses is preferred over explicit\nconcatenation using the `+` operator, as the former is more readable.\n\n## Example\n```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    + \"dog\"\n)\n```\n\nUse instead:\n```python\nz = (\n    \"The quick brown fox jumps over the lazy \"\n    \"dog\"\n)\n```\n"
  },
  {
    "name": "unconventional-import-alias",
    "code": "ICN001",
    "linter": "flake8-import-conventions",
    "summary": "`{name}` should be imported as `{asname}`",
    "message_formats": [
      "`{name}` should be imported as `{asname}`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for imports that are typically imported using a common convention,\nlike `import pandas as pd`, and enforces that convention.\n\n## Why is this bad?\nConsistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nFor example, `import pandas as pd` is a common\nconvention for importing the `pandas` library, and users typically expect\nPandas to be aliased as `pd`.\n\n## Example\n```python\nimport pandas\n```\n\nUse instead:\n```python\nimport pandas as pd\n```\n"
  },
  {
    "name": "banned-import-alias",
    "code": "ICN002",
    "linter": "flake8-import-conventions",
    "summary": "`{name}` should not be imported as `{asname}`",
    "message_formats": [
      "`{name}` should not be imported as `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for imports that use non-standard naming conventions, like\n`import tensorflow.keras.backend as K`.\n\n## Why is this bad?\nConsistency is good. Avoid using a non-standard naming convention for\nimports, and, in particular, choosing import aliases that violate PEP 8.\n\nFor example, aliasing via `import tensorflow.keras.backend as K` violates\nthe guidance of PEP 8, and is thus avoided in some projects.\n\n## Example\n```python\nimport tensorflow.keras.backend as K\n```\n\nUse instead:\n```python\nimport tensorflow as tf\n\ntf.keras.backend\n```\n"
  },
  {
    "name": "banned-import-from",
    "code": "ICN003",
    "linter": "flake8-import-conventions",
    "summary": "Members of `{name}` should not be imported explicitly",
    "message_formats": [
      "Members of `{name}` should not be imported explicitly"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for member imports that should instead be accessed by importing the\nmodule.\n\n## Why is this bad?\nConsistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\nFor example, it's common to import `pandas` as `pd`, and then access\nmembers like `Series` via `pd.Series`, rather than importing `Series`\ndirectly.\n\n## Example\n```python\nfrom pandas import Series\n```\n\nUse instead:\n```python\nimport pandas as pd\n\npd.Series\n```\n"
  },
  {
    "name": "logging-string-format",
    "code": "G001",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses `string.format()`",
    "message_formats": [
      "Logging statement uses `string.format()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-percent-format",
    "code": "G002",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses `%`",
    "message_formats": [
      "Logging statement uses `%`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-string-concat",
    "code": "G003",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses `+`",
    "message_formats": [
      "Logging statement uses `+`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-f-string",
    "code": "G004",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses f-string",
    "message_formats": [
      "Logging statement uses f-string"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-warn",
    "code": "G010",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses `warn` instead of `warning`",
    "message_formats": [
      "Logging statement uses `warn` instead of `warning`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "logging-extra-attr-clash",
    "code": "G101",
    "linter": "flake8-logging-format",
    "summary": "Logging statement uses an extra field that clashes with a LogRecord field: `{key}`",
    "message_formats": [
      "Logging statement uses an extra field that clashes with a LogRecord field: `{key}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-exc-info",
    "code": "G201",
    "linter": "flake8-logging-format",
    "summary": "Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`",
    "message_formats": [
      "Logging `.exception(...)` should be used instead of `.error(..., exc_info=True)`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "logging-redundant-exc-info",
    "code": "G202",
    "linter": "flake8-logging-format",
    "summary": "Logging statement has redundant `exc_info`",
    "message_formats": [
      "Logging statement has redundant `exc_info`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "implicit-namespace-package",
    "code": "INP001",
    "linter": "flake8-no-pep420",
    "summary": "File `{filename}` is part of an implicit namespace package. Add an `__init__.py`.",
    "message_formats": [
      "File `{filename}` is part of an implicit namespace package. Add an `__init__.py`."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for packages that are missing an `__init__.py` file.\n\n## Why is this bad?\nPython packages are directories that contain a file named `__init__.py`.\nThe existence of this file indicates that the directory is a Python\npackage, and so it can be imported the same way a module can be\nimported.\n\nDirectories that lack an `__init__.py` file can still be imported, but\nthey're indicative of a special kind of package, known as a \"namespace\npackage\" (see: [PEP 420](https://www.python.org/dev/peps/pep-0420/)).\nNamespace packages are less widely used, so a package that lacks an\n`__init__.py` file is typically meant to be a regular package, and\nthe absence of the `__init__.py` file is probably an oversight.\n\n## Options\n- `namespace-packages`\n"
  },
  {
    "name": "unnecessary-pass",
    "code": "PIE790",
    "linter": "flake8-pie",
    "summary": "Unnecessary `pass` statement",
    "message_formats": [
      "Unnecessary `pass` statement"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `pass` statements in class and function bodies.\nwhere it is not needed syntactically (e.g., when an indented docstring is\npresent).\n\n## Why is this bad?\nWhen a function or class definition contains a docstring, an additional\n`pass` statement is redundant.\n\n## Example\n```python\ndef foo():\n    \"\"\"Placeholder docstring.\"\"\"\n    pass\n```\n\nUse instead:\n```python\ndef foo():\n    \"\"\"Placeholder docstring.\"\"\"\n```\n\n## References\n- [Python documentation: The `pass` statement](https://docs.python.org/3/reference/simple_stmts.html#the-pass-statement)\n"
  },
  {
    "name": "duplicate-class-field-definition",
    "code": "PIE794",
    "linter": "flake8-pie",
    "summary": "Class field `{name}` is defined multiple times",
    "message_formats": [
      "Class field `{name}` is defined multiple times"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for duplicate field definitions in classes.\n\n## Why is this bad?\nDefining a field multiple times in a class body is redundant and likely a\nmistake.\n\n## Example\n```python\nclass Person:\n    name = Tom\n    ...\n    name = Ben\n```\n\nUse instead:\n```python\nclass Person:\n    name = Tom\n    ...\n```\n"
  },
  {
    "name": "non-unique-enums",
    "code": "PIE796",
    "linter": "flake8-pie",
    "summary": "Enum contains duplicate value: `{value}`",
    "message_formats": [
      "Enum contains duplicate value: `{value}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for enums that contain duplicate values.\n\n## Why is this bad?\nEnum values should be unique. Non-unique values are redundant and likely a\nmistake.\n\n## Example\n```python\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 1\n```\n\nUse instead:\n```python\nfrom enum import Enum\n\n\nclass Foo(Enum):\n    A = 1\n    B = 2\n    C = 3\n```\n\n## References\n- [Python documentation: `enum.Enum`](https://docs.python.org/3/library/enum.html#enum.Enum)\n"
  },
  {
    "name": "unnecessary-spread",
    "code": "PIE800",
    "linter": "flake8-pie",
    "summary": "Unnecessary spread `**`",
    "message_formats": [
      "Unnecessary spread `**`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unnecessary dictionary unpacking operators (`**`).\n\n## Why is this bad?\nUnpacking a dictionary into another dictionary is redundant. The unpacking\noperator can be removed, making the code more readable.\n\n## Example\n```python\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, **{\"C\": 3}}\n```\n\nUse instead:\n```python\nfoo = {\"A\": 1, \"B\": 2}\nbar = {**foo, \"C\": 3}\n```\n\n## References\n- [Python documentation: Dictionary displays](https://docs.python.org/3/reference/expressions.html#dictionary-displays)\n"
  },
  {
    "name": "unnecessary-dict-kwargs",
    "code": "PIE804",
    "linter": "flake8-pie",
    "summary": "Unnecessary `dict` kwargs",
    "message_formats": [
      "Unnecessary `dict` kwargs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unnecessary `dict` kwargs.\n\n## Why is this bad?\nIf the `dict` keys are valid identifiers, they can be passed as keyword\narguments directly.\n\n## Example\n```python\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(**{\"bar\": 2}))  # prints 3\n```\n\nUse instead:\n```python\ndef foo(bar):\n    return bar + 1\n\n\nprint(foo(bar=2))  # prints 3\n```\n\n## References\n- [Python documentation: Dictionary displays](https://docs.python.org/3/reference/expressions.html#dictionary-displays)\n- [Python documentation: Calls](https://docs.python.org/3/reference/expressions.html#calls)\n"
  },
  {
    "name": "reimplemented-list-builtin",
    "code": "PIE807",
    "linter": "flake8-pie",
    "summary": "Prefer `list` over useless lambda",
    "message_formats": [
      "Prefer `list` over useless lambda"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for lambdas that can be replaced with the `list` builtin.\n\n## Why is this bad?\nUsing `list` builtin is more readable.\n\n## Example\n```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=lambda: [])\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass Foo:\n    bar: list[int] = field(default_factory=list)\n```\n\n## References\n- [Python documentation: `list`](https://docs.python.org/3/library/functions.html#func-list)\n"
  },
  {
    "name": "multiple-starts-ends-with",
    "code": "PIE810",
    "linter": "flake8-pie",
    "summary": "Call `{attr}` once with a `tuple`",
    "message_formats": [
      "Call `{attr}` once with a `tuple`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `startswith` or `endswith` calls on the same value with\ndifferent prefixes or suffixes.\n\n## Why is this bad?\nThe `startswith` and `endswith` methods accept tuples of prefixes or\nsuffixes respectively. Passing a tuple of prefixes or suffixes is more\nmore efficient and readable than calling the method multiple times.\n\n## Example\n```python\nmsg = \"Hello, world!\"\nif msg.startswith(\"Hello\") or msg.startswith(\"Hi\"):\n    print(\"Greetings!\")\n```\n\nUse instead:\n```python\nmsg = \"Hello, world!\"\nif msg.startswith((\"Hello\", \"Hi\")):\n    print(\"Greetings!\")\n```\n\n## References\n- [Python documentation: `str.startswith`](https://docs.python.org/3/library/stdtypes.html#str.startswith)\n- [Python documentation: `str.endswith`](https://docs.python.org/3/library/stdtypes.html#str.endswith)\n"
  },
  {
    "name": "print",
    "code": "T201",
    "linter": "flake8-print",
    "summary": "`print` found",
    "message_formats": [
      "`print` found"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `print` statements.\n\n## Why is this bad?\n`print` statements are useful in some situations (e.g., debugging), but\nshould typically be omitted from production code. `print` statements can\nlead to the accidental inclusion of sensitive information in logs, and are\nnot configurable by clients, unlike `logging` statements.\n\n## Example\n```python\ndef add_numbers(a, b):\n    print(f\"The sum of {a} and {b} is {a + b}\")\n    return a + b\n```\n\nUse instead:\n```python\ndef add_numbers(a, b):\n    return a + b\n```\n"
  },
  {
    "name": "p-print",
    "code": "T203",
    "linter": "flake8-print",
    "summary": "`pprint` found",
    "message_formats": [
      "`pprint` found"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `pprint` statements.\n\n## Why is this bad?\nLike `print` statements, `pprint` statements are useful in some situations\n(e.g., debugging), but should typically be omitted from production code.\n`pprint` statements can lead to the accidental inclusion of sensitive\ninformation in logs, and are not configurable by clients, unlike `logging`\nstatements.\n\n## Example\n```python\nimport pprint\n\n\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    pprint.pprint(dict_c)\n    return dict_c\n```\n\nUse instead:\n```python\ndef merge_dicts(dict_a, dict_b):\n    dict_c = {**dict_a, **dict_b}\n    return dict_c\n```\n"
  },
  {
    "name": "unprefixed-type-param",
    "code": "PYI001",
    "linter": "flake8-pyi",
    "summary": "Name of private `{kind}` must start with `_`",
    "message_formats": [
      "Name of private `{kind}` must start with `_`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that type `TypeVar`, `ParamSpec`, and `TypeVarTuple` definitions in\nstubs are prefixed with `_`.\n\n## Why is this bad?\nBy prefixing type parameters with `_`, we can avoid accidentally exposing\nnames internal to the stub.\n\n## Example\n```python\nfrom typing import TypeVar\n\nT = TypeVar(\"T\")\n```\n\nUse instead:\n```python\nfrom typing import TypeVar\n\n_T = TypeVar(\"_T\")\n```\n"
  },
  {
    "name": "bad-version-info-comparison",
    "code": "PYI006",
    "linter": "flake8-pyi",
    "summary": "Use `<` or `>=` for version info comparisons",
    "message_formats": [
      "Use `<` or `>=` for version info comparisons"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of comparators other than `<` and `>=` for\n`sys.version_info` checks in `.pyi` files. All other comparators, such\nas `>`, `<=`, and `==`, are banned.\n\n## Why is this bad?\nComparing `sys.version_info` with `==` or `<=` has unexpected behavior\nand can lead to bugs.\n\nFor example, `sys.version_info > (3, 8)` will also match `3.8.10`,\nwhile `sys.version_info <= (3, 8)` will _not_ match `3.8.10`:\n\n```python\n>>> import sys\n>>> print(sys.version_info)\nsys.version_info(major=3, minor=8, micro=10, releaselevel='final', serial=0)\n>>> print(sys.version_info > (3, 8))\nTrue\n>>> print(sys.version_info == (3, 8))\nFalse\n>>> print(sys.version_info <= (3, 8))\nFalse\n>>> print(sys.version_info in (3, 8))\nFalse\n```\n\n## Example\n```python\nimport sys\n\nif sys.version_info > (3, 8):\n    ...\n```\n\nUse instead:\n```python\nimport sys\n\nif sys.version_info >= (3, 9):\n    ...\n```\n"
  },
  {
    "name": "unrecognized-platform-check",
    "code": "PYI007",
    "linter": "flake8-pyi",
    "summary": "Unrecognized `sys.platform` check",
    "message_formats": [
      "Unrecognized `sys.platform` check"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for unrecognized `sys.platform` checks. Platform checks should be\nsimple string comparisons.\n\n**Note**: this rule is only enabled in `.pyi` stub files.\n\n## Why is this bad?\nSome `sys.platform` checks are too complex for type checkers to\nunderstand, and thus result in false positives. `sys.platform` checks\nshould be simple string comparisons, like `sys.platform == \"linux\"`.\n\n## Example\n```python\nif sys.platform.startswith(\"linux\"):\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n```\n\nInstead, use a simple string comparison, such as `==` or `!=`:\n```python\nif sys.platform == \"linux\":\n    # Linux specific definitions\n    ...\nelse:\n    # Posix specific definitions\n    ...\n```\n\n## References\n- [PEP 484](https://peps.python.org/pep-0484/#version-and-platform-checking)\n"
  },
  {
    "name": "unrecognized-platform-name",
    "code": "PYI008",
    "linter": "flake8-pyi",
    "summary": "Unrecognized platform `{platform}`",
    "message_formats": [
      "Unrecognized platform `{platform}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for unrecognized platform names in `sys.platform` checks.\n\n**Note**: this rule is only enabled in `.pyi` stub files.\n\n## Why is this bad?\nIf a `sys.platform` check compares to a platform name outside of a\nsmall set of known platforms (e.g. \"linux\", \"win32\", etc.), it's likely\na typo or a platform name that is not recognized by type checkers.\n\nThe list of known platforms is: \"linux\", \"win32\", \"cygwin\", \"darwin\".\n\n## Example\n```python\nif sys.platform == \"linus\":\n    ...\n```\n\nUse instead:\n```python\nif sys.platform == \"linux\":\n    ...\n```\n\n## References\n- [PEP 484](https://peps.python.org/pep-0484/#version-and-platform-checking)\n"
  },
  {
    "name": "pass-statement-stub-body",
    "code": "PYI009",
    "linter": "flake8-pyi",
    "summary": "Empty body should contain `...`, not `pass`",
    "message_formats": [
      "Empty body should contain `...`, not `pass`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "non-empty-stub-body",
    "code": "PYI010",
    "linter": "flake8-pyi",
    "summary": "Function body must contain only `...`",
    "message_formats": [
      "Function body must contain only `...`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "typed-argument-default-in-stub",
    "code": "PYI011",
    "linter": "flake8-pyi",
    "summary": "Only simple default values allowed for typed arguments",
    "message_formats": [
      "Only simple default values allowed for typed arguments"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pass-in-class-body",
    "code": "PYI012",
    "linter": "flake8-pyi",
    "summary": "Class body must not contain `pass`",
    "message_formats": [
      "Class body must not contain `pass`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "ellipsis-in-non-empty-class-body",
    "code": "PYI013",
    "linter": "flake8-pyi",
    "summary": "Non-empty class body must not contain `...`",
    "message_formats": [
      "Non-empty class body must not contain `...`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nRemoves ellipses (`...`) in otherwise non-empty class bodies.\n\n## Why is this bad?\nAn ellipsis in a class body is only necessary if the class body is\notherwise empty. If the class body is non-empty, then the ellipsis\nis redundant.\n\n## Example\n```python\nclass Foo:\n    ...\n    value: int\n```\n\nUse instead:\n```python\nclass Foo:\n    value: int\n```\n"
  },
  {
    "name": "argument-default-in-stub",
    "code": "PYI014",
    "linter": "flake8-pyi",
    "summary": "Only simple default values allowed for arguments",
    "message_formats": [
      "Only simple default values allowed for arguments"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "assignment-default-in-stub",
    "code": "PYI015",
    "linter": "flake8-pyi",
    "summary": "Only simple default values allowed for assignments",
    "message_formats": [
      "Only simple default values allowed for assignments"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "duplicate-union-member",
    "code": "PYI016",
    "linter": "flake8-pyi",
    "summary": "Duplicate union member `{}`",
    "message_formats": [
      "Duplicate union member `{}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "quoted-annotation-in-stub",
    "code": "PYI020",
    "linter": "flake8-pyi",
    "summary": "Quoted annotations should not be included in stubs",
    "message_formats": [
      "Quoted annotations should not be included in stubs"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "docstring-in-stub",
    "code": "PYI021",
    "linter": "flake8-pyi",
    "summary": "Docstrings should not be included in stubs",
    "message_formats": [
      "Docstrings should not be included in stubs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "collections-named-tuple",
    "code": "PYI024",
    "linter": "flake8-pyi",
    "summary": "Use `typing.NamedTuple` instead of `collections.namedtuple`",
    "message_formats": [
      "Use `typing.NamedTuple` instead of `collections.namedtuple`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `collections.namedtuple` in stub files.\n\n## Why is this bad?\n`typing.NamedTuple` is the \"typed version\" of `collections.namedtuple`.\n\nThe class generated by subclassing `typing.NamedTuple` is equivalent to\n`collections.namedtuple`, with the exception that `typing.NamedTuple`\nincludes an `__annotations__` attribute, which allows type checkers to\ninfer the types of the fields.\n\n## Example\n```python\nfrom collections import namedtuple\n\n\nperson = namedtuple(\"Person\", [\"name\", \"age\"])\n```\n\nUse instead:\n```python\nfrom typing import NamedTuple\n\n\nclass Person(NamedTuple):\n    name: str\n    age: int\n```\n"
  },
  {
    "name": "unaliased-collections-abc-set-import",
    "code": "PYI025",
    "linter": "flake8-pyi",
    "summary": "Use `from collections.abc import Set as AbstractSet` to avoid confusion with the `set` builtin",
    "message_formats": [
      "Use `from collections.abc import Set as AbstractSet` to avoid confusion with the `set` builtin"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `from collections.abc import Set` imports that do not alias\n`Set` to `AbstractSet`.\n\n## Why is this bad?\nThe `Set` type in `collections.abc` is an abstract base class for set-like types.\nIt is easily confused with, and not equivalent to, the `set` builtin.\n\nTo avoid confusion, `Set` should be aliased to `AbstractSet` when imported. This\nmakes it clear that the imported type is an abstract base class, and not the\n`set` builtin.\n\n## Example\n```python\nfrom collections.abc import Set\n```\n\nUse instead:\n```python\nfrom collections.abc import Set as AbstractSet\n```\n"
  },
  {
    "name": "str-or-repr-defined-in-stub",
    "code": "PYI029",
    "linter": "flake8-pyi",
    "summary": "Defining `{name}` in a stub is almost always redundant",
    "message_formats": [
      "Defining `{name}` in a stub is almost always redundant"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for redundant definitions of `__str__` or `__repr__` in stubs.\n\n## Why is this bad?\nDefining `__str__` or `__repr__` in a stub is almost always redundant,\nas the signatures are almost always identical to those of the default\nequivalent, `object.__str__` and `object.__repr__`, respectively.\n\n## Example\n```python\nclass Foo:\n    def __repr__(self) -> str:\n        ...\n```\n"
  },
  {
    "name": "any-eq-ne-annotation",
    "code": "PYI032",
    "linter": "flake8-pyi",
    "summary": "Prefer `object` to `Any` for the second parameter to `{method_name}`",
    "message_formats": [
      "Prefer `object` to `Any` for the second parameter to `{method_name}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `__eq__` and `__ne__` implementations that use `typing.Any` as\nthe type annotation for the `obj` parameter.\n\n## Why is this bad?\nThe Python documentation recommends the use of `object` to \"indicate that a\nvalue could be any type in a typesafe manner\", while `Any` should be used to\n\"indicate that a value is dynamically typed.\"\n\nThe semantics of `__eq__` and `__ne__` are such that the `obj` parameter\nshould be any type, as opposed to a dynamically typed value. Therefore, the\n`object` type annotation is more appropriate.\n\n## Example\n```python\nclass Foo:\n    def __eq__(self, obj: typing.Any):\n        ...\n```\n\nUse instead:\n```python\nclass Foo:\n    def __eq__(self, obj: object):\n        ...\n```\n## References\n- [Python documentation: The `Any` type](https://docs.python.org/3/library/typing.html#the-any-type)\n- [Mypy documentation](https://mypy.readthedocs.io/en/latest/dynamic_typing.html#any-vs-object)\n"
  },
  {
    "name": "type-comment-in-stub",
    "code": "PYI033",
    "linter": "flake8-pyi",
    "summary": "Don't use type comments in stub file",
    "message_formats": [
      "Don't use type comments in stub file"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of type comments (e.g., `x = 1  # type: int`) in stub\nfiles.\n\n## Why is this bad?\nStub (`.pyi`) files should use type annotations directly, rather\nthan type comments, even if they're intended to support Python 2, since\nstub files are not executed at runtime. The one exception is `# type: ignore`.\n\n## Example\n```python\nx = 1  # type: int\n```\n\nUse instead:\n```python\nx: int = 1\n```\n"
  },
  {
    "name": "non-self-return-type",
    "code": "PYI034",
    "linter": "flake8-pyi",
    "summary": "`__new__` methods usually return `self` at runtime",
    "message_formats": [
      "`__new__` methods usually return `self` at runtime",
      "`{method_name}` methods in classes like `{class_name}` usually return `self` at runtime"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for methods that are annotated with a fixed return type, which\nshould instead be returning `self`.\n\n## Why is this bad?\nIf methods like `__new__` or `__enter__` are annotated with a fixed return\ntype, and the class is subclassed, type checkers will not be able to infer\nthe correct return type.\n\nFor example:\n```python\nclass Shape:\n    def set_scale(self, scale: float) -> Shape:\n        self.scale = scale\n        return self\n\nclass Circle(Shape):\n    def set_radius(self, radius: float) -> Circle:\n        self.radius = radius\n        return self\n\n# This returns `Shape`, not `Circle`.\nCircle().set_scale(0.5)\n\n# Thus, this expression is invalid, as `Shape` has no attribute `set_radius`.\nCircle().set_scale(0.5).set_radius(2.7)\n```\n\nSpecifically, this check enforces that the return type of the following\nmethods is `Self`:\n\n1. In-place binary operations, like `__iadd__`, `__imul__`, etc.\n1. `__new__`, `__enter__`, and `__aenter__`, if those methods return the\n   class name.\n1. `__iter__` methods that return `Iterator`, despite the class inheriting\n   directly from `Iterator`.\n1. `__aiter__` methods that return `AsyncIterator`, despite the class\n   inheriting directly from `AsyncIterator`.\n\n## Example\n```python\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Bad:\n        ...\n\n    def __enter__(self) -> Bad:\n        ...\n\n    async def __aenter__(self) -> Bad:\n        ...\n\n    def __iadd__(self, other: Bad) -> Bad:\n        ...\n```\n\nUse instead:\n```python\nfrom typing_extensions import Self\n\n\nclass Foo:\n    def __new__(cls, *args: Any, **kwargs: Any) -> Self:\n        ...\n\n    def __enter__(self) -> Self:\n        ...\n\n    async def __aenter__(self) -> Self:\n        ...\n\n    def __iadd__(self, other: Bad) -> Self:\n        ...\n```\n## References\n- [PEP 673](https://peps.python.org/pep-0673/)\n"
  },
  {
    "name": "unassigned-special-variable-in-stub",
    "code": "PYI035",
    "linter": "flake8-pyi",
    "summary": "`{name}` in a stub file must have a value, as it has the same semantics as `{name}` at runtime",
    "message_formats": [
      "`{name}` in a stub file must have a value, as it has the same semantics as `{name}` at runtime"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "snake-case-type-alias",
    "code": "PYI042",
    "linter": "flake8-pyi",
    "summary": "Type alias `{name}` should be CamelCase",
    "message_formats": [
      "Type alias `{name}` should be CamelCase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "t-suffixed-type-alias",
    "code": "PYI043",
    "linter": "flake8-pyi",
    "summary": "Private type alias `{name}` should not be suffixed with `T` (the `T` suffix implies that an object is a `TypeVar`)",
    "message_formats": [
      "Private type alias `{name}` should not be suffixed with `T` (the `T` suffix implies that an object is a `TypeVar`)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "future-annotations-in-stub",
    "code": "PYI044",
    "linter": "flake8-pyi",
    "summary": "`from __future__ import annotations` has no effect in stub files, since type checkers automatically treat stubs as having those semantics",
    "message_formats": [
      "`from __future__ import annotations` has no effect in stub files, since type checkers automatically treat stubs as having those semantics"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "iter-method-return-iterable",
    "code": "PYI045",
    "linter": "flake8-pyi",
    "summary": "`__aiter__` methods should return an `AsyncIterator`, not an `AsyncIterable`",
    "message_formats": [
      "`__aiter__` methods should return an `AsyncIterator`, not an `AsyncIterable`",
      "`__iter__` methods should return an `Iterator`, not an `Iterable`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__iter__` methods in stubs that return `Iterable[T]` instead\nof an `Iterator[T]`.\n\n## Why is this bad?\n`__iter__` methods should always should return an `Iterator` of some kind,\nnot an `Iterable`.\n\nIn Python, an `Iterator` is an object that has a `__next__` method, which\nprovides a consistent interface for sequentially processing elements from\na sequence or other iterable object. Meanwhile, an `Iterable` is an object\nwith an `__iter__` method, which itself returns an `Iterator`.\n\nEvery `Iterator` is an `Iterable`, but not every `Iterable` is an `Iterator`.\nBy returning an `Iterable` from `__iter__`, you may end up returning an\nobject that doesn't implement `__next__`, which will cause a `TypeError`\nat runtime. For example, returning a `list` from `__iter__` will cause\na `TypeError` when you call `__next__` on it, as a `list` is an `Iterable`,\nbut not an `Iterator`.\n\n## Example\n```python\nimport collections.abc\n\n\nclass Class:\n    def __iter__(self) -> collections.abc.Iterable[str]:\n        ...\n```\n\nUse instead:\n```python\nimport collections.abc\n\n\nclass Class:\n    def __iter__(self) -> collections.abc.Iterator[str]:\n        ...\n```\n"
  },
  {
    "name": "stub-body-multiple-statements",
    "code": "PYI048",
    "linter": "flake8-pyi",
    "summary": "Function body must contain exactly one statement",
    "message_formats": [
      "Function body must contain exactly one statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "no-return-argument-annotation-in-stub",
    "code": "PYI050",
    "linter": "flake8-pyi",
    "summary": "Prefer `{module}.Never` over `NoReturn` for argument annotations",
    "message_formats": [
      "Prefer `{module}.Never` over `NoReturn` for argument annotations"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "unannotated-assignment-in-stub",
    "code": "PYI052",
    "linter": "flake8-pyi",
    "summary": "Need type annotation for `{name}`",
    "message_formats": [
      "Need type annotation for `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "string-or-bytes-too-long",
    "code": "PYI053",
    "linter": "flake8-pyi",
    "summary": "String and bytes literals longer than 50 characters are not permitted",
    "message_formats": [
      "String and bytes literals longer than 50 characters are not permitted"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "numeric-literal-too-long",
    "code": "PYI054",
    "linter": "flake8-pyi",
    "summary": "Numeric literals with a string representation longer than ten characters are not permitted",
    "message_formats": [
      "Numeric literals with a string representation longer than ten characters are not permitted"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-fixture-incorrect-parentheses-style",
    "code": "PT001",
    "linter": "flake8-pytest-style",
    "summary": "Use `@pytest.fixture{expected}` over `@pytest.fixture{actual}`",
    "message_formats": [
      "Use `@pytest.fixture{expected}` over `@pytest.fixture{actual}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-fixture-positional-args",
    "code": "PT002",
    "linter": "flake8-pytest-style",
    "summary": "Configuration for fixture `{function}` specified via positional args, use kwargs",
    "message_formats": [
      "Configuration for fixture `{function}` specified via positional args, use kwargs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-extraneous-scope-function",
    "code": "PT003",
    "linter": "flake8-pytest-style",
    "summary": "`scope='function'` is implied in `@pytest.fixture()`",
    "message_formats": [
      "`scope='function'` is implied in `@pytest.fixture()`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-missing-fixture-name-underscore",
    "code": "PT004",
    "linter": "flake8-pytest-style",
    "summary": "Fixture `{function}` does not return anything, add leading underscore",
    "message_formats": [
      "Fixture `{function}` does not return anything, add leading underscore"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-incorrect-fixture-name-underscore",
    "code": "PT005",
    "linter": "flake8-pytest-style",
    "summary": "Fixture `{function}` returns a value, remove leading underscore",
    "message_formats": [
      "Fixture `{function}` returns a value, remove leading underscore"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-parametrize-names-wrong-type",
    "code": "PT006",
    "linter": "flake8-pytest-style",
    "summary": "Wrong name(s) type in `@pytest.mark.parametrize`, expected `{expected}`",
    "message_formats": [
      "Wrong name(s) type in `@pytest.mark.parametrize`, expected `{expected}`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": null
  },
  {
    "name": "pytest-parametrize-values-wrong-type",
    "code": "PT007",
    "linter": "flake8-pytest-style",
    "summary": "Wrong values type in `@pytest.mark.parametrize` expected `{values}` of `{row}`",
    "message_formats": [
      "Wrong values type in `@pytest.mark.parametrize` expected `{values}` of `{row}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-patch-with-lambda",
    "code": "PT008",
    "linter": "flake8-pytest-style",
    "summary": "Use `return_value=` instead of patching with `lambda`",
    "message_formats": [
      "Use `return_value=` instead of patching with `lambda`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-unittest-assertion",
    "code": "PT009",
    "linter": "flake8-pytest-style",
    "summary": "Use a regular `assert` instead of unittest-style `{assertion}`",
    "message_formats": [
      "Use a regular `assert` instead of unittest-style `{assertion}`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": null
  },
  {
    "name": "pytest-raises-without-exception",
    "code": "PT010",
    "linter": "flake8-pytest-style",
    "summary": "set the expected exception in `pytest.raises()`",
    "message_formats": [
      "set the expected exception in `pytest.raises()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-raises-too-broad",
    "code": "PT011",
    "linter": "flake8-pytest-style",
    "summary": "`pytest.raises({exception})` is too broad, set the `match` parameter or use a more specific exception",
    "message_formats": [
      "`pytest.raises({exception})` is too broad, set the `match` parameter or use a more specific exception"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-raises-with-multiple-statements",
    "code": "PT012",
    "linter": "flake8-pytest-style",
    "summary": "`pytest.raises()` block should contain a single simple statement",
    "message_formats": [
      "`pytest.raises()` block should contain a single simple statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-incorrect-pytest-import",
    "code": "PT013",
    "linter": "flake8-pytest-style",
    "summary": "Found incorrect import of pytest, use simple `import pytest` instead",
    "message_formats": [
      "Found incorrect import of pytest, use simple `import pytest` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-assert-always-false",
    "code": "PT015",
    "linter": "flake8-pytest-style",
    "summary": "Assertion always fails, replace with `pytest.fail()`",
    "message_formats": [
      "Assertion always fails, replace with `pytest.fail()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-fail-without-message",
    "code": "PT016",
    "linter": "flake8-pytest-style",
    "summary": "No message passed to `pytest.fail()`",
    "message_formats": [
      "No message passed to `pytest.fail()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-assert-in-except",
    "code": "PT017",
    "linter": "flake8-pytest-style",
    "summary": "Found assertion on exception `{name}` in `except` block, use `pytest.raises()` instead",
    "message_formats": [
      "Found assertion on exception `{name}` in `except` block, use `pytest.raises()` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-composite-assertion",
    "code": "PT018",
    "linter": "flake8-pytest-style",
    "summary": "Assertion should be broken down into multiple parts",
    "message_formats": [
      "Assertion should be broken down into multiple parts"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for assertions that combine multiple independent conditions.\n\n## Why is this bad?\nComposite assertion statements are harder debug upon failure, as the\nfailure message will not indicate which condition failed.\n\n## Example\n```python\ndef test_foo():\n    assert something and something_else\n\n\ndef test_bar():\n    assert not (something or something_else)\n```\n\nUse instead:\n```python\ndef test_foo():\n    assert something\n    assert something_else\n\n\ndef test_bar():\n    assert not something\n    assert not something_else\n```\n"
  },
  {
    "name": "pytest-fixture-param-without-value",
    "code": "PT019",
    "linter": "flake8-pytest-style",
    "summary": "Fixture `{name}` without value is injected as parameter, use `@pytest.mark.usefixtures` instead",
    "message_formats": [
      "Fixture `{name}` without value is injected as parameter, use `@pytest.mark.usefixtures` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-deprecated-yield-fixture",
    "code": "PT020",
    "linter": "flake8-pytest-style",
    "summary": "`@pytest.yield_fixture` is deprecated, use `@pytest.fixture`",
    "message_formats": [
      "`@pytest.yield_fixture` is deprecated, use `@pytest.fixture`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-fixture-finalizer-callback",
    "code": "PT021",
    "linter": "flake8-pytest-style",
    "summary": "Use `yield` instead of `request.addfinalizer`",
    "message_formats": [
      "Use `yield` instead of `request.addfinalizer`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pytest-useless-yield-fixture",
    "code": "PT022",
    "linter": "flake8-pytest-style",
    "summary": "No teardown in fixture `{name}`, use `return` instead of `yield`",
    "message_formats": [
      "No teardown in fixture `{name}`, use `return` instead of `yield`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-incorrect-mark-parentheses-style",
    "code": "PT023",
    "linter": "flake8-pytest-style",
    "summary": "Use `@pytest.mark.{mark_name}{expected_parens}` over `@pytest.mark.{mark_name}{actual_parens}`",
    "message_formats": [
      "Use `@pytest.mark.{mark_name}{expected_parens}` over `@pytest.mark.{mark_name}{actual_parens}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-unnecessary-asyncio-mark-on-fixture",
    "code": "PT024",
    "linter": "flake8-pytest-style",
    "summary": "`pytest.mark.asyncio` is unnecessary for fixtures",
    "message_formats": [
      "`pytest.mark.asyncio` is unnecessary for fixtures"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-erroneous-use-fixtures-on-fixture",
    "code": "PT025",
    "linter": "flake8-pytest-style",
    "summary": "`pytest.mark.usefixtures` has no effect on fixtures",
    "message_formats": [
      "`pytest.mark.usefixtures` has no effect on fixtures"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "pytest-use-fixtures-without-parameters",
    "code": "PT026",
    "linter": "flake8-pytest-style",
    "summary": "Useless `pytest.mark.usefixtures` without parameters",
    "message_formats": [
      "Useless `pytest.mark.usefixtures` without parameters"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "bad-quotes-inline-string",
    "code": "Q000",
    "linter": "flake8-quotes",
    "summary": "Double quotes found but single quotes preferred",
    "message_formats": [
      "Double quotes found but single quotes preferred",
      "Single quotes found but double quotes preferred"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for inline strings that use single quotes or double quotes,\ndepending on the value of the [`flake8-quotes.inline-quotes`] option.\n\n## Why is this bad?\nConsistency is good. Use either single or double quotes for inline\nstrings, but be consistent.\n\n## Example\n```python\nfoo = 'bar'\n```\n\nAssuming `inline-quotes` is set to `double`, use instead:\n```python\nfoo = \"bar\"\n```\n\n## Options\n- `flake8-quotes.inline-quotes`\n"
  },
  {
    "name": "bad-quotes-multiline-string",
    "code": "Q001",
    "linter": "flake8-quotes",
    "summary": "Double quote multiline found but single quotes preferred",
    "message_formats": [
      "Double quote multiline found but single quotes preferred",
      "Single quote multiline found but double quotes preferred"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for multiline strings that use single quotes or double quotes,\ndepending on the value of the [`flake8-quotes.multiline-quotes`]\nsetting.\n\n## Why is this bad?\nConsistency is good. Use either single or double quotes for multiline\nstrings, but be consistent.\n\n## Example\n```python\nfoo = '''\nbar\n'''\n```\n\nAssuming `multiline-quotes` is set to `double`, use instead:\n```python\nfoo = \"\"\"\nbar\n\"\"\"\n```\n\n## Options\n- `flake8-quotes.multiline-quotes`\n"
  },
  {
    "name": "bad-quotes-docstring",
    "code": "Q002",
    "linter": "flake8-quotes",
    "summary": "Double quote docstring found but single quotes preferred",
    "message_formats": [
      "Double quote docstring found but single quotes preferred",
      "Single quote docstring found but double quotes preferred"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings that use single quotes or double quotes, depending\non the value of the [`flake8-quotes.docstring-quotes`] setting.\n\n## Why is this bad?\nConsistency is good. Use either single or double quotes for docstring\nstrings, but be consistent.\n\n## Example\n```python\n'''\nbar\n'''\n```\n\nAssuming `docstring-quotes` is set to `double`, use instead:\n```python\n\"\"\"\nbar\n\"\"\"\n```\n\n## Options\n- `flake8-quotes.docstring-quotes`\n"
  },
  {
    "name": "avoidable-escaped-quote",
    "code": "Q003",
    "linter": "flake8-quotes",
    "summary": "Change outer quotes to avoid escaping inner quotes",
    "message_formats": [
      "Change outer quotes to avoid escaping inner quotes"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that include escaped quotes, and suggests changing\nthe quote style to avoid the need to escape them.\n\n## Why is this bad?\nIt's preferable to avoid escaped quotes in strings. By changing the\nouter quote style, you can avoid escaping inner quotes.\n\n## Example\n```python\nfoo = 'bar\\'s'\n```\n\nUse instead:\n```python\nfoo = \"bar's\"\n```\n"
  },
  {
    "name": "unnecessary-paren-on-raise-exception",
    "code": "RSE102",
    "linter": "flake8-raise",
    "summary": "Unnecessary parentheses on raised exception",
    "message_formats": [
      "Unnecessary parentheses on raised exception"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary parentheses on raised exceptions.\n\n## Why is this bad?\nIf an exception is raised without any arguments, parentheses are not\nrequired, as the `raise` statement accepts either an exception instance\nor an exception class (which is then implicitly instantiated).\n\nRemoving the parentheses makes the code more concise.\n\n## Example\n```python\nraise TypeError()\n```\n\nUse instead:\n```python\nraise TypeError\n```\n\n## References\n- [Python documentation: The `raise` statement](https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement)\n"
  },
  {
    "name": "unnecessary-return-none",
    "code": "RET501",
    "linter": "flake8-return",
    "summary": "Do not explicitly `return None` in function if it is the only possible return value",
    "message_formats": [
      "Do not explicitly `return None` in function if it is the only possible return value"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the presence of a `return None` statement when `None` is the only\npossible return value.\n\n## Why is this bad?\nPython implicitly assumes `return None` if an explicit `return` value is\nomitted. Therefore, explicitly returning `None` is redundant and should be\navoided when it is the only possible `return` value across all code paths\nin a given function.\n\n## Example\n```python\ndef foo(bar):\n    if not bar:\n        return\n    return None\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return\n    return\n```\n"
  },
  {
    "name": "implicit-return-value",
    "code": "RET502",
    "linter": "flake8-return",
    "summary": "Do not implicitly `return None` in function able to return non-`None` value",
    "message_formats": [
      "Do not implicitly `return None` in function able to return non-`None` value"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the presence of a `return` statement with no explicit value,\nfor functions that return non-`None` values elsewhere.\n\n## Why is this bad?\nIncluding a `return` statement with no explicit value can cause confusion\nwhen other `return` statements in the function return non-`None` values.\nPython implicitly assumes return `None` if no other return value is present.\nAdding an explicit `return None` can make the code more readable by clarifying\nintent.\n\n## Example\n```python\ndef foo(bar):\n    if not bar:\n        return\n    return 1\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return None\n    return 1\n```\n"
  },
  {
    "name": "implicit-return",
    "code": "RET503",
    "linter": "flake8-return",
    "summary": "Missing explicit `return` at the end of function able to return non-`None` value",
    "message_formats": [
      "Missing explicit `return` at the end of function able to return non-`None` value"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for missing explicit `return` statements at the end of functions\nthat can return non-`None` values.\n\n## Why is this bad?\nThe lack of an explicit `return` statement at the end of a function that\ncan return non-`None` values can cause confusion. Python implicitly returns\n`None` if no other return value is present. Adding an explicit\n`return None` can make the code more readable by clarifying intent.\n\n## Example\n```python\ndef foo(bar):\n    if not bar:\n        return 1\n```\n\nUse instead:\n```python\ndef foo(bar):\n    if not bar:\n        return 1\n    return None\n```\n"
  },
  {
    "name": "unnecessary-assign",
    "code": "RET504",
    "linter": "flake8-return",
    "summary": "Unnecessary assignment to `{name}` before `return` statement",
    "message_formats": [
      "Unnecessary assignment to `{name}` before `return` statement"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for variable assignments that immediately precede a `return` of the\nassigned variable.\n\n## Why is this bad?\nThe variable assignment is not necessary as the value can be returned\ndirectly.\n\n## Example\n```python\ndef foo():\n    bar = 1\n    return bar\n```\n\nUse instead:\n```python\ndef foo():\n    return 1\n```\n"
  },
  {
    "name": "superfluous-else-return",
    "code": "RET505",
    "linter": "flake8-return",
    "summary": "Unnecessary `{branch}` after `return` statement",
    "message_formats": [
      "Unnecessary `{branch}` after `return` statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` statements with a `return` statement in the preceding\n`if` block.\n\n## Why is this bad?\nThe `else` statement is not needed as the `return` statement will always\nbreak out of the enclosing function. Removing the `else` will reduce\nnesting and make the code more readable.\n\n## Example\n```python\ndef foo(bar, baz):\n    if bar:\n        return 1\n    else:\n        return baz\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    if bar:\n        return 1\n    return baz\n```\n"
  },
  {
    "name": "superfluous-else-raise",
    "code": "RET506",
    "linter": "flake8-return",
    "summary": "Unnecessary `{branch}` after `raise` statement",
    "message_formats": [
      "Unnecessary `{branch}` after `raise` statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` statements with a `raise` statement in the preceding `if`\nblock.\n\n## Why is this bad?\nThe `else` statement is not needed as the `raise` statement will always\nbreak out of the current scope. Removing the `else` will reduce nesting\nand make the code more readable.\n\n## Example\n```python\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    else:\n        raise Exception(baz)\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    if bar == \"Specific Error\":\n        raise Exception(bar)\n    raise Exception(baz)\n```\n"
  },
  {
    "name": "superfluous-else-continue",
    "code": "RET507",
    "linter": "flake8-return",
    "summary": "Unnecessary `{branch}` after `continue` statement",
    "message_formats": [
      "Unnecessary `{branch}` after `continue` statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` statements with a `continue` statement in the preceding\n`if` block.\n\n## Why is this bad?\nThe `else` statement is not needed, as the `continue` statement will always\ncontinue onto the next iteration of a loop. Removing the `else` will reduce\nnesting and make the code more readable.\n\n## Example\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        else:\n            x = 0\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i < baz:\n            continue\n        x = 0\n```\n"
  },
  {
    "name": "superfluous-else-break",
    "code": "RET508",
    "linter": "flake8-return",
    "summary": "Unnecessary `{branch}` after `break` statement",
    "message_formats": [
      "Unnecessary `{branch}` after `break` statement"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` statements with a `break` statement in the preceding `if`\nblock.\n\n## Why is this bad?\nThe `else` statement is not needed, as the `break` statement will always\nbreak out of the loop. Removing the `else` will reduce nesting and make the\ncode more readable.\n\n## Example\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        else:\n            x = 0\n```\n\nUse instead:\n```python\ndef foo(bar, baz):\n    for i in bar:\n        if i > baz:\n            break\n        x = 0\n```\n"
  },
  {
    "name": "private-member-access",
    "code": "SLF001",
    "linter": "flake8-self",
    "summary": "Private member accessed: `{access}`",
    "message_formats": [
      "Private member accessed: `{access}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for accesses on \"private\" class members.\n\n## Why is this bad?\nIn Python, the convention is such that class members that are prefixed\nwith a single underscore, or prefixed but not suffixed with a double\nunderscore, are considered private and intended for internal use.\n\nUsing such \"private\" members is considered a misuse of the class, as\nthere are no guarantees that the member will be present in future\nversions, that it will have the same type, or that it will have the same\nbehavior. Instead, use the class's public interface.\n\n## Example\n```python\nclass Class:\n    def __init__(self):\n        self._private_member = \"...\"\n\n\nvar = Class()\nprint(var._private_member)\n```\n\nUse instead:\n```python\nclass Class:\n    def __init__(self):\n        self.public_member = \"...\"\n\n\nvar = Class()\nprint(var.public_member)\n```\n\n## Options\n- `flake8-self.ignore-names`\n\n## References\n- [_What is the meaning of single or double underscores before an object name?_](https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name)\n"
  },
  {
    "name": "duplicate-isinstance-call",
    "code": "SIM101",
    "linter": "flake8-simplify",
    "summary": "Multiple `isinstance` calls for `{name}`, merge into a single call",
    "message_formats": [
      "Multiple `isinstance` calls for `{name}`, merge into a single call",
      "Multiple `isinstance` calls for expression, merge into a single call"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for multiple `isinstance` calls on the same target.\n\n## Why is this bad?\nTo check if an object is an instance of any one of multiple types\nor classes, it is unnecessary to use multiple `isinstance` calls, as\nthe second argument of the `isinstance` built-in function accepts a\ntuple of types and classes.\n\nUsing a single `isinstance` call implements the same behavior with more\nconcise code and clearer intent.\n\n## Example\n```python\nif isinstance(obj, int) or isinstance(obj, float):\n    pass\n```\n\nUse instead:\n```python\nif isinstance(obj, (int, float)):\n    pass\n```\n\n## References\n- [Python documentation: `isinstance`](https://docs.python.org/3/library/functions.html#isinstance)\n"
  },
  {
    "name": "collapsible-if",
    "code": "SIM102",
    "linter": "flake8-simplify",
    "summary": "Use a single `if` statement instead of nested `if` statements",
    "message_formats": [
      "Use a single `if` statement instead of nested `if` statements"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for nested `if` statements that can be collapsed into a single `if`\nstatement.\n\n## Why is this bad?\nNesting `if` statements leads to deeper indentation and makes code harder to\nread. Instead, combine the conditions into a single `if` statement with an\n`and` operator.\n\n## Example\n```python\nif foo:\n    if bar:\n        ...\n```\n\nUse instead:\n```python\nif foo and bar:\n    ...\n```\n\n## References\n- [Python documentation: The `if` statement](https://docs.python.org/3/reference/compound_stmts.html#the-if-statement)\n- [Python documentation: Boolean operations](https://docs.python.org/3/reference/expressions.html#boolean-operations)\n"
  },
  {
    "name": "needless-bool",
    "code": "SIM103",
    "linter": "flake8-simplify",
    "summary": "Return the condition `{condition}` directly",
    "message_formats": [
      "Return the condition `{condition}` directly"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `if` statements that can be replaced with `bool`.\n\n## Why is this bad?\n`if` statements that return `True` for a truthy condition and `False` for\na falsey condition can be replaced with boolean casts.\n\n## Example\n```python\nif foo:\n    return True\nelse:\n    return False\n```\n\nUse instead:\n```python\nreturn bool(foo)\n```\n\n## References\n- [Python documentation: Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)\n"
  },
  {
    "name": "suppressible-exception",
    "code": "SIM105",
    "linter": "flake8-simplify",
    "summary": "Use `contextlib.suppress({exception})` instead of `try`-`except`-`pass`",
    "message_formats": [
      "Use `contextlib.suppress({exception})` instead of `try`-`except`-`pass`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `try`-`except`-`pass` blocks that can be replaced with the\n`contextlib.suppress` context manager.\n\n## Why is this bad?\nUsing `contextlib.suppress` is more concise and directly communicates the\nintent of the code: to suppress a given exception.\n\nNote that `contextlib.suppress` is slower than using `try`-`except`-`pass`\ndirectly. For performance-critical code, consider retaining the\n`try`-`except`-`pass` pattern.\n\n## Example\n```python\ntry:\n    1 / 0\nexcept ZeroDivisionError:\n    pass\n```\n\nUse instead:\n```python\nimport contextlib\n\nwith contextlib.suppress(ZeroDivisionError):\n    1 / 0\n```\n\n## References\n- [Python documentation: `contextlib.suppress`](https://docs.python.org/3/library/contextlib.html#contextlib.suppress)\n- [Python documentation: `try` statement](https://docs.python.org/3/reference/compound_stmts.html#the-try-statement)\n- [a simpler `try`/`except` (and why maybe shouldn't)](https://www.youtube.com/watch?v=MZAJ8qnC7mk)\n"
  },
  {
    "name": "return-in-try-except-finally",
    "code": "SIM107",
    "linter": "flake8-simplify",
    "summary": "Don't use `return` in `try`-`except` and `finally`",
    "message_formats": [
      "Don't use `return` in `try`-`except` and `finally`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `return` statements in `try`-`except` and `finally` blocks.\n\n## Why is this bad?\nThe `return` statement in a `finally` block will always be executed, even if\nan exception is raised in the `try` or `except` block. This can lead to\nunexpected behavior.\n\n## Example\n```python\ndef squared(n):\n    try:\n        sqr = n**2\n        return sqr\n    except Exception:\n        return \"An exception occurred\"\n    finally:\n        return -1  # Always returns -1.\n```\n\nUse instead:\n```python\ndef squared(n):\n    try:\n        return_value = n**2\n    except Exception:\n        return_value = \"An exception occurred\"\n    finally:\n        return_value = -1\n    return return_value\n```\n\n## References\n- [Python documentation: Defining Clean-up Actions](https://docs.python.org/3/tutorial/errors.html#defining-clean-up-actions)\n"
  },
  {
    "name": "if-else-block-instead-of-if-exp",
    "code": "SIM108",
    "linter": "flake8-simplify",
    "summary": "Use ternary operator `{contents}` instead of `if`-`else`-block",
    "message_formats": [
      "Use ternary operator `{contents}` instead of `if`-`else`-block"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nCheck for `if`-`else`-blocks that can be replaced with a ternary operator.\n\n## Why is this bad?\n`if`-`else`-blocks that assign a value to a variable in both branches can\nbe expressed more concisely by using a ternary operator.\n\n## Example\n```python\nif foo:\n    bar = x\nelse:\n    bar = y\n```\n\nUse instead:\n```python\nbar = x if foo else y\n```\n\n## References\n- [Python documentation: Conditional expressions](https://docs.python.org/3/reference/expressions.html#conditional-expressions)\n"
  },
  {
    "name": "compare-with-tuple",
    "code": "SIM109",
    "linter": "flake8-simplify",
    "summary": "Use `{replacement}` instead of multiple equality comparisons",
    "message_formats": [
      "Use `{replacement}` instead of multiple equality comparisons"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for boolean expressions that contain multiple equality comparisons\nto the same value.\n\n## Why is this bad?\nTo check if an object is equal to any one of multiple values, it's more\nconcise to use the `in` operator with a tuple of values.\n\n## Example\n```python\nif foo == x or foo == y:\n    ...\n```\n\nUse instead:\n```python\nif foo in (x, y):\n    ...\n```\n\n## References\n- [Python documentation: Membership test operations](https://docs.python.org/3/reference/expressions.html#membership-test-operations)\n"
  },
  {
    "name": "reimplemented-builtin",
    "code": "SIM110",
    "linter": "flake8-simplify",
    "summary": "Use `{repl}` instead of `for` loop",
    "message_formats": [
      "Use `{repl}` instead of `for` loop"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `for` loops that can be replaced with a builtin function, like\n`any` or `all`.\n\n## Why is this bad?\nUsing a builtin function is more concise and readable. Builtins are also\nmore efficient than `for` loops.\n\n## Example\n```python\nfor item in iterable:\n    if predicate(item):\n        return True\nreturn False\n```\n\nUse instead:\n```python\nreturn any(predicate(item) for item in iterable)\n```\n\n## References\n- [Python documentation: `any`](https://docs.python.org/3/library/functions.html#any)\n- [Python documentation: `all`](https://docs.python.org/3/library/functions.html#all)\n"
  },
  {
    "name": "uncapitalized-environment-variables",
    "code": "SIM112",
    "linter": "flake8-simplify",
    "summary": "Use capitalized environment variable `{expected}` instead of `{original}`",
    "message_formats": [
      "Use capitalized environment variable `{expected}` instead of `{original}`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nCheck for environment variables that are not capitalized.\n\n## Why is this bad?\nBy convention, environment variables should be capitalized.\n\nOn Windows, environment variables are case-insensitive and are converted to\nuppercase, so using lowercase environment variables can lead to subtle bugs.\n\n## Example\n```python\nimport os\n\nos.environ[\"foo\"]\n```\n\nUse instead:\n```python\nimport os\n\nos.environ[\"FOO\"]\n```\n\n## References\n- [Python documentation: `os.environ`](https://docs.python.org/3/library/os.html#os.environ)\n"
  },
  {
    "name": "if-with-same-arms",
    "code": "SIM114",
    "linter": "flake8-simplify",
    "summary": "Combine `if` branches using logical `or` operator",
    "message_formats": [
      "Combine `if` branches using logical `or` operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `if` branches with identical arm bodies.\n\n## Why is this bad?\nIf multiple arms of an `if` statement have the same body, using `or`\nbetter signals the intent of the statement.\n\n## Example\n```python\nif x == 1:\n    print(\"Hello\")\nelif x == 2:\n    print(\"Hello\")\n```\n\nUse instead:\n```python\nif x == 1 or x == 2:\n    print(\"Hello\")\n```\n"
  },
  {
    "name": "open-file-with-context-handler",
    "code": "SIM115",
    "linter": "flake8-simplify",
    "summary": "Use context handler for opening files",
    "message_formats": [
      "Use context handler for opening files"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of the builtin `open()` function without an associated context\nmanager.\n\n## Why is this bad?\nIf a file is opened without a context manager, it is not guaranteed that\nthe file will be closed (e.g., if an exception is raised), which can cause\nresource leaks.\n\n## Example\n```python\nfile = open(\"foo.txt\")\n...\nfile.close()\n```\n\nUse instead:\n```python\nwith open(\"foo.txt\") as file:\n    ...\n```\n\n# References\n- [Python documentation: `open`](https://docs.python.org/3/library/functions.html#open)\n"
  },
  {
    "name": "if-else-block-instead-of-dict-lookup",
    "code": "SIM116",
    "linter": "flake8-simplify",
    "summary": "Use a dictionary instead of consecutive `if` statements",
    "message_formats": [
      "Use a dictionary instead of consecutive `if` statements"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for three or more consecutive if-statements with direct returns\n\n## Why is this bad?\nThese can be simplified by using a dictionary\n\n## Example\n```python\nif x == 1:\n    return \"Hello\"\nelif x == 2:\n    return \"Goodbye\"\nelse:\n    return \"Goodnight\"\n```\n\nUse instead:\n```python\nreturn {1: \"Hello\", 2: \"Goodbye\"}.get(x, \"Goodnight\")\n```\n"
  },
  {
    "name": "multiple-with-statements",
    "code": "SIM117",
    "linter": "flake8-simplify",
    "summary": "Use a single `with` statement with multiple contexts instead of nested `with` statements",
    "message_formats": [
      "Use a single `with` statement with multiple contexts instead of nested `with` statements"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the unnecessary nesting of multiple consecutive context\nmanagers.\n\n## Why is this bad?\nIn Python 3, a single `with` block can include multiple context\nmanagers.\n\nCombining multiple context managers into a single `with` statement\nwill minimize the indentation depth of the code, making it more\nreadable.\n\n## Example\n```python\nwith A() as a:\n    with B() as b:\n        pass\n```\n\nUse instead:\n```python\nwith A() as a, B() as b:\n    pass\n```\n\n## References\n- [Python documentation: The `with` statement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement)\n"
  },
  {
    "name": "in-dict-keys",
    "code": "SIM118",
    "linter": "flake8-simplify",
    "summary": "Use `{key} in {dict}` instead of `{key} in {dict}.keys()`",
    "message_formats": [
      "Use `{key} in {dict}` instead of `{key} in {dict}.keys()`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for key-existence checks against `dict.keys()` calls.\n\n## Why is this bad?\nWhen checking for the existence of a key in a given dictionary, using\n`key in dict` is more readable and efficient than `key in dict.keys()`,\nwhile having the same semantics.\n\n## Example\n```python\nkey in foo.keys()\n```\n\nUse instead:\n```python\nkey in foo\n```\n\n## References\n- [Python documentation: Mapping Types](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\n"
  },
  {
    "name": "negate-equal-op",
    "code": "SIM201",
    "linter": "flake8-simplify",
    "summary": "Use `{left} != {right}` instead of `not {left} == {right}`",
    "message_formats": [
      "Use `{left} != {right}` instead of `not {left} == {right}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for negated `==` operators.\n\n## Why is this bad?\nNegated `==` operators are less readable than `!=` operators. When testing\nfor non-equality, it is more common to use `!=` than `==`.\n\n## Example\n```python\nnot a == b\n```\n\nUse instead:\n```python\na != b\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n"
  },
  {
    "name": "negate-not-equal-op",
    "code": "SIM202",
    "linter": "flake8-simplify",
    "summary": "Use `{left} == {right}` instead of `not {left} != {right}`",
    "message_formats": [
      "Use `{left} == {right}` instead of `not {left} != {right}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for negated `!=` operators.\n\n## Why is this bad?\nNegated `!=` operators are less readable than `==` operators, as they avoid a\ndouble negation.\n\n## Example\n```python\nnot a != b\n```\n\nUse instead:\n```python\na == b\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n"
  },
  {
    "name": "double-negation",
    "code": "SIM208",
    "linter": "flake8-simplify",
    "summary": "Use `{expr}` instead of `not (not {expr})`",
    "message_formats": [
      "Use `{expr}` instead of `not (not {expr})`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for double negations (i.e., multiple `not` operators).\n\n## Why is this bad?\nA double negation is redundant and less readable than omitting the `not`\noperators entirely.\n\n## Example\n```python\nnot (not a)\n```\n\nUse instead:\n```python\na\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n"
  },
  {
    "name": "if-expr-with-true-false",
    "code": "SIM210",
    "linter": "flake8-simplify",
    "summary": "Use `bool({expr})` instead of `True if {expr} else False`",
    "message_formats": [
      "Use `bool({expr})` instead of `True if {expr} else False`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `if` expressions that can be replaced with `bool()` calls.\n\n## Why is this bad?\n`if` expressions that evaluate to `True` for a truthy condition an `False`\nfor a falsey condition can be replaced with `bool()` calls, which are more\nconcise and readable.\n\n## Example\n```python\nTrue if a else False\n```\n\nUse instead:\n```python\nbool(a)\n```\n\n## References\n- [Python documentation: Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)\n"
  },
  {
    "name": "if-expr-with-false-true",
    "code": "SIM211",
    "linter": "flake8-simplify",
    "summary": "Use `not {expr}` instead of `False if {expr} else True`",
    "message_formats": [
      "Use `not {expr}` instead of `False if {expr} else True`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `if` expressions that can be replaced by negating a given\ncondition.\n\n## Why is this bad?\n`if` expressions that evaluate to `False` for a truthy condition an `True`\nfor a falsey condition can be replaced with `not` operators, which are more\nconcise and readable.\n\n## Example\n```python\nFalse if a else True\n```\n\nUse instead:\n```python\nnot a\n```\n\n## References\n- [Python documentation: Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)\n"
  },
  {
    "name": "if-expr-with-twisted-arms",
    "code": "SIM212",
    "linter": "flake8-simplify",
    "summary": "Use `{expr_else} if {expr_else} else {expr_body}` instead of `{expr_body} if not {expr_else} else {expr_else}`",
    "message_formats": [
      "Use `{expr_else} if {expr_else} else {expr_body}` instead of `{expr_body} if not {expr_else} else {expr_else}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `if` expressions that check against a negated condition.\n\n## Why is this bad?\n`if` expressions that check against a negated condition are more difficult\nto read than `if` expressions that check against the condition directly.\n\n## Example\n```python\nb if not a else a\n```\n\nUse instead:\n```python\na if a else b\n```\n\n## References\n- [Python documentation: Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)\n"
  },
  {
    "name": "expr-and-not-expr",
    "code": "SIM220",
    "linter": "flake8-simplify",
    "summary": "Use `False` instead of `{name} and not {name}`",
    "message_formats": [
      "Use `False` instead of `{name} and not {name}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `and` expressions that include both an expression and its\nnegation.\n\n## Why is this bad?\nAn `and` expression that includes both an expression and its negation will\nalways evaluate to `False`.\n\n## Example\n```python\nx and not x\n```\n\n## References\n- [Python documentation: Boolean operations](https://docs.python.org/3/reference/expressions.html#boolean-operations)\n"
  },
  {
    "name": "expr-or-not-expr",
    "code": "SIM221",
    "linter": "flake8-simplify",
    "summary": "Use `True` instead of `{name} or not {name}`",
    "message_formats": [
      "Use `True` instead of `{name} or not {name}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `or` expressions that include both an expression and its\nnegation.\n\n## Why is this bad?\nAn `or` expression that includes both an expression and its negation will\nalways evaluate to `True`.\n\n## Example\n```python\nx and not x\n```\n\n## References\n- [Python documentation: Boolean operations](https://docs.python.org/3/reference/expressions.html#boolean-operations)\n"
  },
  {
    "name": "expr-or-true",
    "code": "SIM222",
    "linter": "flake8-simplify",
    "summary": "Use `{expr}` instead of `{replaced}`",
    "message_formats": [
      "Use `{expr}` instead of `{replaced}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `or` expressions that contain truthy values.\n\n## Why is this bad?\nIf the expression is used as a condition, it can be replaced in-full with\n`True`.\n\nIn other cases, the expression can be short-circuited to the first truthy\nvalue.\n\nBy using `True` (or the first truthy value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.\n\n## Example\n```python\nif x or [1] or y:\n    pass\n\na = x or [1] or y\n```\n\nUse instead:\n```python\nif True:\n    pass\n\na = x or [1]\n```\n"
  },
  {
    "name": "expr-and-false",
    "code": "SIM223",
    "linter": "flake8-simplify",
    "summary": "Use `{expr}` instead of `{replaced}`",
    "message_formats": [
      "Use `{expr}` instead of `{replaced}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `and` expressions that contain falsey values.\n\n## Why is this bad?\nIf the expression is used as a condition, it can be replaced in-full with\n`False`.\n\nIn other cases, the expression can be short-circuited to the first falsey\nvalue.\n\nBy using `False` (or the first falsey value), the code is more concise\nand easier to understand, since it no longer contains redundant conditions.\n\n## Example\n```python\nif x and [] and y:\n    pass\n\na = x and [] and y\n```\n\nUse instead:\n```python\nif False:\n    pass\n\na = x and []\n```\n"
  },
  {
    "name": "yoda-conditions",
    "code": "SIM300",
    "linter": "flake8-simplify",
    "summary": "Yoda conditions are discouraged, use `{suggestion}` instead",
    "message_formats": [
      "Yoda conditions are discouraged, use `{suggestion}` instead",
      "Yoda conditions are discouraged"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for conditions that position a constant on the left-hand side of the\ncomparison operator, rather than the right-hand side.\n\n## Why is this bad?\nThese conditions (sometimes referred to as \"Yoda conditions\") are less\nreadable than conditions that place the variable on the left-hand side of\nthe comparison operator.\n\nIn some languages, Yoda conditions are used to prevent accidental\nassignment in conditions (i.e., accidental uses of the `=` operator,\ninstead of the `==` operator). However, Python does not allow assignments\nin conditions unless using the `:=` operator, so Yoda conditions provide\nno benefit in this regard.\n\n## Example\n```python\nif \"Foo\" == foo:\n    ...\n```\n\nUse instead:\n```python\nif foo == \"Foo\":\n    ...\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n- [Python documentation: Assignment statements](https://docs.python.org/3/reference/simple_stmts.html#assignment-statements)\n"
  },
  {
    "name": "if-else-block-instead-of-dict-get",
    "code": "SIM401",
    "linter": "flake8-simplify",
    "summary": "Use `{contents}` instead of an `if` block",
    "message_formats": [
      "Use `{contents}` instead of an `if` block"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `if` statements that can be replaced with `dict.get` calls.\n\n## Why is this bad?\n`dict.get()` calls can be used to replace `if` statements that assign a\nvalue to a variable in both branches, falling back to a default value if\nthe key is not found. When possible, using `dict.get` is more concise and\nmore idiomatic.\n\n## Example\n```python\nif \"bar\" in foo:\n    value = foo[\"bar\"]\nelse:\n    value = 0\n```\n\nUse instead:\n```python\nvalue = foo.get(\"bar\", 0)\n```\n\n## References\n- [Python documentation: Mapping Types](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)\n"
  },
  {
    "name": "dict-get-with-none-default",
    "code": "SIM910",
    "linter": "flake8-simplify",
    "summary": "Use `{expected}` instead of `{original}`",
    "message_formats": [
      "Use `{expected}` instead of `{original}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nCheck for `dict.get()` calls that pass `None` as the default value.\n\n## Why is this bad?\n`None` is the default value for `dict.get()`, so it is redundant to pass it\nexplicitly.\n\n## Example\n```python\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\", None)  # None\n```\n\nUse instead:\n```python\nages = {\"Tom\": 23, \"Maria\": 23, \"Dog\": 11}\nage = ages.get(\"Cat\")  # None\n```\n\n## References\n- [Python documentation: `dict.get`](https://docs.python.org/3/library/stdtypes.html#dict.get)\n"
  },
  {
    "name": "no-slots-in-str-subclass",
    "code": "SLOT000",
    "linter": "flake8-slots",
    "summary": "Subclasses of `str` should define `__slots__`",
    "message_formats": [
      "Subclasses of `str` should define `__slots__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for subclasses of `str` that lack a `__slots__` definition.\n\n## Why is this bad?\nIn Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `str` inherit all the attributes and methods of the built-in\n`str` class. Since strings are typically immutable, they don't require\nadditional attributes beyond what the `str` class provides. Defining\n`__slots__` for subclasses of `str` prevents the creation of a dictionary\nfor each instance, reducing memory consumption.\n\n## Example\n```python\nclass Foo(str):\n    pass\n```\n\nUse instead:\n```python\nclass Foo(str):\n    __slots__ = ()\n```\n\n## References\n- [Python documentation: `__slots__`](https://docs.python.org/3.7/reference/datamodel.html#slots)\n"
  },
  {
    "name": "no-slots-in-tuple-subclass",
    "code": "SLOT001",
    "linter": "flake8-slots",
    "summary": "Subclasses of `tuple` should define `__slots__`",
    "message_formats": [
      "Subclasses of `tuple` should define `__slots__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for subclasses of `tuple` that lack a `__slots__` definition.\n\n## Why is this bad?\nIn Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `tuple` inherit all the attributes and methods of the\nbuilt-in `tuple` class. Since tuples are typically immutable, they don't\nrequire additional attributes beyond what the `tuple` class provides.\nDefining `__slots__` for subclasses of `tuple` prevents the creation of a\ndictionary for each instance, reducing memory consumption.\n\n## Example\n```python\nclass Foo(tuple):\n    pass\n```\n\nUse instead:\n```python\nclass Foo(tuple):\n    __slots__ = ()\n```\n\n## References\n- [Python documentation: `__slots__`](https://docs.python.org/3.7/reference/datamodel.html#slots)\n"
  },
  {
    "name": "no-slots-in-namedtuple-subclass",
    "code": "SLOT002",
    "linter": "flake8-slots",
    "summary": "Subclasses of `collections.namedtuple()` should define `__slots__`",
    "message_formats": [
      "Subclasses of `collections.namedtuple()` should define `__slots__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for subclasses of `collections.namedtuple` that lack a `__slots__`\ndefinition.\n\n## Why is this bad?\nIn Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nSubclasses of `namedtuple` inherit all the attributes and methods of the\nbuilt-in `namedtuple` class. Since tuples are typically immutable, they\ndon't require additional attributes beyond what the `namedtuple` class\nprovides. Defining `__slots__` for subclasses of `namedtuple` prevents the\ncreation of a dictionary for each instance, reducing memory consumption.\n\n## Example\n```python\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    pass\n```\n\nUse instead:\n```python\nfrom collections import namedtuple\n\n\nclass Foo(namedtuple(\"foo\", [\"str\", \"int\"])):\n    __slots__ = ()\n```\n\n## References\n- [Python documentation: `__slots__`](https://docs.python.org/3.7/reference/datamodel.html#slots)\n"
  },
  {
    "name": "banned-api",
    "code": "TID251",
    "linter": "flake8-tidy-imports",
    "summary": "`{name}` is banned: {message}",
    "message_formats": [
      "`{name}` is banned: {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for banned imports.\n\n## Why is this bad?\nProjects may want to ensure that specific modules or module members are\nnot be imported or accessed.\n\nSecurity or other company policies may be a reason to impose\nrestrictions on importing external Python libraries. In some cases,\nprojects may adopt conventions around the use of certain modules or\nmodule members that are not enforceable by the language itself.\n\nThis rule enforces certain import conventions project-wide in an\nautomatic way.\n\n## Options\n- `flake8-tidy-imports.banned-api`\n"
  },
  {
    "name": "relative-imports",
    "code": "TID252",
    "linter": "flake8-tidy-imports",
    "summary": "Relative imports from parent modules are banned",
    "message_formats": [
      "Relative imports from parent modules are banned",
      "Relative imports are banned"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for relative imports.\n\n## Why is this bad?\nAbsolute imports, or relative imports from siblings, are recommended by [PEP 8]:\n\n> Absolute imports are recommended, as they are usually more readable and tend to be better behaved...\n> ```python\n> import mypkg.sibling\n> from mypkg import sibling\n> from mypkg.sibling import example\n> ```\n> However, explicit relative imports are an acceptable alternative to absolute imports,\n> especially when dealing with complex package layouts where using absolute imports would be\n> unnecessarily verbose:\n> ```python\n> from . import sibling\n> from .sibling import example\n> ```\n\n## Example\n```python\nfrom .. import foo\n```\n\nUse instead:\n```python\nfrom mypkg import foo\n```\n\n## Options\n- `flake8-tidy-imports.ban-relative-imports`\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports\n"
  },
  {
    "name": "invalid-todo-tag",
    "code": "TD001",
    "linter": "flake8-todos",
    "summary": "Invalid TODO tag: `{tag}`",
    "message_formats": [
      "Invalid TODO tag: `{tag}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that a TODO comment is labelled with \"TODO\".\n\n## Why is this bad?\nAmbiguous tags reduce code visibility and can lead to dangling TODOs.\nFor example, if a comment is tagged with \"FIXME\" rather than \"TODO\", it may\nbe overlooked by future readers.\n\nNote that this rule will only flag \"FIXME\" and \"XXX\" tags as incorrect.\n\n## Example\n```python\n# FIXME(ruff): this should get fixed!\n```\n\nUse instead:\n```python\n# TODO(ruff): this is now fixed!\n```\n"
  },
  {
    "name": "missing-todo-author",
    "code": "TD002",
    "linter": "flake8-todos",
    "summary": "Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`",
    "message_formats": [
      "Missing author in TODO; try: `# TODO(<author_name>): ...` or `# TODO @<author_name>: ...`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that a TODO comment includes an author.\n\n## Why is this bad?\nIncluding an author on a TODO provides future readers with context around\nthe issue. While the TODO author is not always considered responsible for\nfixing the issue, they are typically the individual with the most context.\n\n## Example\n```python\n# TODO: should assign an author here\n```\n\nUse instead\n```python\n# TODO(charlie): now an author is assigned\n```\n"
  },
  {
    "name": "missing-todo-link",
    "code": "TD003",
    "linter": "flake8-todos",
    "summary": "Missing issue link on the line following this TODO",
    "message_formats": [
      "Missing issue link on the line following this TODO"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that a TODO comment is associated with a link to a relevant issue\nor ticket.\n\n## Why is this bad?\nIncluding an issue link near a TODO makes it easier for resolvers\nto get context around the issue.\n\n## Example\n```python\n# TODO: this link has no issue\n```\n\nUse one of these instead:\n```python\n# TODO(charlie): this comment has an issue link\n# https://github.com/astral-sh/ruff/issues/3870\n\n# TODO(charlie): this comment has a 3-digit issue code\n# 003\n\n# TODO(charlie): this comment has an issue code of (up to) 6 characters, then digits\n# SIXCHR-003\n```\n"
  },
  {
    "name": "missing-todo-colon",
    "code": "TD004",
    "linter": "flake8-todos",
    "summary": "Missing colon in TODO",
    "message_formats": [
      "Missing colon in TODO"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that a \"TODO\" tag is followed by a colon.\n\n## Why is this bad?\n\"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.\n\n## Example\n```python\n# TODO(charlie) fix this colon\n```\n\nUsed instead:\n```python\n# TODO(charlie): colon fixed\n```\n"
  },
  {
    "name": "missing-todo-description",
    "code": "TD005",
    "linter": "flake8-todos",
    "summary": "Missing issue description after `TODO`",
    "message_formats": [
      "Missing issue description after `TODO`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that a \"TODO\" tag contains a description of the issue following the\ntag itself.\n\n## Why is this bad?\nTODO comments should include a description of the issue to provide context\nfor future readers.\n\n## Example\n```python\n# TODO(charlie)\n```\n\nUse instead:\n```python\n# TODO(charlie): fix some issue\n```\n"
  },
  {
    "name": "invalid-todo-capitalization",
    "code": "TD006",
    "linter": "flake8-todos",
    "summary": "Invalid TODO capitalization: `{tag}` should be `TODO`",
    "message_formats": [
      "Invalid TODO capitalization: `{tag}` should be `TODO`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks that a \"TODO\" tag is properly capitalized (i.e., that the tag is\nuppercase).\n\n## Why is this bad?\nCapitalizing the \"TODO\" in a TODO comment is a convention that makes it\neasier for future readers to identify TODOs.\n\n## Example\n```python\n# todo(charlie): capitalize this\n```\n\nUse instead:\n```python\n# TODO(charlie): this is capitalized\n```\n"
  },
  {
    "name": "missing-space-after-todo-colon",
    "code": "TD007",
    "linter": "flake8-todos",
    "summary": "Missing space after colon in TODO",
    "message_formats": [
      "Missing space after colon in TODO"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks that the colon after a \"TODO\" tag is followed by a space.\n\n## Why is this bad?\n\"TODO\" tags are typically followed by a parenthesized author name, a colon,\na space, and a description of the issue, in that order.\n\nDeviating from this pattern can lead to inconsistent and non-idiomatic\ncomments.\n\n## Example\n```python\n# TODO(charlie):fix this\n```\n\nUse instead:\n```python\n# TODO(charlie): fix this\n```\n"
  },
  {
    "name": "typing-only-first-party-import",
    "code": "TCH001",
    "linter": "flake8-type-checking",
    "summary": "Move application import `{}` into a type-checking block",
    "message_formats": [
      "Move application import `{}` into a type-checking block"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for first-party imports that are only used for type annotations, but\naren't defined in a type-checking block.\n\n## Why is this bad?\nUnused imports add a performance overhead at runtime, and risk creating\nimport cycles.\n\n## Example\n```python\nfrom __future__ import annotations\n\nimport A\n\n\ndef foo(a: A) -> int:\n    return len(a)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import A\n\n\ndef foo(a: A) -> int:\n    return len(a)\n```\n\n## References\n- [PEP 536](https://peps.python.org/pep-0563/#runtime-annotation-resolution-and-type-checking)\n"
  },
  {
    "name": "typing-only-third-party-import",
    "code": "TCH002",
    "linter": "flake8-type-checking",
    "summary": "Move third-party import `{}` into a type-checking block",
    "message_formats": [
      "Move third-party import `{}` into a type-checking block"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for third-party imports that are only used for type annotations, but\naren't defined in a type-checking block.\n\n## Why is this bad?\nUnused imports add a performance overhead at runtime, and risk creating\nimport cycles.\n\n## Example\n```python\nfrom __future__ import annotations\n\nimport pandas as pd\n\n\ndef foo(df: pd.DataFrame) -> int:\n    return len(df)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import pandas as pd\n\n\ndef foo(df: pd.DataFrame) -> int:\n    return len(df)\n```\n\n## References\n- [PEP 536](https://peps.python.org/pep-0563/#runtime-annotation-resolution-and-type-checking)\n"
  },
  {
    "name": "typing-only-standard-library-import",
    "code": "TCH003",
    "linter": "flake8-type-checking",
    "summary": "Move standard library import `{}` into a type-checking block",
    "message_formats": [
      "Move standard library import `{}` into a type-checking block"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for standard library imports that are only used for type\nannotations, but aren't defined in a type-checking block.\n\n## Why is this bad?\nUnused imports add a performance overhead at runtime, and risk creating\nimport cycles.\n\n## Example\n```python\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\n\ndef foo(path: Path) -> str:\n    return str(path)\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from pathlib import Path\n\n\ndef foo(path: Path) -> str:\n    return str(path)\n```\n\n## References\n- [PEP 536](https://peps.python.org/pep-0563/#runtime-annotation-resolution-and-type-checking)\n"
  },
  {
    "name": "runtime-import-in-type-checking-block",
    "code": "TCH004",
    "linter": "flake8-type-checking",
    "summary": "Move import `{qualified_name}` out of type-checking block. Import is used for more than type hinting.",
    "message_formats": [
      "Move import `{qualified_name}` out of type-checking block. Import is used for more than type hinting."
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for runtime imports defined in a type-checking block.\n\n## Why is this bad?\nThe type-checking block is not executed at runtime, so the import will not\nbe available at runtime.\n\n## Example\n```python\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import foo\n\n\ndef bar() -> None:\n    foo.bar()  # raises NameError: name 'foo' is not defined\n```\n\nUse instead:\n```python\nimport foo\n\n\ndef bar() -> None:\n    foo.bar()\n```\n\n## References\n- [PEP 535](https://peps.python.org/pep-0563/#runtime-annotation-resolution-and-type-checking)\n"
  },
  {
    "name": "empty-type-checking-block",
    "code": "TCH005",
    "linter": "flake8-type-checking",
    "summary": "Found empty type-checking block",
    "message_formats": [
      "Found empty type-checking block"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for an empty type-checking block.\n\n## Why is this bad?\nThe type-checking block does not do anything and should be removed to avoid\nconfusion.\n\n## Example\n```python\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    pass\n\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```\n\n## References\n- [PEP 535](https://peps.python.org/pep-0563/#runtime-annotation-resolution-and-type-checking)\n"
  },
  {
    "name": "unused-function-argument",
    "code": "ARG001",
    "linter": "flake8-unused-arguments",
    "summary": "Unused function argument: `{name}`",
    "message_formats": [
      "Unused function argument: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of unused arguments in function definitions.\n\n## Why is this bad?\nAn argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n## Example\n```python\ndef foo(bar, baz):\n    return bar * 2\n```\n\nUse instead:\n```python\ndef foo(bar):\n    return bar * 2\n```\n"
  },
  {
    "name": "unused-method-argument",
    "code": "ARG002",
    "linter": "flake8-unused-arguments",
    "summary": "Unused method argument: `{name}`",
    "message_formats": [
      "Unused method argument: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of unused arguments in instance method definitions.\n\n## Why is this bad?\nAn argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n## Example\n```python\nclass Class:\n    def foo(self, arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    def foo(self, arg1):\n        print(arg1)\n```\n"
  },
  {
    "name": "unused-class-method-argument",
    "code": "ARG003",
    "linter": "flake8-unused-arguments",
    "summary": "Unused class method argument: `{name}`",
    "message_formats": [
      "Unused class method argument: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of unused arguments in class method definitions.\n\n## Why is this bad?\nAn argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n## Example\n```python\nclass Class:\n    @classmethod\n    def foo(cls, arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    @classmethod\n    def foo(cls, arg1):\n        print(arg1)\n```\n"
  },
  {
    "name": "unused-static-method-argument",
    "code": "ARG004",
    "linter": "flake8-unused-arguments",
    "summary": "Unused static method argument: `{name}`",
    "message_formats": [
      "Unused static method argument: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of unused arguments in static method definitions.\n\n## Why is this bad?\nAn argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n## Example\n```python\nclass Class:\n    @staticmethod\n    def foo(arg1, arg2):\n        print(arg1)\n```\n\nUse instead:\n```python\nclass Class:\n    @static\n    def foo(arg1):\n        print(arg1)\n```\n"
  },
  {
    "name": "unused-lambda-argument",
    "code": "ARG005",
    "linter": "flake8-unused-arguments",
    "summary": "Unused lambda argument: `{name}`",
    "message_formats": [
      "Unused lambda argument: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the presence of unused arguments in lambda expression\ndefinitions.\n\n## Why is this bad?\nAn argument that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\n## Example\n```python\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x, y: x**2, my_list)\n```\n\nUse instead:\n```python\nmy_list = [1, 2, 3, 4, 5]\nsquares = map(lambda x: x**2, my_list)\n```\n"
  },
  {
    "name": "os-path-abspath",
    "code": "PTH100",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.abspath()` should be replaced by `Path.resolve()`",
    "message_formats": [
      "`os.path.abspath()` should be replaced by `Path.resolve()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-chmod",
    "code": "PTH101",
    "linter": "flake8-use-pathlib",
    "summary": "`os.chmod()` should be replaced by `Path.chmod()`",
    "message_formats": [
      "`os.chmod()` should be replaced by `Path.chmod()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-mkdir",
    "code": "PTH102",
    "linter": "flake8-use-pathlib",
    "summary": "`os.mkdir()` should be replaced by `Path.mkdir()`",
    "message_formats": [
      "`os.mkdir()` should be replaced by `Path.mkdir()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-makedirs",
    "code": "PTH103",
    "linter": "flake8-use-pathlib",
    "summary": "`os.makedirs()` should be replaced by `Path.mkdir(parents=True)`",
    "message_formats": [
      "`os.makedirs()` should be replaced by `Path.mkdir(parents=True)`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-rename",
    "code": "PTH104",
    "linter": "flake8-use-pathlib",
    "summary": "`os.rename()` should be replaced by `Path.rename()`",
    "message_formats": [
      "`os.rename()` should be replaced by `Path.rename()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-replace",
    "code": "PTH105",
    "linter": "flake8-use-pathlib",
    "summary": "`os.replace()` should be replaced by `Path.replace()`",
    "message_formats": [
      "`os.replace()` should be replaced by `Path.replace()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-rmdir",
    "code": "PTH106",
    "linter": "flake8-use-pathlib",
    "summary": "`os.rmdir()` should be replaced by `Path.rmdir()`",
    "message_formats": [
      "`os.rmdir()` should be replaced by `Path.rmdir()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-remove",
    "code": "PTH107",
    "linter": "flake8-use-pathlib",
    "summary": "`os.remove()` should be replaced by `Path.unlink()`",
    "message_formats": [
      "`os.remove()` should be replaced by `Path.unlink()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-unlink",
    "code": "PTH108",
    "linter": "flake8-use-pathlib",
    "summary": "`os.unlink()` should be replaced by `Path.unlink()`",
    "message_formats": [
      "`os.unlink()` should be replaced by `Path.unlink()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-getcwd",
    "code": "PTH109",
    "linter": "flake8-use-pathlib",
    "summary": "`os.getcwd()` should be replaced by `Path.cwd()`",
    "message_formats": [
      "`os.getcwd()` should be replaced by `Path.cwd()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-exists",
    "code": "PTH110",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.exists()` should be replaced by `Path.exists()`",
    "message_formats": [
      "`os.path.exists()` should be replaced by `Path.exists()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-expanduser",
    "code": "PTH111",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.expanduser()` should be replaced by `Path.expanduser()`",
    "message_formats": [
      "`os.path.expanduser()` should be replaced by `Path.expanduser()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-isdir",
    "code": "PTH112",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.isdir()` should be replaced by `Path.is_dir()`",
    "message_formats": [
      "`os.path.isdir()` should be replaced by `Path.is_dir()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-isfile",
    "code": "PTH113",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.isfile()` should be replaced by `Path.is_file()`",
    "message_formats": [
      "`os.path.isfile()` should be replaced by `Path.is_file()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-islink",
    "code": "PTH114",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.islink()` should be replaced by `Path.is_symlink()`",
    "message_formats": [
      "`os.path.islink()` should be replaced by `Path.is_symlink()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-readlink",
    "code": "PTH115",
    "linter": "flake8-use-pathlib",
    "summary": "`os.readlink()` should be replaced by `Path.readlink()`",
    "message_formats": [
      "`os.readlink()` should be replaced by `Path.readlink()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-stat",
    "code": "PTH116",
    "linter": "flake8-use-pathlib",
    "summary": "`os.stat()` should be replaced by `Path.stat()`, `Path.owner()`, or `Path.group()`",
    "message_formats": [
      "`os.stat()` should be replaced by `Path.stat()`, `Path.owner()`, or `Path.group()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-isabs",
    "code": "PTH117",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.isabs()` should be replaced by `Path.is_absolute()`",
    "message_formats": [
      "`os.path.isabs()` should be replaced by `Path.is_absolute()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-join",
    "code": "PTH118",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.join()` should be replaced by `Path` with `/` operator",
    "message_formats": [
      "`os.path.join()` should be replaced by `Path` with `/` operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-basename",
    "code": "PTH119",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.basename()` should be replaced by `Path.name`",
    "message_formats": [
      "`os.path.basename()` should be replaced by `Path.name`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-dirname",
    "code": "PTH120",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.dirname()` should be replaced by `Path.parent`",
    "message_formats": [
      "`os.path.dirname()` should be replaced by `Path.parent`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-samefile",
    "code": "PTH121",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.samefile()` should be replaced by `Path.samefile()`",
    "message_formats": [
      "`os.path.samefile()` should be replaced by `Path.samefile()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "os-path-splitext",
    "code": "PTH122",
    "linter": "flake8-use-pathlib",
    "summary": "`os.path.splitext()` should be replaced by `Path.suffix`",
    "message_formats": [
      "`os.path.splitext()` should be replaced by `Path.suffix`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "builtin-open",
    "code": "PTH123",
    "linter": "flake8-use-pathlib",
    "summary": "`open()` should be replaced by `Path.open()`",
    "message_formats": [
      "`open()` should be replaced by `Path.open()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "py-path",
    "code": "PTH124",
    "linter": "flake8-use-pathlib",
    "summary": "`py.path` is in maintenance mode, use `pathlib` instead",
    "message_formats": [
      "`py.path` is in maintenance mode, use `pathlib` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "static-join-to-f-string",
    "code": "FLY002",
    "linter": "flynt",
    "summary": "Consider `{expr}` instead of string join",
    "message_formats": [
      "Consider `{expr}` instead of string join"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "unsorted-imports",
    "code": "I001",
    "linter": "isort",
    "summary": "Import block is un-sorted or un-formatted",
    "message_formats": [
      "Import block is un-sorted or un-formatted"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nDe-duplicates, groups, and sorts imports based on the provided `isort` settings.\n\n## Why is this bad?\nConsistency is good. Use a common convention for imports to make your code\nmore readable and idiomatic.\n\n## Example\n```python\nimport pandas\nimport numpy as np\n```\n\nUse instead:\n```python\nimport numpy as np\nimport pandas\n```\n"
  },
  {
    "name": "missing-required-import",
    "code": "I002",
    "linter": "isort",
    "summary": "Missing required import: `{name}`",
    "message_formats": [
      "Missing required import: `{name}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nAdds any required imports, as specified by the user, to the top of the\nfile.\n\n## Why is this bad?\nIn some projects, certain imports are required to be present in all\nfiles. For example, some projects assume that\n`from __future__ import annotations` is enabled,\nand thus require that import to be\npresent in all files. Omitting a \"required\" import (as specified by\nthe user) can cause errors or unexpected behavior.\n\n## Example\n```python\nimport typing\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nimport typing\n```\n"
  },
  {
    "name": "complex-structure",
    "code": "C901",
    "linter": "mccabe",
    "summary": "`{name}` is too complex ({complexity} > {max_complexity})",
    "message_formats": [
      "`{name}` is too complex ({complexity} > {max_complexity})"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions with a high `McCabe` complexity.\n\n## Why is this bad?\nThe `McCabe` complexity of a function is a measure of the complexity of\nthe control flow graph of the function. It is calculated by adding\none to the number of decision points in the function. A decision\npoint is a place in the code where the program has a choice of two\nor more paths to follow.\n\nFunctions with a high complexity are hard to understand and maintain.\n\n## Example\n```python\ndef foo(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n            else:\n                return 2\n        else:\n            return 3\n    else:\n        return 4\n```\n\nUse instead:\n```python\ndef foo(a, b, c):\n    if not a:\n        return 4\n    if not b:\n        return 3\n    if not c:\n        return 2\n    return 1\n```\n\n## Options\n- `mccabe.max-complexity`\n"
  },
  {
    "name": "numpy-deprecated-type-alias",
    "code": "NPY001",
    "linter": "NumPy-specific rules",
    "summary": "Type alias `np.{type_name}` is deprecated, replace with builtin type",
    "message_formats": [
      "Type alias `np.{type_name}` is deprecated, replace with builtin type"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for deprecated NumPy type aliases.\n\n## Why is this bad?\nNumPy's `np.int` has long been an alias of the builtin `int`. The same\ngoes for `np.float`, `np.bool`, and others. These aliases exist\nprimarily for historic reasons, and have been a cause of\nfrequent confusion for newcomers.\n\nThese aliases were been deprecated in 1.20, and removed in 1.24.\n\n## Examples\n```python\nimport numpy as np\n\nnp.bool\n```\n\nUse instead:\n```python\nbool\n```\n"
  },
  {
    "name": "numpy-legacy-random",
    "code": "NPY002",
    "linter": "NumPy-specific rules",
    "summary": "Replace legacy `np.random.{method_name}` call with `np.random.Generator`",
    "message_formats": [
      "Replace legacy `np.random.{method_name}` call with `np.random.Generator`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of legacy `np.random` function calls.\n\n## Why is this bad?\nAccording to the NumPy documentation's [Legacy Random Generation]:\n\n> The `RandomState` provides access to legacy generators... This class\n> should only be used if it is essential to have randoms that are\n> identical to what would have been produced by previous versions of\n> NumPy.\n\nThe members exposed directly on the `random` module are convenience\nfunctions that alias to methods on a global singleton `RandomState`\ninstance. NumPy recommends using a dedicated `Generator` instance\nrather than the random variate generation methods exposed directly on\nthe `random` module, as the new `Generator` is both faster and has\nbetter statistical properties.\n\nSee the documentation on [Random Sampling] and [NEP 19] for further\ndetails.\n\n## Examples\n```python\nimport numpy as np\n\nnp.random.seed(1337)\nnp.random.normal()\n```\n\nUse instead:\n```python\nrng = np.random.default_rng(1337)\nrng.normal()\n```\n\n[Legacy Random Generation]: https://numpy.org/doc/stable/reference/random/legacy.html#legacy\n[Random Sampling]: https://numpy.org/doc/stable/reference/random/index.html#random-quick-start\n[NEP 19]: https://numpy.org/neps/nep-0019-rng-policy.html\n"
  },
  {
    "name": "invalid-class-name",
    "code": "N801",
    "linter": "pep8-naming",
    "summary": "Class name `{name}` should use CapWords convention ",
    "message_formats": [
      "Class name `{name}` should use CapWords convention "
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for class names that do not follow the `CamelCase` convention.\n\n## Why is this bad?\n[PEP 8] recommends the use of the `CapWords` (or `CamelCase`) convention\nfor class names:\n\n> Class names should normally use the `CapWords` convention.\n>\n> The naming convention for functions may be used instead in cases where the interface is\n> documented and used primarily as a callable.\n>\n> Note that there is a separate convention for builtin names: most builtin names are single\n> words (or two words run together), with the `CapWords` convention used only for exception\n> names and builtin constants.\n\n## Example\n```python\nclass my_class:\n    pass\n```\n\nUse instead:\n```python\nclass MyClass:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#class-names\n"
  },
  {
    "name": "invalid-function-name",
    "code": "N802",
    "linter": "pep8-naming",
    "summary": "Function name `{name}` should be lowercase",
    "message_formats": [
      "Function name `{name}` should be lowercase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions names that do not follow the `snake_case` naming\nconvention.\n\n## Why is this bad?\n[PEP 8] recommends that function names follow `snake_case`:\n\n> Function names should be lowercase, with words separated by underscores as necessary to\n> improve readability. mixedCase is allowed only in contexts where thats already the\n> prevailing style (e.g. threading.py), to retain backwards compatibility.\n\n## Example\n```python\ndef myFunction():\n    pass\n```\n\nUse instead:\n```python\ndef my_function():\n    pass\n```\n\n## Options\n- `pep8-naming.ignore-names`\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-variable-names\n"
  },
  {
    "name": "invalid-argument-name",
    "code": "N803",
    "linter": "pep8-naming",
    "summary": "Argument name `{name}` should be lowercase",
    "message_formats": [
      "Argument name `{name}` should be lowercase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for argument names that do not follow the `snake_case` convention.\n\n## Why is this bad?\n[PEP 8] recommends that function names should be lower case and separated\nby underscores (also known as `snake_case`).\n\n> Function names should be lowercase, with words separated by underscores\nas necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n## Example\n```python\ndef MY_FUNCTION():\n    pass\n```\n\nUse instead:\n```python\ndef my_function():\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-method-arguments\n"
  },
  {
    "name": "invalid-first-argument-name-for-class-method",
    "code": "N804",
    "linter": "pep8-naming",
    "summary": "First argument of a class method should be named `cls`",
    "message_formats": [
      "First argument of a class method should be named `cls`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for class methods that use a name other than `cls` for their\nfirst argument.\n\n## Why is this bad?\n[PEP 8] recommends the use of `cls` as the first argument for all class\nmethods:\n\n> Always use `cls` for the first argument to class methods.\n>\n> If a function arguments name clashes with a reserved keyword, it is generally better to\n> append a single trailing underscore rather than use an abbreviation or spelling corruption.\n> Thus `class_` is better than `clss`. (Perhaps better is to avoid such clashes by using a synonym.)\n\n## Example\n```python\nclass Example:\n    @classmethod\n    def function(self, data):\n        ...\n```\n\nUse instead:\n```python\nclass Example:\n    @classmethod\n    def function(cls, data):\n        ...\n```\n\n## Options\n- `pep8-naming.classmethod-decorators`\n- `pep8-naming.staticmethod-decorators`\n- `pep8-naming.ignore-names`\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-method-arguments\n"
  },
  {
    "name": "invalid-first-argument-name-for-method",
    "code": "N805",
    "linter": "pep8-naming",
    "summary": "First argument of a method should be named `self`",
    "message_formats": [
      "First argument of a method should be named `self`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for instance methods that use a name other than `self` for their\nfirst argument.\n\n## Why is this bad?\n[PEP 8] recommends the use of `self` as first argument for all instance\nmethods:\n\n> Always use self for the first argument to instance methods.\n>\n> If a function arguments name clashes with a reserved keyword, it is generally better to\n> append a single trailing underscore rather than use an abbreviation or spelling corruption.\n> Thus `class_` is better than `clss`. (Perhaps better is to avoid such clashes by using a synonym.)\n\n## Example\n```python\nclass Example:\n    def function(cls, data):\n        ...\n```\n\nUse instead:\n```python\nclass Example:\n    def function(self, data):\n        ...\n```\n\n## Options\n- `pep8-naming.classmethod-decorators`\n- `pep8-naming.staticmethod-decorators`\n- `pep8-naming.ignore-names`\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-method-arguments\n"
  },
  {
    "name": "non-lowercase-variable-in-function",
    "code": "N806",
    "linter": "pep8-naming",
    "summary": "Variable `{name}` in function should be lowercase",
    "message_formats": [
      "Variable `{name}` in function should be lowercase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of non-lowercase variable names in functions.\n\n## Why is this bad?\n[PEP 8] recommends that all function variables use lowercase names:\n\n> Function names should be lowercase, with words separated by underscores as necessary to\n> improve readability. Variable names follow the same convention as function names. mixedCase\n> is allowed only in contexts where that's already the prevailing style (e.g. threading.py),\n> to retain backwards compatibility.\n\n## Example\n```python\ndef my_function(a):\n    B = a + 3\n    return B\n```\n\nUse instead:\n```python\ndef my_function(a):\n    b = a + 3\n    return b\n```\n\n## Options\n- `pep8-naming.ignore-names`\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-variable-names\n"
  },
  {
    "name": "dunder-function-name",
    "code": "N807",
    "linter": "pep8-naming",
    "summary": "Function name should not start and end with `__`",
    "message_formats": [
      "Function name should not start and end with `__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions with \"dunder\" names (that is, names with two\nleading and trailing underscores) that are not documented.\n\n## Why is this bad?\n[PEP 8] recommends that only documented \"dunder\" methods are used:\n\n> ...\"magic\" objects or attributes that live in user-controlled\n> namespaces. E.g. `__init__`, `__import__` or `__file__`. Never invent\n> such names; only use them as documented.\n\n## Example\n```python\ndef __my_function__():\n    pass\n```\n\nUse instead:\n```python\ndef my_function():\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "constant-imported-as-non-constant",
    "code": "N811",
    "linter": "pep8-naming",
    "summary": "Constant `{name}` imported as non-constant `{asname}`",
    "message_formats": [
      "Constant `{name}` imported as non-constant `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for constant imports that are aliased to non-constant-style\nnames.\n\n## Why is this bad?\n[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\n## Example\n```python\nfrom example import CONSTANT_VALUE as ConstantValue\n```\n\nUse instead:\n```python\nfrom example import CONSTANT_VALUE\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "lowercase-imported-as-non-lowercase",
    "code": "N812",
    "linter": "pep8-naming",
    "summary": "Lowercase `{name}` imported as non-lowercase `{asname}`",
    "message_formats": [
      "Lowercase `{name}` imported as non-lowercase `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for lowercase imports that are aliased to non-lowercase names.\n\n## Why is this bad?\n[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\n## Example\n```python\nfrom example import myclassname as MyClassName\n```\n\nUse instead:\n```python\nfrom example import myclassname\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "camelcase-imported-as-lowercase",
    "code": "N813",
    "linter": "pep8-naming",
    "summary": "Camelcase `{name}` imported as lowercase `{asname}`",
    "message_formats": [
      "Camelcase `{name}` imported as lowercase `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `CamelCase` imports that are aliased to lowercase names.\n\n## Why is this bad?\n[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\n## Example\n```python\nfrom example import MyClassName as myclassname\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "camelcase-imported-as-constant",
    "code": "N814",
    "linter": "pep8-naming",
    "summary": "Camelcase `{name}` imported as constant `{asname}`",
    "message_formats": [
      "Camelcase `{name}` imported as constant `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `CamelCase` imports that are aliased to constant-style names.\n\n## Why is this bad?\n[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\n## Example\n```python\nfrom example import MyClassName as MY_CLASS_NAME\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "mixed-case-variable-in-class-scope",
    "code": "N815",
    "linter": "pep8-naming",
    "summary": "Variable `{name}` in class scope should not be mixedCase",
    "message_formats": [
      "Variable `{name}` in class scope should not be mixedCase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for class variable names that follow the `mixedCase` convention.\n\n## Why is this bad?\n[PEP 8] recommends that variable names should be lower case and separated\nby underscores (also known as `snake_case`).\n\n> Function names should be lowercase, with words separated by underscores\nas necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the\nprevailing style (e.g. threading.py), to retain backwards compatibility.\n\n## Example\n```python\nclass MyClass:\n    myVariable = \"hello\"\n    another_variable = \"world\"\n```\n\nUse instead:\n```python\nclass MyClass:\n    my_variable = \"hello\"\n    another_variable = \"world\"\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#function-and-method-arguments\n"
  },
  {
    "name": "mixed-case-variable-in-global-scope",
    "code": "N816",
    "linter": "pep8-naming",
    "summary": "Variable `{name}` in global scope should not be mixedCase",
    "message_formats": [
      "Variable `{name}` in global scope should not be mixedCase"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for global variable names that follow the `mixedCase` convention.\n\n## Why is this bad?\n[PEP 8] recommends that global variable names should be lower case and\nseparated by underscores (also known as `snake_case`).\n\n> ### Global Variable Names\n> (Lets hope that these variables are meant for use inside one module\nonly.) The conventions are about the same as those for functions.\n>\n> Modules that are designed for use via from M import * should use the\n__all__ mechanism to prevent exporting globals, or use the older\nconvention of prefixing such globals with an underscore (which you might\nwant to do to indicate these globals are module non-public).\n>\n> ### Function and Variable Names\n> Function names should be lowercase, with words separated by underscores\nas necessary to improve readability.\n>\n> Variable names follow the same convention as function names.\n>\n> mixedCase is allowed only in contexts where thats already the prevailing\nstyle (e.g. threading.py), to retain backwards compatibility.\n\n## Example\n```python\nmyVariable = \"hello\"\nanother_variable = \"world\"\nyet_anotherVariable = \"foo\"\n```\n\nUse instead:\n```python\nmy_variable = \"hello\"\nanother_variable = \"world\"\nyet_another_variable = \"foo\"\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#global-variable-names\n"
  },
  {
    "name": "camelcase-imported-as-acronym",
    "code": "N817",
    "linter": "pep8-naming",
    "summary": "CamelCase `{name}` imported as acronym `{asname}`",
    "message_formats": [
      "CamelCase `{name}` imported as acronym `{asname}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `CamelCase` imports that are aliased as acronyms.\n\n## Why is this bad?\n[PEP 8] recommends naming conventions for classes, functions,\nconstants, and more. The use of inconsistent naming styles between\nimport and alias names may lead readers to expect an import to be of\nanother type (e.g., confuse a Python class with a constant).\n\nImport aliases should thus follow the same naming style as the member\nbeing imported.\n\nNote that this rule is distinct from `camelcase-imported-as-constant`\nto accommodate selective enforcement.\n\n## Example\n```python\nfrom example import MyClassName as MCN\n```\n\nUse instead:\n```python\nfrom example import MyClassName\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/\n"
  },
  {
    "name": "error-suffix-on-exception-name",
    "code": "N818",
    "linter": "pep8-naming",
    "summary": "Exception name `{name}` should be named with an Error suffix",
    "message_formats": [
      "Exception name `{name}` should be named with an Error suffix"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for custom exception definitions that omit the `Error` suffix.\n\n## Why is this bad?\nThe `Error` suffix is recommended by [PEP 8]:\n\n> Because exceptions should be classes, the class naming convention\n> applies here. However, you should use the suffix `\"Error\"` on your\n> exception names (if the exception actually is an error).\n\n## Example\n```python\nclass Validation(Exception):\n    ...\n```\n\nUse instead:\n```python\nclass ValidationError(Exception):\n    ...\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#exception-names\n"
  },
  {
    "name": "invalid-module-name",
    "code": "N999",
    "linter": "pep8-naming",
    "summary": "Invalid module name: '{name}'",
    "message_formats": [
      "Invalid module name: '{name}'"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for module names that do not follow the `snake_case` naming\nconvention or are otherwise invalid.\n\n## Why is this bad?\n[PEP 8] recommends the use of the `snake_case` naming convention for\nmodule names:\n\n> Modules should have short, all-lowercase names. Underscores can be used in the\n> module name if it improves readability. Python packages should also have short,\n> all-lowercase names, although the use of underscores is discouraged.\n>\n> When an extension module written in C or C++ has an accompanying Python module that\n> provides a higher level (e.g. more object oriented) interface, the C/C++ module has\n> a leading underscore (e.g. `_socket`).\n\nFurther, in order for Python modules to be importable, they must be valid\nidentifiers. As such, they cannot start with a digit, or collide with hard\nkeywords, like `import` or `class`.\n\n## Example\n- Instead of `example-module-name` or `example module name`, use `example_module_name`.\n- Instead of `ExampleModule`, use `example_module`.\n\n[PEP 8]: https://peps.python.org/pep-0008/#package-and-module-names\n"
  },
  {
    "name": "pandas-use-of-inplace-argument",
    "code": "PD002",
    "linter": "pandas-vet",
    "summary": "`inplace=True` should be avoided; it has inconsistent behavior",
    "message_formats": [
      "`inplace=True` should be avoided; it has inconsistent behavior"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `inplace=True` usages in `pandas` function and method\ncalls.\n\n## Why is this bad?\nUsing `inplace=True` encourages mutation rather than immutable data,\nwhich is harder to reason about and may cause bugs. It also removes the\nability to use the method chaining style for `pandas` operations.\n\nFurther, in many cases, `inplace=True` does not provide a performance\nbenefit, as `pandas` will often copy `DataFrames` in the background.\n\n## Example\n```python\ndf.sort_values(\"col1\", inplace=True)\n```\n\nUse instead:\n```python\nsorted_df = df.sort_values(\"col1\")\n```\n\n## References\n- [_Why You Should Probably Never Use pandas inplace=True_](https://towardsdatascience.com/why-you-should-probably-never-use-pandas-inplace-true-9f9f211849e4)\n"
  },
  {
    "name": "pandas-use-of-dot-is-null",
    "code": "PD003",
    "linter": "pandas-vet",
    "summary": "`.isna` is preferred to `.isnull`; functionality is equivalent",
    "message_formats": [
      "`.isna` is preferred to `.isnull`; functionality is equivalent"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-not-null",
    "code": "PD004",
    "linter": "pandas-vet",
    "summary": "`.notna` is preferred to `.notnull`; functionality is equivalent",
    "message_formats": [
      "`.notna` is preferred to `.notnull`; functionality is equivalent"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-ix",
    "code": "PD007",
    "linter": "pandas-vet",
    "summary": "`.ix` is deprecated; use more explicit `.loc` or `.iloc`",
    "message_formats": [
      "`.ix` is deprecated; use more explicit `.loc` or `.iloc`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-at",
    "code": "PD008",
    "linter": "pandas-vet",
    "summary": "Use `.loc` instead of `.at`. If speed is important, use NumPy.",
    "message_formats": [
      "Use `.loc` instead of `.at`. If speed is important, use NumPy."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-iat",
    "code": "PD009",
    "linter": "pandas-vet",
    "summary": "Use `.iloc` instead of `.iat`. If speed is important, use NumPy.",
    "message_formats": [
      "Use `.iloc` instead of `.iat`. If speed is important, use NumPy."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-pivot-or-unstack",
    "code": "PD010",
    "linter": "pandas-vet",
    "summary": "`.pivot_table` is preferred to `.pivot` or `.unstack`; provides same functionality",
    "message_formats": [
      "`.pivot_table` is preferred to `.pivot` or `.unstack`; provides same functionality"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-values",
    "code": "PD011",
    "linter": "pandas-vet",
    "summary": "Use `.to_numpy()` instead of `.values`",
    "message_formats": [
      "Use `.to_numpy()` instead of `.values`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-read-table",
    "code": "PD012",
    "linter": "pandas-vet",
    "summary": "`.read_csv` is preferred to `.read_table`; provides same functionality",
    "message_formats": [
      "`.read_csv` is preferred to `.read_table`; provides same functionality"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-dot-stack",
    "code": "PD013",
    "linter": "pandas-vet",
    "summary": "`.melt` is preferred to `.stack`; provides same functionality",
    "message_formats": [
      "`.melt` is preferred to `.stack`; provides same functionality"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-use-of-pd-merge",
    "code": "PD015",
    "linter": "pandas-vet",
    "summary": "Use `.merge` method instead of `pd.merge` function. They have equivalent functionality.",
    "message_formats": [
      "Use `.merge` method instead of `pd.merge` function. They have equivalent functionality."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "pandas-df-variable-name",
    "code": "PD901",
    "linter": "pandas-vet",
    "summary": "`df` is a bad variable name. Be kinder to your future self.",
    "message_formats": [
      "`df` is a bad variable name. Be kinder to your future self."
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "unnecessary-list-cast",
    "code": "PERF101",
    "linter": "Perflint",
    "summary": "Do not cast an iterable to `list` before iterating over it",
    "message_formats": [
      "Do not cast an iterable to `list` before iterating over it"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for explicit casts to `list` on for-loop iterables.\n\n## Why is this bad?\nUsing a `list()` call to eagerly iterate over an already-iterable type\n(like a tuple, list, or set) is inefficient, as it forces Python to create\na new list unnecessarily.\n\nRemoving the `list()` call will not change the behavior of the code, but\nmay improve performance.\n\n## Example\n```python\nitems = (1, 2, 3)\nfor i in list(items):\n    print(i)\n```\n\nUse instead:\n```python\nitems = (1, 2, 3)\nfor i in items:\n    print(i)\n```\n"
  },
  {
    "name": "incorrect-dict-iterator",
    "code": "PERF102",
    "linter": "Perflint",
    "summary": "When using only the {subset} of a dict use the `{subset}()` method",
    "message_formats": [
      "When using only the {subset} of a dict use the `{subset}()` method"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `dict.items()` that discard either the key or the value\nwhen iterating over the dictionary.\n\n## Why is this bad?\nIf you only need the keys or values of a dictionary, you should use\n`dict.keys()` or `dict.values()` respectively, instead of `dict.items()`.\nThese specialized methods are more efficient than `dict.items()`, as they\navoid allocating tuples for every item in the dictionary. They also\ncommunicate the intent of the code more clearly.\n\n## Example\n```python\nsome_dict = {\"a\": 1, \"b\": 2}\nfor _, val in some_dict.items():\n    print(val)\n```\n\nUse instead:\n```python\nsome_dict = {\"a\": 1, \"b\": 2}\nfor val in some_dict.values():\n    print(val)\n```\n"
  },
  {
    "name": "try-except-in-loop",
    "code": "PERF203",
    "linter": "Perflint",
    "summary": "`try`-`except` within a loop incurs performance overhead",
    "message_formats": [
      "`try`-`except` within a loop incurs performance overhead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of except handling via `try`-`except` within `for` and\n`while` loops.\n\n## Why is this bad?\nException handling via `try`-`except` blocks incurs some performance\noverhead, regardless of whether an exception is raised.\n\nWhen possible, refactor your code to put the entire loop into the\n`try`-`except` block, rather than wrapping each iteration in a separate\n`try`-`except` block.\n\nThis rule is only enforced for Python versions prior to 3.11, which\nintroduced \"zero cost\" exception handling.\n\nNote that, as with all `perflint` rules, this is only intended as a\nmicro-optimization, and will have a negligible impact on performance in\nmost cases.\n\n## Example\n```python\nfor i in range(10):\n    try:\n        print(i * i)\n    except:\n        break\n```\n\nUse instead:\n```python\ntry:\n    for i in range(10):\n        print(i * i)\nexcept:\n    break\n```\n\n## Options\n- `target-version`\n"
  },
  {
    "name": "mixed-spaces-and-tabs",
    "code": "E101",
    "linter": "pycodestyle",
    "summary": "Indentation contains mixed spaces and tabs",
    "message_formats": [
      "Indentation contains mixed spaces and tabs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for mixed tabs and spaces in indentation.\n\n## Why is this bad?\nNever mix tabs and spaces.\n\nThe most popular way of indenting Python is with spaces only. The\nsecond-most popular way is with tabs only. Code indented with a\nmixture of tabs and spaces should be converted to using spaces\nexclusively.\n\n## Example\n```python\nif a == 0:\\n        a = 1\\n\\tb = 1\n```\n\nUse instead:\n```python\nif a == 0:\\n    a = 1\\n    b = 1\n```\n"
  },
  {
    "name": "indentation-with-invalid-multiple",
    "code": "E111",
    "linter": "pycodestyle",
    "summary": "Indentation is not a multiple of {indent_size}",
    "message_formats": [
      "Indentation is not a multiple of {indent_size}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for indentation with a non-multiple of 4 spaces.\n\n## Why is this bad?\nAccording to [PEP 8], 4 spaces per indentation level should be preferred.\n\n## Example\n```python\nif True:\n   a = 1\n```\n\nUse instead:\n```python\nif True:\n    a = 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "no-indented-block",
    "code": "E112",
    "linter": "pycodestyle",
    "summary": "Expected an indented block",
    "message_formats": [
      "Expected an indented block"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for indented blocks that are lacking indentation.\n\n## Why is this bad?\nAll indented blocks should be indented; otherwise, they are not valid\nPython syntax.\n\n## Example\n```python\nfor item in items:\npass\n```\n\nUse instead:\n```python\nfor item in items:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "unexpected-indentation",
    "code": "E113",
    "linter": "pycodestyle",
    "summary": "Unexpected indentation",
    "message_formats": [
      "Unexpected indentation"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unexpected indentation.\n\n## Why is this bad?\nIndentation outside of a code block is not valid Python syntax.\n\n## Example\n```python\na = 1\n    b = 2\n```\n\nUse instead:\n```python\na = 1\nb = 2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "indentation-with-invalid-multiple-comment",
    "code": "E114",
    "linter": "pycodestyle",
    "summary": "Indentation is not a multiple of {indent_size} (comment)",
    "message_formats": [
      "Indentation is not a multiple of {indent_size} (comment)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for indentation of comments with a non-multiple of 4 spaces.\n\n## Why is this bad?\nAccording to [PEP 8], 4 spaces per indentation level should be preferred.\n\n## Example\n```python\nif True:\n   # a = 1\n```\n\nUse instead:\n```python\nif True:\n    # a = 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "no-indented-block-comment",
    "code": "E115",
    "linter": "pycodestyle",
    "summary": "Expected an indented block (comment)",
    "message_formats": [
      "Expected an indented block (comment)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comments in a code blocks that are lacking indentation.\n\n## Why is this bad?\nComments within an indented block should themselves be indented, to\nindicate that they are part of the block.\n\n## Example\n```python\nfor item in items:\n# Hi\n    pass\n```\n\nUse instead:\n```python\nfor item in items:\n    # Hi\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "unexpected-indentation-comment",
    "code": "E116",
    "linter": "pycodestyle",
    "summary": "Unexpected indentation (comment)",
    "message_formats": [
      "Unexpected indentation (comment)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unexpected indentation of comment.\n\n## Why is this bad?\nComments should match the indentation of the containing code block.\n\n## Example\n```python\na = 1\n    # b = 2\n```\n\nUse instead:\n```python\na = 1\n# b = 2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "over-indented",
    "code": "E117",
    "linter": "pycodestyle",
    "summary": "Over-indented (comment)",
    "message_formats": [
      "Over-indented (comment)",
      "Over-indented"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for over-indented code.\n\n## Why is this bad?\nAccording to [PEP 8], 4 spaces per indentation level should be preferred. Increased\nindentation can lead to inconsistent formatting, which can hurt\nreadability.\n\n## Example\n```python\nfor item in items:\n      pass\n```\n\nUse instead:\n```python\nfor item in items:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#indentation\n"
  },
  {
    "name": "whitespace-after-open-bracket",
    "code": "E201",
    "linter": "pycodestyle",
    "summary": "Whitespace after '{symbol}'",
    "message_formats": [
      "Whitespace after '{symbol}'"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the use of extraneous whitespace after \"(\".\n\n## Why is this bad?\n[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"\n\n## Example\n```python\nspam( ham[1], {eggs: 2})\nspam(ham[ 1], {eggs: 2})\nspam(ham[1], { eggs: 2})\n```\n\nUse instead:\n```python\nspam(ham[1], {eggs: 2})\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves\n"
  },
  {
    "name": "whitespace-before-close-bracket",
    "code": "E202",
    "linter": "pycodestyle",
    "summary": "Whitespace before '{symbol}'",
    "message_formats": [
      "Whitespace before '{symbol}'"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the use of extraneous whitespace before \")\".\n\n## Why is this bad?\n[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"\n\n## Example\n```python\nspam(ham[1], {eggs: 2} )\nspam(ham[1 ], {eggs: 2})\nspam(ham[1], {eggs: 2 })\n```\n\nUse instead:\n```python\nspam(ham[1], {eggs: 2})\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves\n"
  },
  {
    "name": "whitespace-before-punctuation",
    "code": "E203",
    "linter": "pycodestyle",
    "summary": "Whitespace before '{symbol}'",
    "message_formats": [
      "Whitespace before '{symbol}'"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the use of extraneous whitespace before \",\", \";\" or \":\".\n\n## Why is this bad?\n[PEP 8] recommends the omission of whitespace in the following cases:\n- \"Immediately inside parentheses, brackets or braces.\"\n- \"Immediately before a comma, semicolon, or colon.\"\n\n## Example\n```python\nif x == 4: print(x, y); x, y = y , x\n```\n\nUse instead:\n```python\nif x == 4: print(x, y); x, y = y, x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#pet-peeves\n"
  },
  {
    "name": "whitespace-before-parameters",
    "code": "E211",
    "linter": "pycodestyle",
    "summary": "Whitespace before '{bracket}'",
    "message_formats": [
      "Whitespace before '{bracket}'"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "multiple-spaces-before-operator",
    "code": "E221",
    "linter": "pycodestyle",
    "summary": "Multiple spaces before operator",
    "message_formats": [
      "Multiple spaces before operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous whitespace before an operator.\n\n## Why is this bad?\nAccording to [PEP 8], operators should be surrounded by at most a single space on either\nside.\n\n## Example\n```python\na = 4  + 5\n```\n\nUse instead:\n```python\na = 12 + 3\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements\n"
  },
  {
    "name": "multiple-spaces-after-operator",
    "code": "E222",
    "linter": "pycodestyle",
    "summary": "Multiple spaces after operator",
    "message_formats": [
      "Multiple spaces after operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous whitespace after an operator.\n\n## Why is this bad?\nAccording to [PEP 8], operators should be surrounded by at most a single space on either\nside.\n\n## Example\n```python\na = 4 +  5\n```\n\nUse instead:\n```python\na = 12 + 3\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements\n"
  },
  {
    "name": "tab-before-operator",
    "code": "E223",
    "linter": "pycodestyle",
    "summary": "Tab before operator",
    "message_formats": [
      "Tab before operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous tabs before an operator.\n\n## Why is this bad?\nAccording to [PEP 8], operators should be surrounded by at most a single space on either\nside.\n\n## Example\n```python\na = 4\\t+ 5\n```\n\nUse instead:\n```python\na = 12 + 3\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements\n"
  },
  {
    "name": "tab-after-operator",
    "code": "E224",
    "linter": "pycodestyle",
    "summary": "Tab after operator",
    "message_formats": [
      "Tab after operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous tabs after an operator.\n\n## Why is this bad?\nAccording to [PEP 8], operators should be surrounded by at most a single space on either\nside.\n\n## Example\n```python\na = 4 +\\t5\n```\n\nUse instead:\n```python\na = 12 + 3\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#whitespace-in-expressions-and-statements\n"
  },
  {
    "name": "missing-whitespace-around-operator",
    "code": "E225",
    "linter": "pycodestyle",
    "summary": "Missing whitespace around operator",
    "message_formats": [
      "Missing whitespace around operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "missing-whitespace-around-arithmetic-operator",
    "code": "E226",
    "linter": "pycodestyle",
    "summary": "Missing whitespace around arithmetic operator",
    "message_formats": [
      "Missing whitespace around arithmetic operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "missing-whitespace-around-bitwise-or-shift-operator",
    "code": "E227",
    "linter": "pycodestyle",
    "summary": "Missing whitespace around bitwise or shift operator",
    "message_formats": [
      "Missing whitespace around bitwise or shift operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "missing-whitespace-around-modulo-operator",
    "code": "E228",
    "linter": "pycodestyle",
    "summary": "Missing whitespace around modulo operator",
    "message_formats": [
      "Missing whitespace around modulo operator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "missing-whitespace",
    "code": "E231",
    "linter": "pycodestyle",
    "summary": "Missing whitespace after '{token}'",
    "message_formats": [
      "Missing whitespace after '{token}'"
    ],
    "autofix": "Autofix is always available.",
    "explanation": null
  },
  {
    "name": "unexpected-spaces-around-keyword-parameter-equals",
    "code": "E251",
    "linter": "pycodestyle",
    "summary": "Unexpected spaces around keyword / parameter equals",
    "message_formats": [
      "Unexpected spaces around keyword / parameter equals"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "missing-whitespace-around-parameter-equals",
    "code": "E252",
    "linter": "pycodestyle",
    "summary": "Missing whitespace around parameter equals",
    "message_formats": [
      "Missing whitespace around parameter equals"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "too-few-spaces-before-inline-comment",
    "code": "E261",
    "linter": "pycodestyle",
    "summary": "Insert at least two spaces before an inline comment",
    "message_formats": [
      "Insert at least two spaces before an inline comment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks if inline comments are separated by at least two spaces.\n\n## Why is this bad?\nAn inline comment is a comment on the same line as a statement.\n\nPer PEP8, inline comments should be separated by at least two spaces from\nthe preceding statement.\n\n## Example\n```python\nx = x + 1 # Increment x\n```\n\nUse instead:\n```python\nx = x + 1  # Increment x\nx = x + 1    # Increment x\n```\n"
  },
  {
    "name": "no-space-after-inline-comment",
    "code": "E262",
    "linter": "pycodestyle",
    "summary": "Inline comment should start with `# `",
    "message_formats": [
      "Inline comment should start with `# `"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks if one space is used after inline comments.\n\n## Why is this bad?\nAn inline comment is a comment on the same line as a statement.\n\nPer PEP8, inline comments should start with a # and a single space.\n\n## Example\n```python\nx = x + 1  #Increment x\nx = x + 1  #  Increment x\nx = x + 1  # \\xa0Increment x\n```\n\nUse instead:\n```python\nx = x + 1  # Increment x\nx = x + 1    # Increment x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments\n"
  },
  {
    "name": "no-space-after-block-comment",
    "code": "E265",
    "linter": "pycodestyle",
    "summary": "Block comment should start with `# `",
    "message_formats": [
      "Block comment should start with `# `"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks if one space is used after block comments.\n\n## Why is this bad?\nPer PEP8, \"Block comments generally consist of one or more paragraphs built\nout of complete sentences, with each sentence ending in a period.\"\n\nBlock comments should start with a # and a single space.\n\n## Example\n```python\n#Block comment\n```\n\nUse instead:\n```python\n# Block comments:\n#  - Block comment list\n# \\xa0- Block comment list\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments\n"
  },
  {
    "name": "multiple-leading-hashes-for-block-comment",
    "code": "E266",
    "linter": "pycodestyle",
    "summary": "Too many leading `#` before block comment",
    "message_formats": [
      "Too many leading `#` before block comment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks if block comments start with a single \"#\".\n\n## Why is this bad?\nPer PEP8, \"Block comments generally consist of one or more paragraphs built\nout of complete sentences, with each sentence ending in a period.\"\n\nEach line of a block comment should start with a # and a single space.\n\n## Example\n```python\n### Block comment\n```\n\nUse instead:\n```python\n# Block comments:\n#  - Block comment list\n# \\xa0- Block comment list\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#comments\n"
  },
  {
    "name": "multiple-spaces-after-keyword",
    "code": "E271",
    "linter": "pycodestyle",
    "summary": "Multiple spaces after keyword",
    "message_formats": [
      "Multiple spaces after keyword"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous whitespace after keywords.\n\n## Why is this bad?\n\n\n## Example\n```python\nTrue and  False\n```\n\nUse instead:\n```python\nTrue and False\n```\n"
  },
  {
    "name": "multiple-spaces-before-keyword",
    "code": "E272",
    "linter": "pycodestyle",
    "summary": "Multiple spaces before keyword",
    "message_formats": [
      "Multiple spaces before keyword"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous whitespace before keywords.\n\n## Why is this bad?\n\n\n## Example\n```python\nTrue  and False\n```\n\nUse instead:\n```python\nTrue and False\n```\n"
  },
  {
    "name": "tab-after-keyword",
    "code": "E273",
    "linter": "pycodestyle",
    "summary": "Tab after keyword",
    "message_formats": [
      "Tab after keyword"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous tabs after keywords.\n\n## Why is this bad?\n\n\n## Example\n```python\nTrue and\\tFalse\n```\n\nUse instead:\n```python\nTrue and False\n```\n"
  },
  {
    "name": "tab-before-keyword",
    "code": "E274",
    "linter": "pycodestyle",
    "summary": "Tab before keyword",
    "message_formats": [
      "Tab before keyword"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for extraneous tabs before keywords.\n\n## Why is this bad?\n\n\n## Example\n```python\nTrue\\tand False\n```\n\nUse instead:\n```python\nTrue and False\n```\n"
  },
  {
    "name": "missing-whitespace-after-keyword",
    "code": "E275",
    "linter": "pycodestyle",
    "summary": "Missing whitespace after keyword",
    "message_formats": [
      "Missing whitespace after keyword"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "multiple-imports-on-one-line",
    "code": "E401",
    "linter": "pycodestyle",
    "summary": "Multiple imports on one line",
    "message_formats": [
      "Multiple imports on one line"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for multiple imports on one line.\n\n## Why is this bad?\nAccording to [PEP 8], \"imports should usually be on separate lines.\"\n\n## Example\n```python\nimport sys, os\n```\n\nUse instead:\n```python\nimport os\nimport sys\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports\n"
  },
  {
    "name": "module-import-not-at-top-of-file",
    "code": "E402",
    "linter": "pycodestyle",
    "summary": "Module level import not at top of file",
    "message_formats": [
      "Module level import not at top of file"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for imports that are not at the top of the file.\n\n## Why is this bad?\nAccording to [PEP 8], \"imports are always put at the top of the file, just after any\nmodule comments and docstrings, and before module globals and constants.\"\n\n## Example\n```python\n\"One string\"\n\"Two string\"\na = 1\nimport os\nfrom sys import x\n```\n\nUse instead:\n```python\nimport os\nfrom sys import x\n\n\"One string\"\n\"Two string\"\na = 1\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports\n"
  },
  {
    "name": "line-too-long",
    "code": "E501",
    "linter": "pycodestyle",
    "summary": "Line too long ({width} > {limit} characters)",
    "message_formats": [
      "Line too long ({width} > {limit} characters)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for lines that exceed the specified maximum character length.\n\n## Why is this bad?\nOverlong lines can hurt readability. [PEP 8], for example, recommends\nlimiting lines to 79 characters.\n\nIn the interest of pragmatism, this rule makes a few exceptions when\ndetermining whether a line is overlong. Namely, it ignores lines that\nconsist of a single \"word\" (i.e., without any whitespace between its\ncharacters), and lines that end with a URL (as long as the URL starts\nbefore the line-length threshold).\n\nIf `pycodestyle.ignore_overlong_task_comments` is `true`, this rule will\nalso ignore comments that start with any of the specified `task-tags`\n(e.g., `# TODO:`).\n\n## Example\n```python\nmy_function(param1, param2, param3, param4, param5, param6, param7, param8, param9, param10)\n```\n\nUse instead:\n```python\nmy_function(\n    param1, param2, param3, param4, param5,\n    param6, param7, param8, param9, param10\n)\n```\n\n## Options\n- `task-tags`\n- `pycodestyle.ignore-overlong-task-comments`\n\n[PEP 8]: https://peps.python.org/pep-0008/#maximum-line-length\n"
  },
  {
    "name": "multiple-statements-on-one-line-colon",
    "code": "E701",
    "linter": "pycodestyle",
    "summary": "Multiple statements on one line (colon)",
    "message_formats": [
      "Multiple statements on one line (colon)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for compound statements (multiple statements on the same line).\n\n## Why is this bad?\nAccording to [PEP 8], \"compound statements are generally discouraged\".\n\n## Example\n```python\nif foo == \"blah\": do_blah_thing()\n```\n\nUse instead:\n```python\nif foo == \"blah\":\n    do_blah_thing()\n```\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations\n"
  },
  {
    "name": "multiple-statements-on-one-line-semicolon",
    "code": "E702",
    "linter": "pycodestyle",
    "summary": "Multiple statements on one line (semicolon)",
    "message_formats": [
      "Multiple statements on one line (semicolon)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for multiline statements on one line.\n\n## Why is this bad?\nAccording to [PEP 8], including multi-clause statements on the same line is\ndiscouraged.\n\n## Example\n```python\ndo_one(); do_two(); do_three()\n```\n\nUse instead:\n```python\ndo_one()\ndo_two()\ndo_three()\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations\n"
  },
  {
    "name": "useless-semicolon",
    "code": "E703",
    "linter": "pycodestyle",
    "summary": "Statement ends with an unnecessary semicolon",
    "message_formats": [
      "Statement ends with an unnecessary semicolon"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for statements that end with an unnecessary semicolon.\n\n## Why is this bad?\nA trailing semicolon is unnecessary and should be removed.\n\n## Example\n```python\ndo_four();  # useless semicolon\n```\n\nUse instead:\n```python\ndo_four()\n```\n"
  },
  {
    "name": "none-comparison",
    "code": "E711",
    "linter": "pycodestyle",
    "summary": "Comparison to `None` should be `cond is None`",
    "message_formats": [
      "Comparison to `None` should be `cond is None`",
      "Comparison to `None` should be `cond is not None`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for comparisons to `None` which are not using the `is` operator.\n\n## Why is this bad?\nAccording to [PEP 8], \"Comparisons to singletons like None should always be done with\nis or is not, never the equality operators.\"\n\n## Example\n```python\nif arg != None:\n    pass\nif None == arg:\n    pass\n```\n\nUse instead:\n```python\nif arg is not None:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#programming-recommendations\n"
  },
  {
    "name": "true-false-comparison",
    "code": "E712",
    "linter": "pycodestyle",
    "summary": "Comparison to `True` should be `cond is True` or `if cond:`",
    "message_formats": [
      "Comparison to `True` should be `cond is True` or `if cond:`",
      "Comparison to `True` should be `cond is not True` or `if not cond:`",
      "Comparison to `False` should be `cond is False` or `if not cond:`",
      "Comparison to `False` should be `cond is not False` or `if cond:`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for comparisons to booleans which are not using the `is` operator.\n\n## Why is this bad?\nAccording to [PEP 8], \"Comparisons to singletons like None should always be done with\nis or is not, never the equality operators.\"\n\n## Example\n```python\nif arg == True:\n    pass\nif False == arg:\n    pass\n```\n\nUse instead:\n```python\nif arg is True:\n    pass\nif arg is False:\n    pass\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#programming-recommendations\n"
  },
  {
    "name": "not-in-test",
    "code": "E713",
    "linter": "pycodestyle",
    "summary": "Test for membership should be `not in`",
    "message_formats": [
      "Test for membership should be `not in`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for negative comparison using `not {foo} in {bar}`.\n\n## Why is this bad?\nNegative comparison should be done using `not in`.\n\n## Example\n```python\nZ = not X in Y\nif not X.B in Y:\n    pass\n```\n\nUse instead:\n```python\nZ = X not in Y\nif X.B not in Y:\n    pass\n```\n"
  },
  {
    "name": "not-is-test",
    "code": "E714",
    "linter": "pycodestyle",
    "summary": "Test for object identity should be `is not`",
    "message_formats": [
      "Test for object identity should be `is not`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for negative comparison using `not {foo} is {bar}`.\n\n## Why is this bad?\nNegative comparison should be done using `is not`.\n\n## Example\n```python\nif not X is Y:\n    pass\nZ = not X.B is Y\n```\n\nUse instead:\n```python\nif X is not Y:\n    pass\nZ = X.B is not Y\n```\n"
  },
  {
    "name": "type-comparison",
    "code": "E721",
    "linter": "pycodestyle",
    "summary": "Do not compare types, use `isinstance()`",
    "message_formats": [
      "Do not compare types, use `isinstance()`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for object type comparisons without using isinstance().\n\n## Why is this bad?\nDo not compare types directly.\nWhen checking if an object is a instance of a certain type, keep in mind that it might\nbe subclassed. E.g. `bool` inherits from `int` or `Exception` inherits from `BaseException`.\n\n## Example\n```python\nif type(obj) is type(1):\n    pass\n```\n\nUse instead:\n```python\nif isinstance(obj, int):\n    pass\nif type(a1) is type(b1):\n    pass\n```\n"
  },
  {
    "name": "bare-except",
    "code": "E722",
    "linter": "pycodestyle",
    "summary": "Do not use bare `except`",
    "message_formats": [
      "Do not use bare `except`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for bare `except` catches in `try`-`except` statements.\n\n## Why is this bad?\nA bare `except` catches `BaseException` which includes\n`KeyboardInterrupt`, `SystemExit`, `Exception`, and others. Catching\n`BaseException` can make it hard to interrupt the program (e.g., with\nCtrl-C) and can disguise other problems.\n\n## Example\n```python\ntry:\n    raise KeyboardInterrupt(\"You probably don't mean to break CTRL-C.\")\nexcept:\n    print(\"But a bare `except` will ignore keyboard interrupts.\")\n```\n\nUse instead:\n```python\ntry:\n    do_something_that_might_break()\nexcept MoreSpecificException as e:\n    handle_error(e)\n```\n\nIf you actually need to catch an unknown error, use `Exception` which will\ncatch regular program errors but not important system exceptions.\n\n```python\ndef run_a_function(some_other_fn):\n    try:\n        some_other_fn()\n    except Exception as e:\n        print(f\"How exceptional! {e}\")\n```\n\n## References\n- [Python documentation: Exception hierarchy](https://docs.python.org/3/library/exceptions.html#exception-hierarchy)\n- [Google Python Style Guide: \"Exceptions\"](https://google.github.io/styleguide/pyguide.html#24-exceptions)\n"
  },
  {
    "name": "lambda-assignment",
    "code": "E731",
    "linter": "pycodestyle",
    "summary": "Do not assign a `lambda` expression, use a `def`",
    "message_formats": [
      "Do not assign a `lambda` expression, use a `def`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for lambda expressions which are assigned to a variable.\n\n## Why is this bad?\nPer PEP 8, you should \"Always use a def statement instead of an assignment\nstatement that binds a lambda expression directly to an identifier.\"\n\nUsing a `def` statement leads to better tracebacks, and the assignment\nitself negates the primary benefit of using a `lambda` expression (i.e.,\nthat it can be embedded inside another expression).\n\n## Example\n```python\nf = lambda x: 2 * x\n```\n\nUse instead:\n```python\ndef f(x):\n    return 2 * x\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#programming-recommendations\n"
  },
  {
    "name": "ambiguous-variable-name",
    "code": "E741",
    "linter": "pycodestyle",
    "summary": "Ambiguous variable name: `{name}`",
    "message_formats": [
      "Ambiguous variable name: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of the characters 'l', 'O', or 'I' as variable names.\n\n## Why is this bad?\nIn some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\n## Example\n```python\nl = 0\nO = 123\nI = 42\n```\n\nUse instead:\n```python\nL = 0\no = 123\ni = 42\n```\n"
  },
  {
    "name": "ambiguous-class-name",
    "code": "E742",
    "linter": "pycodestyle",
    "summary": "Ambiguous class name: `{name}`",
    "message_formats": [
      "Ambiguous class name: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of the characters 'l', 'O', or 'I' as class names.\n\n## Why is this bad?\nIn some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\n## Example\n```python\nclass I(object):\n    ...\n```\n\nUse instead:\n```python\nclass Integer(object):\n    ...\n```\n"
  },
  {
    "name": "ambiguous-function-name",
    "code": "E743",
    "linter": "pycodestyle",
    "summary": "Ambiguous function name: `{name}`",
    "message_formats": [
      "Ambiguous function name: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of the characters 'l', 'O', or 'I' as function names.\n\n## Why is this bad?\nIn some fonts, these characters are indistinguishable from the\nnumerals one and zero. When tempted to use 'l', use 'L' instead.\n\n## Example\n```python\ndef l(x):\n    ...\n```\n\nUse instead:\n```python\ndef long_name(x):\n    ...\n```\n"
  },
  {
    "name": "io-error",
    "code": "E902",
    "linter": "pycodestyle",
    "summary": "{message}",
    "message_formats": [
      "{message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "syntax-error",
    "code": "E999",
    "linter": "pycodestyle",
    "summary": "SyntaxError: {message}",
    "message_formats": [
      "SyntaxError: {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "tab-indentation",
    "code": "W191",
    "linter": "pycodestyle",
    "summary": "Indentation contains tabs",
    "message_formats": [
      "Indentation contains tabs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": null
  },
  {
    "name": "trailing-whitespace",
    "code": "W291",
    "linter": "pycodestyle",
    "summary": "Trailing whitespace",
    "message_formats": [
      "Trailing whitespace"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for superfluous trailing whitespace.\n\n## Why is this bad?\nAccording to [PEP 8], \"avoid trailing whitespace anywhere. Because its usually\ninvisible, it can be confusing\"\n\n## Example\n```python\nspam(1) \\n#\n```\n\nUse instead:\n```python\nspam(1)\\n#\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations\n"
  },
  {
    "name": "missing-newline-at-end-of-file",
    "code": "W292",
    "linter": "pycodestyle",
    "summary": "No newline at end of file",
    "message_formats": [
      "No newline at end of file"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for files missing a new line at the end of the file.\n\n## Why is this bad?\nTrailing blank lines are superfluous.\nHowever the last line should end with a new line.\n\n## Example\n```python\nspam(1)\n```\n\nUse instead:\n```python\nspam(1)\\n\n```\n"
  },
  {
    "name": "blank-line-with-whitespace",
    "code": "W293",
    "linter": "pycodestyle",
    "summary": "Blank line contains whitespace",
    "message_formats": [
      "Blank line contains whitespace"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for superfluous whitespace in blank lines.\n\n## Why is this bad?\nAccording to [PEP 8], \"avoid trailing whitespace anywhere. Because its usually\ninvisible, it can be confusing\"\n\n## Example\n```python\nclass Foo(object):\\n    \\n    bang = 12\n```\n\nUse instead:\n```python\nclass Foo(object):\\n\\n    bang = 12\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#other-recommendations\n"
  },
  {
    "name": "doc-line-too-long",
    "code": "W505",
    "linter": "pycodestyle",
    "summary": "Doc line too long ({width} > {limit} characters)",
    "message_formats": [
      "Doc line too long ({width} > {limit} characters)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for doc lines that exceed the specified maximum character length.\n\n## Why is this bad?\nFor flowing long blocks of text (docstrings or comments), overlong lines\ncan hurt readability. [PEP 8], for example, recommends that such lines be\nlimited to 72 characters.\n\nIn the context of this rule, a \"doc line\" is defined as a line consisting\nof either a standalone comment or a standalone string, like a docstring.\n\nIn the interest of pragmatism, this rule makes a few exceptions when\ndetermining whether a line is overlong. Namely, it ignores lines that\nconsist of a single \"word\" (i.e., without any whitespace between its\ncharacters), and lines that end with a URL (as long as the URL starts\nbefore the line-length threshold).\n\nIf `pycodestyle.ignore_overlong_task_comments` is `true`, this rule will\nalso ignore comments that start with any of the specified `task-tags`\n(e.g., `# TODO:`).\n\n## Example\n```python\ndef function(x):\n    \"\"\"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis auctor purus ut ex fermentum, at maximus est hendrerit.\"\"\"\n```\n\nUse instead:\n```python\ndef function(x):\n    \"\"\"\n    Lorem ipsum dolor sit amet, consectetur adipiscing elit.\n    Duis auctor purus ut ex fermentum, at maximus est hendrerit.\n    \"\"\"\n```\n\n\n## Options\n- `task-tags`\n- `pycodestyle.ignore-overlong-task-comments`\n\n[PEP 8]: https://peps.python.org/pep-0008/#maximum-line-length\n"
  },
  {
    "name": "invalid-escape-sequence",
    "code": "W605",
    "linter": "pycodestyle",
    "summary": "Invalid escape sequence: `\\{char}`",
    "message_formats": [
      "Invalid escape sequence: `\\{char}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for invalid escape sequences.\n\n## Why is this bad?\nInvalid escape sequences are deprecated in Python 3.6.\n\n## Example\n```python\nregex = \"\\.png$\"\n```\n\nUse instead:\n```python\nregex = r\"\\.png$\"\n```\n\n## References\n- [Python documentation: String and Bytes literals](https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals)\n"
  },
  {
    "name": "undocumented-public-module",
    "code": "D100",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public module",
    "message_formats": [
      "Missing docstring in public module"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public module definitions.\n\n## Why is this bad?\nPublic modules should be documented via docstrings to outline their purpose\nand contents.\n\nGenerally, module docstrings should describe the purpose of the module and\nlist the classes, exceptions, functions, and other objects that are exported\nby the module, alongside a one-line summary of each.\n\nIf the module is a script, the docstring should be usable as its \"usage\"\nmessage.\n\nIf the codebase adheres to a standard format for module docstrings, follow\nthat format for consistency.\n\n## Example\n```python\nclass FasterThanLightError(ZeroDivisionError):\n    ...\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    ...\n```\n\nUse instead:\n```python\n\"\"\"Utility functions and classes for calculating speed.\n\nThis module provides:\n- FasterThanLightError: exception when FTL speed is calculated;\n- calculate_speed: calculate speed given distance and time.\n\"\"\"\n\n\nclass FasterThanLightError(ZeroDivisionError):\n    ...\n\n\ndef calculate_speed(distance: float, time: float) -> float:\n    ...\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-class",
    "code": "D101",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public class",
    "message_formats": [
      "Missing docstring in public class"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public class definitions.\n\n## Why is this bad?\nPublic classes should be documented via docstrings to outline their purpose\nand behavior.\n\nGenerally, a class docstring should describe the class's purpose and list\nits public attributes and methods.\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.\n\n## Example\n```python\nclass Player:\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```\n\nUse instead (in the NumPy docstring format):\n```python\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes\n    ----------\n    name : str\n        The name of the player.\n    points : int\n        The number of points the player has.\n\n    Methods\n    -------\n    add_points(points: int) -> None\n        Add points to the player's score.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```\n\nOr (in the Google docstring format):\n```python\nclass Player:\n    \"\"\"A player in the game.\n\n    Attributes:\n        name: The name of the player.\n        points: The number of points the player has.\n    \"\"\"\n\n    def __init__(self, name: str, points: int = 0) -> None:\n        self.name: str = name\n        self.points: int = points\n\n    def add_points(self, points: int) -> None:\n        self.points += points\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-method",
    "code": "D102",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public method",
    "message_formats": [
      "Missing docstring in public method"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public method definitions.\n\n## Why is this bad?\nPublic methods should be documented via docstrings to outline their purpose\nand behavior.\n\nGenerally, a method docstring should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.\n\n## Example\n```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```\n\nUse instead (in the NumPy docstring format):\n```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Parameters\n        ----------\n        happy : bool, optional\n            Whether the cat is happy, is True by default.\n\n        Raises\n        ------\n        ValueError\n            If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```\n\nOr (in the Google docstring format):\n```python\nclass Cat(Animal):\n    def greet(self, happy: bool = True):\n        \"\"\"Print a greeting from the cat.\n\n        Args:\n            happy: Whether the cat is happy, is True by default.\n\n        Raises:\n            ValueError: If the cat is not happy.\n        \"\"\"\n        if happy:\n            print(\"Meow!\")\n        else:\n            raise ValueError(\"Tried to greet an unhappy cat.\")\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-function",
    "code": "D103",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public function",
    "message_formats": [
      "Missing docstring in public function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public function definitions.\n\n## Why is this bad?\nPublic functions should be documented via docstrings to outline their\npurpose and behavior.\n\nGenerally, a function docstring should describe the function's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for function docstrings, follow\nthat format for consistency.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead (using the NumPy docstring format):\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nOr, using the Google docstring format:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Python Docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-package",
    "code": "D104",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public package",
    "message_formats": [
      "Missing docstring in public package"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public package definitions.\n\n## Why is this bad?\nPublic packages should be documented via docstrings to outline their\npurpose and contents.\n\nGenerally, package docstrings should list the modules and subpackages that\nare exported by the package.\n\nIf the codebase adheres to a standard format for package docstrings, follow\nthat format for consistency.\n\n## Example\n```python\n__all__ = [\"Player\", \"Game\"]\n```\n\nUse instead:\n```python\n\"\"\"Game and player management package.\n\nThis package provides classes for managing players and games.\n\"\"\"\n\n__all__ = [\"player\", \"game\"]\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Python Docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-magic-method",
    "code": "D105",
    "linter": "pydocstyle",
    "summary": "Missing docstring in magic method",
    "message_formats": [
      "Missing docstring in magic method"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented magic method definitions.\n\n## Why is this bad?\nMagic methods (methods with names that start and end with double\nunderscores) are used to implement operator overloading and other special\nbehavior. Such methods should should be documented via docstrings to\noutline their behavior.\n\nGenerally, magic method docstrings should describe the method's behavior,\narguments, side effects, exceptions, return values, and any other\ninformation that may be relevant to the user.\n\nIf the codebase adheres to a standard format for method docstrings, follow\nthat format for consistency.\n\n## Example\n```python\nclass Cat(Animal):\n    def __str__(self) -> str:\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n```\n\nUse instead:\n```python\nclass Cat(Animal):\n    def __str__(self) -> str:\n        \"\"\"Return a string representation of the cat.\"\"\"\n        return f\"Cat: {self.name}\"\n\n\ncat = Cat(\"Dusty\")\nprint(cat)  # \"Cat: Dusty\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Python Docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-nested-class",
    "code": "D106",
    "linter": "pydocstyle",
    "summary": "Missing docstring in public nested class",
    "message_formats": [
      "Missing docstring in public nested class"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undocumented public class definitions, for nested classes.\n\n## Why is this bad?\nPublic classes should be documented via docstrings to outline their\npurpose and behavior.\n\nNested classes do not inherit the docstring of their enclosing class, so\nthey should have their own docstrings.\n\nIf the codebase adheres to a standard format for class docstrings, follow\nthat format for consistency.\n\n## Example\n```python\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar:\n        ...\n\n\nbar = Foo.Bar()\nbar.__doc__  # None\n```\n\nUse instead:\n```python\nclass Foo:\n    \"\"\"Class Foo.\"\"\"\n\n    class Bar:\n        \"\"\"Class Bar.\"\"\"\n\n\nbar = Foo.Bar()\nbar.__doc__  # \"Class Bar.\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Python Docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-public-init",
    "code": "D107",
    "linter": "pydocstyle",
    "summary": "Missing docstring in `__init__`",
    "message_formats": [
      "Missing docstring in `__init__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for public `__init__` method definitions that are missing\ndocstrings.\n\n## Why is this bad?\nPublic `__init__` methods are used to initialize objects. `__init__`\nmethods should be documented via docstrings to describe the method's\nbehavior, arguments, side effects, exceptions, and any other information\nthat may be relevant to the user.\n\nIf the codebase adheres to a standard format for `__init__` method docstrings,\nfollow that format for consistency.\n\n## Example\n```python\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        self.name: str = name\n        self.population: int = population\n```\n\nUse instead:\n```python\nclass City:\n    def __init__(self, name: str, population: int) -> None:\n        \"\"\"Initialize a city with a name and population.\"\"\"\n        self.name: str = name\n        self.population: int = population\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Python Docstrings](https://google.github.io/styleguide/pyguide.html#s3.8-comments-and-docstrings)\n"
  },
  {
    "name": "fits-on-one-line",
    "code": "D200",
    "linter": "pydocstyle",
    "summary": "One-line docstring should fit on one line",
    "message_formats": [
      "One-line docstring should fit on one line"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for single-line docstrings that are broken across multiple lines.\n\n## Why is this bad?\n[PEP 257] recommends that docstrings that _can_ fit on one line should be\nformatted on a single line, for consistency and readability.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"\n    Return the mean of the given values.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "no-blank-line-before-function",
    "code": "D201",
    "linter": "pydocstyle",
    "summary": "No blank lines allowed before function docstring (found {num_lines})",
    "message_formats": [
      "No blank lines allowed before function docstring (found {num_lines})"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings on functions that are separated by one or more blank\nlines from the function definition.\n\n## Why is this bad?\nRemove any blank lines between the function definition and its docstring,\nfor consistency.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "no-blank-line-after-function",
    "code": "D202",
    "linter": "pydocstyle",
    "summary": "No blank lines allowed after function docstring (found {num_lines})",
    "message_formats": [
      "No blank lines allowed after function docstring (found {num_lines})"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings on functions that are separated by one or more blank\nlines from the function body.\n\n## Why is this bad?\nRemove any blank lines between the function body and the function\ndocstring, for consistency.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n\n    return sum(values) / len(values)\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n    return sum(values) / len(values)\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "one-blank-line-before-class",
    "code": "D203",
    "linter": "pydocstyle",
    "summary": "1 blank line required before class docstring",
    "message_formats": [
      "1 blank line required before class docstring"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings on class definitions that are not preceded by a\nblank line.\n\n## Why is this bad?\nUse a blank line to separate the docstring from the class definition, for\nconsistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D211].\n\n## Example\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\nUse instead:\n```python\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n[D211]: https://beta.ruff.rs/docs/rules/blank-line-before-class\n"
  },
  {
    "name": "one-blank-line-after-class",
    "code": "D204",
    "linter": "pydocstyle",
    "summary": "1 blank line required after class docstring",
    "message_formats": [
      "1 blank line required after class docstring"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for class methods that are not separated from the class's docstring\nby a blank line.\n\n## Why is this bad?\n[PEP 257] recommends the use of a blank line to separate a class's\ndocstring its methods.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`\nconvention, and disabled when using the `numpy` and `pep257` conventions.\n\n## Example\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n    def __init__(self, file: Path):\n        ...\n```\n\nUse instead:\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n\n    def __init__(self, file: Path):\n        ...\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "blank-line-after-summary",
    "code": "D205",
    "linter": "pydocstyle",
    "summary": "1 blank line required between summary line and description",
    "message_formats": [
      "1 blank line required between summary line and description",
      "1 blank line required between summary line and description (found {num_lines})"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for docstring summary lines that are not separated from the docstring\ndescription by one blank line.\n\n## Why is this bad?\n[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the\n    result using the bubble sort algorithm.\n    \"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "indent-with-spaces",
    "code": "D206",
    "linter": "pydocstyle",
    "summary": "Docstring should be indented with spaces, not tabs",
    "message_formats": [
      "Docstring should be indented with spaces, not tabs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that are indented with tabs.\n\n## Why is this bad?\n[PEP 8](https://peps.python.org/pep-0008/#tabs-or-spaces) recommends using\nspaces over tabs for indentation.\n\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n\tSort the list in ascending order and return a copy of the result using the bubble\n\tsort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "under-indentation",
    "code": "D207",
    "linter": "pydocstyle",
    "summary": "Docstring is under-indented",
    "message_formats": [
      "Docstring is under-indented"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for under-indented docstrings.\n\n## Why is this bad?\n[PEP 257] recommends that docstrings be indented to the same level as their\nopening quotes. Avoid under-indenting docstrings, for consistency.\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\nSort the list in ascending order and return a copy of the result using the bubble sort\nalgorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "over-indentation",
    "code": "D208",
    "linter": "pydocstyle",
    "summary": "Docstring is over-indented",
    "message_formats": [
      "Docstring is over-indented"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for over-indented docstrings.\n\n## Why is this bad?\n[PEP 257] recommends that docstrings be indented to the same level as their\nopening quotes. Avoid over-indenting docstrings, for consistency.\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n        Sort the list in ascending order and return a copy of the result using the\n        bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "new-line-after-last-paragraph",
    "code": "D209",
    "linter": "pydocstyle",
    "summary": "Multi-line docstring closing quotes should be on a separate line",
    "message_formats": [
      "Multi-line docstring closing quotes should be on a separate line"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for multi-line docstrings whose closing quotes are not on their\nown line.\n\n## Why is this bad?\n[PEP 257] recommends that the closing quotes of a multi-line docstring be\non their own line, for consistency and compatibility with documentation\ntools that may need to parse the docstring.\n\n## Example\n```python\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: List[int]) -> List[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "surrounding-whitespace",
    "code": "D210",
    "linter": "pydocstyle",
    "summary": "No whitespaces allowed surrounding docstring text",
    "message_formats": [
      "No whitespaces allowed surrounding docstring text"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for surrounding whitespace in docstrings.\n\n## Why is this bad?\nRemove surrounding whitespace from the docstring, for consistency.\n\n## Example\n```python\ndef factorial(n: int) -> int:\n    \"\"\" Return the factorial of n. \"\"\"\n```\n\nUse instead:\n```python\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "blank-line-before-class",
    "code": "D211",
    "linter": "pydocstyle",
    "summary": "No blank lines allowed before class docstring",
    "message_formats": [
      "No blank lines allowed before class docstring"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings on class definitions that are preceded by a blank\nline.\n\n## Why is this bad?\nAvoid introducing any blank lines between a class definition and its\ndocstring, for consistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D203].\n\n## Example\n```python\nclass PhotoMetadata:\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\nUse instead:\n```python\nclass PhotoMetadata:\n\n    \"\"\"Metadata about a photo.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n[D203]: https://beta.ruff.rs/docs/rules/one-blank-line-before-class\n"
  },
  {
    "name": "multi-line-summary-first-line",
    "code": "D212",
    "linter": "pydocstyle",
    "summary": "Multi-line docstring summary should start at the first line",
    "message_formats": [
      "Multi-line docstring summary should start at the first line"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring summary lines that are not positioned on the first\nphysical line of the docstring.\n\n## Why is this bad?\n[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\nThe summary line should be located on the first physical line of the\ndocstring, immediately after the opening quotes.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`\nconvention, and disabled when using the `numpy` and `pep257` conventions.\n\nFor an alternative, see [D213].\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n[D213]: https://beta.ruff.rs/docs/rules/multi-line-summary-second-line\n"
  },
  {
    "name": "multi-line-summary-second-line",
    "code": "D213",
    "linter": "pydocstyle",
    "summary": "Multi-line docstring summary should start at the second line",
    "message_formats": [
      "Multi-line docstring summary should start at the second line"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring summary lines that are not positioned on the second\nphysical line of the docstring.\n\n## Why is this bad?\n[PEP 257] recommends that multi-line docstrings consist of \"a summary line\njust like a one-line docstring, followed by a blank line, followed by a\nmore elaborate description.\"\n\nThe summary line should be located on the second physical line of the\ndocstring, immediately after the opening quotes and the blank line.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is disabled when using the `google`,\n`numpy`, and `pep257` conventions.\n\nFor an alternative, see [D212].\n\n## Example\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the\n    bubble sort algorithm.\n    \"\"\"\n```\n\nUse instead:\n```python\ndef sort_list(l: list[int]) -> list[int]:\n    \"\"\"\n    Return a sorted copy of the list.\n\n    Sort the list in ascending order and return a copy of the result using the bubble\n    sort algorithm.\n    \"\"\"\n```\n\n[D212]: https://beta.ruff.rs/docs/rules/multi-line-summary-first-line\n"
  },
  {
    "name": "section-not-over-indented",
    "code": "D214",
    "linter": "pydocstyle",
    "summary": "Section is over-indented (\"{name}\")",
    "message_formats": [
      "Section is over-indented (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for over-indented sections in docstrings.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nEach section should use consistent indentation, with the section headers\nmatching the indentation of the docstring's opening quotes, and the\nsection bodies being indented one level further.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n        Args:\n            distance: Distance traveled.\n            time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "section-underline-not-over-indented",
    "code": "D215",
    "linter": "pydocstyle",
    "summary": "Section underline is over-indented (\"{name}\")",
    "message_formats": [
      "Section underline is over-indented (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for over-indented section underlines in docstrings.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSome docstring formats (like reStructuredText) use underlines to separate\nsection bodies from section headers.\n\nAvoid over-indenting the section underlines, as this can cause syntax\nerrors in reStructuredText.\n\nBy default, this rule is enabled when using the `numpy` convention, and\ndisabled when using the `google` or `pep257` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n        ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "triple-single-quotes",
    "code": "D300",
    "linter": "pydocstyle",
    "summary": "Use triple double quotes `\"\"\"`",
    "message_formats": [
      "Use triple double quotes `\"\"\"`",
      "Use triple single quotes `'''`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that use `'''triple single quotes'''` instead of\n`\"\"\"triple double quotes\"\"\"`.\n\n## Why is this bad?\n[PEP 257](https://peps.python.org/pep-0257/#what-is-a-docstring) recommends\nthe use of `\"\"\"triple double quotes\"\"\"` for docstrings, to ensure\nconsistency.\n\n## Example\n```python\ndef kos_root():\n    '''Return the pathname of the KOS root directory.'''\n```\n\nUse instead:\n```python\ndef kos_root():\n    \"\"\"Return the pathname of the KOS root directory.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "escape-sequence-in-docstring",
    "code": "D301",
    "linter": "pydocstyle",
    "summary": "Use `r\"\"\"` if any backslashes in a docstring",
    "message_formats": [
      "Use `r\"\"\"` if any backslashes in a docstring"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that include backslashes, but are not defined as\nraw string literals.\n\n## Why is this bad?\nIn Python, backslashes are typically used to escape characters in strings.\nIn raw strings (those prefixed with an `r`), however, backslashes are\ntreated as literal characters.\n\n[PEP 257](https://peps.python.org/pep-0257/#what-is-a-docstring) recommends\nthe use of raw strings (i.e., `r\"\"\"raw triple double quotes\"\"\"`) for\ndocstrings that include backslashes. The use of a raw string ensures that\nany backslashes are treated as literal characters, and not as escape\nsequences, which avoids confusion.\n\n## Example\n```python\ndef foobar():\n    \"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foar.\"\n```\n\nUse instead:\n```python\ndef foobar():\n    r\"\"\"Docstring for foo\\bar.\"\"\"\n\n\nfoobar.__doc__  # \"Docstring for foo\\bar.\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [Python documentation: String and Bytes literals](https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals)\n"
  },
  {
    "name": "ends-in-period",
    "code": "D400",
    "linter": "pydocstyle",
    "summary": "First line should end with a period",
    "message_formats": [
      "First line should end with a period"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings in which the first line does not end in a period.\n\n## Why is this bad?\n[PEP 257] recommends that the first line of a docstring is written in the\nform of a command, ending in a period.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy` and\n`pep257` conventions, and disabled when using the `google` convention.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "non-imperative-mood",
    "code": "D401",
    "linter": "pydocstyle",
    "summary": "First line of docstring should be in imperative mood: \"{first_line}\"",
    "message_formats": [
      "First line of docstring should be in imperative mood: \"{first_line}\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstring first lines that are not in an imperative mood.\n\n## Why is this bad?\n[PEP 257] recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy` and\n`pep257` conventions, and disabled when using the `google` conventions.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Returns the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "no-signature",
    "code": "D402",
    "linter": "pydocstyle",
    "summary": "First line should not be the function's signature",
    "message_formats": [
      "First line should not be the function's signature"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function docstrings that include the function's signature in\nthe summary line.\n\n## Why is this bad?\n[PEP 257] recommends against including a function's signature in its\ndocstring. Instead, consider using type annotations as a form of\ndocumentation for the function's parameters and return value.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google` and\n`pep257` conventions, and disabled when using the `numpy` convention.\n\n## Example\n```python\ndef foo(a, b):\n    \"\"\"foo(a: int, b: int) -> list[int]\"\"\"\n```\n\nUse instead:\n```python\ndef foo(a: int, b: int) -> list[int]:\n    \"\"\"Return a list of a and b.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "first-line-capitalized",
    "code": "D403",
    "linter": "pydocstyle",
    "summary": "First word of the first line should be capitalized: `{}` -> `{}`",
    "message_formats": [
      "First word of the first line should be capitalized: `{}` -> `{}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings that do not start with a capital letter.\n\n## Why is this bad?\nThe first character in a docstring should be capitalized for, grammatical\ncorrectness and consistency.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"return the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "docstring-starts-with-this",
    "code": "D404",
    "linter": "pydocstyle",
    "summary": "First word of the docstring should not be \"This\"",
    "message_formats": [
      "First word of the docstring should not be \"This\""
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that start with `This`.\n\n## Why is this bad?\n[PEP 257] recommends that the first line of a docstring be written in the\nimperative mood, for consistency.\n\nHint: to rewrite the docstring in the imperative, phrase the first line as\nif it were a command.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `numpy`\nconvention,, and disabled when using the `google` and `pep257` conventions.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"This function returns the mean of the given values.\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n\n[PEP 257]: https://peps.python.org/pep-0257/\n"
  },
  {
    "name": "capitalize-section-name",
    "code": "D405",
    "linter": "pydocstyle",
    "summary": "Section name should be properly capitalized (\"{name}\")",
    "message_formats": [
      "Section name should be properly capitalized (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for section headers in docstrings that do not begin with capital\nletters.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSection headers should be capitalized, for consistency.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    returns:\n        Speed as distance divided by time.\n\n    raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "new-line-after-section-name",
    "code": "D406",
    "linter": "pydocstyle",
    "summary": "Section name should end with a newline (\"{name}\")",
    "message_formats": [
      "Section name should end with a newline (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks that section headers in docstrings that are not followed by a\nnewline.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSection headers should be followed by a newline, and not by another\ncharacter (like a colon), for consistency.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters:\n    -----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns:\n    --------\n    float\n        Speed as distance divided by time.\n\n    Raises:\n    -------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "dashed-underline-after-section",
    "code": "D407",
    "linter": "pydocstyle",
    "summary": "Missing dashed underline after section (\"{name}\")",
    "message_formats": [
      "Missing dashed underline after section (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for section headers in docstrings that are not followed by\nunderlines.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSome docstring formats (like reStructuredText) use underlines to separate\nsection bodies from section headers.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "section-underline-after-name",
    "code": "D408",
    "linter": "pydocstyle",
    "summary": "Section underline should be in the line following the section's name (\"{name}\")",
    "message_formats": [
      "Section underline should be in the line following the section's name (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for section underlines in docstrings that are not on the line\nimmediately following the section name.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSome docstring formats (like reStructuredText) use underlines to separate\nsection bodies from section headers.\n\nWhen present, section underlines should be positioned on the line\nimmediately following the section header.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "section-underline-matches-section-length",
    "code": "D409",
    "linter": "pydocstyle",
    "summary": "Section underline should match the length of its name (\"{name}\")",
    "message_formats": [
      "Section underline should match the length of its name (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for section underlines in docstrings that do not match the length of\nthe corresponding section header.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nSome docstring formats (like reStructuredText) use underlines to separate\nsection bodies from section headers.\n\nWhen present, section underlines should match the length of the\ncorresponding section header.\n\nThis rule is enabled when using the `numpy` convention, and disabled\nwhen using the `google` or `pep257` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ---\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    ---\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ---\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "no-blank-line-after-section",
    "code": "D410",
    "linter": "pydocstyle",
    "summary": "Missing blank line after section (\"{name}\")",
    "message_formats": [
      "Missing blank line after section (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring sections that are not separated by a single blank\nline.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nDocstring sections should be separated by a blank line, for consistency and\ncompatibility with documentation tooling.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Guide](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "no-blank-line-before-section",
    "code": "D411",
    "linter": "pydocstyle",
    "summary": "Missing blank line before section (\"{name}\")",
    "message_formats": [
      "Missing blank line before section (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring sections that are separated by a blank line.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nDocstring sections should be separated by a blank line, for consistency and\ncompatibility with documentation tooling.\n\nThis rule is enabled when using the `numpy` and `google` conventions, and\ndisabled when using the `pep257` convention.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "blank-lines-between-header-and-content",
    "code": "D412",
    "linter": "pydocstyle",
    "summary": "No blank lines allowed between a section header and its content (\"{name}\")",
    "message_formats": [
      "No blank lines allowed between a section header and its content (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring sections that contain blank lines between the section\nheader and the section body.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nDocstring sections should not contain blank lines between the section header\nand the section body, for consistency.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "blank-line-after-last-section",
    "code": "D413",
    "linter": "pydocstyle",
    "summary": "Missing blank line after last section (\"{name}\")",
    "message_formats": [
      "Missing blank line after last section (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for missing blank lines after the last section of a multi-line\ndocstring.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nThe last section in a docstring should be separated by a blank line, for\nconsistency and compatibility with documentation tooling.\n\nThis rule is enabled when using the `numpy` convention, and disabled when\nusing the `pep257` and `google` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n"
  },
  {
    "name": "empty-docstring-section",
    "code": "D414",
    "linter": "pydocstyle",
    "summary": "Section has no content (\"{name}\")",
    "message_formats": [
      "Section has no content (\"{name}\")"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for docstrings that contain empty sections.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nEmpty docstring sections are indicative of missing documentation. Empty\nsections should either be removed or filled in with relevant documentation.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Parameters\n    ----------\n    distance : float\n        Distance traveled.\n    time : float\n        Time spent traveling.\n\n    Returns\n    -------\n    float\n        Speed as distance divided by time.\n\n    Raises\n    ------\n    FasterThanLightError\n        If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Style Guide](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "ends-in-punctuation",
    "code": "D415",
    "linter": "pydocstyle",
    "summary": "First line should end with a period, question mark, or exclamation point",
    "message_formats": [
      "First line should end with a period, question mark, or exclamation point"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstrings in which the first line does not end in a punctuation\nmark, such as a period, question mark, or exclamation point.\n\n## Why is this bad?\nThe first line of a docstring should end with a period, question mark, or\nexclamation point, for grammatical correctness and consistency.\n\nThis rule may not apply to all projects; its applicability is a matter of\nconvention. By default, this rule is enabled when using the `google`\nconvention, and disabled when using the `numpy` and `pep257` conventions.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "section-name-ends-in-colon",
    "code": "D416",
    "linter": "pydocstyle",
    "summary": "Section name should end with a colon (\"{name}\")",
    "message_formats": [
      "Section name should end with a colon (\"{name}\")"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for docstring section headers that do not end with a colon.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nIn a docstring, each section header should end with a colon, for\nconsistency.\n\nThis rule is enabled when using the `google` convention, and disabled when\nusing the `pep257` and `numpy` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns\n        Speed as distance divided by time.\n\n    Raises\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [Google Style Guide](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "undocumented-param",
    "code": "D417",
    "linter": "pydocstyle",
    "summary": "Missing argument description in the docstring: `{name}`",
    "message_formats": [
      "Missing argument description in the docstring: `{name}`",
      "Missing argument descriptions in the docstring: {names}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function docstrings that do not include documentation for all\nparameters in the function.\n\n## Why is this bad?\nMulti-line docstrings are typically composed of a summary line, followed by\na blank line, followed by a series of sections, each with a section header\nand a section body.\n\nFunction docstrings often include a section for function arguments, which\nshould include documentation for every argument. Undocumented arguments are\nindicative of missing documentation.\n\nThis rule is enabled when using the `google` convention, and disabled when\nusing the `pep257` and `numpy` conventions.\n\n## Example\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\nUse instead:\n```python\ndef calculate_speed(distance: float, time: float) -> float:\n    \"\"\"Calculate speed as distance divided by time.\n\n    Args:\n        distance: Distance traveled.\n        time: Time spent traveling.\n\n    Returns:\n        Speed as distance divided by time.\n\n    Raises:\n        FasterThanLightError: If speed is greater than the speed of light.\n    \"\"\"\n    try:\n        return distance / time\n    except ZeroDivisionError as exc:\n        raise FasterThanLightError from exc\n```\n\n## Options\n- `pydocstyle.convention`\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [PEP 287  reStructuredText Docstring Format](https://peps.python.org/pep-0287/)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "overload-with-docstring",
    "code": "D418",
    "linter": "pydocstyle",
    "summary": "Function decorated with `@overload` shouldn't contain a docstring",
    "message_formats": [
      "Function decorated with `@overload` shouldn't contain a docstring"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `@overload` function definitions that contain a docstring.\n\n## Why is this bad?\nThe `@overload` decorator is used to define multiple compatible signatures\nfor a given function, to support type-checking. A series of `@overload`\ndefinitions should be followed by a single non-decorated definition that\ncontains the implementation of the function.\n\n`@overload` function definitions should not contain a docstring; instead,\nthe docstring should be placed on the non-decorated definition that contains\nthe implementation.\n\n## Example\n```python\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\n@overload\ndef factorial(n: float) -> float:\n    \"\"\"Return the factorial of n.\"\"\"\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n```\n\nUse instead:\n```python\nfrom typing import overload\n\n\n@overload\ndef factorial(n: int) -> int:\n    ...\n\n\n@overload\ndef factorial(n: float) -> float:\n    ...\n\n\ndef factorial(n):\n    \"\"\"Return the factorial of n.\"\"\"\n\n\nfactorial.__doc__  # \"Return the factorial of n.\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [Python documentation: `typing.overload`](https://docs.python.org/3/library/typing.html#typing.overload)\n"
  },
  {
    "name": "empty-docstring",
    "code": "D419",
    "linter": "pydocstyle",
    "summary": "Docstring is empty",
    "message_formats": [
      "Docstring is empty"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for empty docstrings.\n\n## Why is this bad?\nAn empty docstring is indicative of incomplete documentation. It should either\nbe removed or replaced with a meaningful docstring.\n\n## Example\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"\"\"\"\n```\n\nUse instead:\n```python\ndef average(values: list[float]) -> float:\n    \"\"\"Return the mean of the given values.\"\"\"\n```\n\n## References\n- [PEP 257  Docstring Conventions](https://peps.python.org/pep-0257/)\n- [NumPy Style Guide](https://numpydoc.readthedocs.io/en/latest/format.html)\n- [Google Python Style Guide - Docstrings](https://google.github.io/styleguide/pyguide.html#38-comments-and-docstrings)\n"
  },
  {
    "name": "unused-import",
    "code": "F401",
    "linter": "Pyflakes",
    "summary": "`{name}` imported but unused; consider using `importlib.util.find_spec` to test for availability",
    "message_formats": [
      "`{name}` imported but unused; consider using `importlib.util.find_spec` to test for availability",
      "`{name}` imported but unused; consider adding to `__all__` or using a redundant alias",
      "`{name}` imported but unused"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for unused imports.\n\n## Why is this bad?\nUnused imports add a performance overhead at runtime, and risk creating\nimport cycles. They also increase the cognitive load of reading the code.\n\nIf an import statement is used to check for the availability or existence\nof a module, consider using `importlib.util.find_spec` instead.\n\n## Example\n```python\nimport numpy as np  # unused import\n\n\ndef area(radius):\n    return 3.14 * radius**2\n```\n\nUse instead:\n```python\ndef area(radius):\n    return 3.14 * radius**2\n```\n\nTo check the availability of a module, use `importlib.util.find_spec`:\n```python\nfrom importlib.util import find_spec\n\nif find_spec(\"numpy\") is not None:\n    print(\"numpy is installed\")\nelse:\n    print(\"numpy is not installed\")\n```\n\n## Options\n- `pyflakes.extend-generics`\n\n## References\n- [Python documentation: `import`](https://docs.python.org/3/reference/simple_stmts.html#the-import-statement)\n- [Python documentation: `importlib.util.find_spec`](https://docs.python.org/3/library/importlib.html#importlib.util.find_spec)\n"
  },
  {
    "name": "import-shadowed-by-loop-var",
    "code": "F402",
    "linter": "Pyflakes",
    "summary": "Import `{name}` from line {line} shadowed by loop variable",
    "message_formats": [
      "Import `{name}` from line {line} shadowed by loop variable"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for import bindings that are shadowed by loop variables.\n\n## Why is this bad?\nShadowing an import with loop variables makes the code harder to read and\nreason about, as the identify of the imported binding is no longer clear.\nIt's also often indicative of a mistake, as it's unlikely that the loop\nvariable is intended to be used as the imported binding.\n\nConsider using a different name for the loop variable.\n\n## Example\n```python\nfrom os import path\n\nfor path in files:\n    print(path)\n```\n\nUse instead:\n```python\nfrom os import path\n\n\nfor filename in files:\n    print(filename)\n```\n"
  },
  {
    "name": "undefined-local-with-import-star",
    "code": "F403",
    "linter": "Pyflakes",
    "summary": "`from {name} import *` used; unable to detect undefined names",
    "message_formats": [
      "`from {name} import *` used; unable to detect undefined names"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of wildcard imports.\n\n## Why is this bad?\nWildcard imports (e.g., `from module import *`) make it hard to determine\nwhich symbols are available in the current namespace, and from which module\nthey were imported. They're also discouraged by [PEP 8].\n\n## Example\n```python\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports\n"
  },
  {
    "name": "late-future-import",
    "code": "F404",
    "linter": "Pyflakes",
    "summary": "`from __future__` imports must occur at the beginning of the file",
    "message_formats": [
      "`from __future__` imports must occur at the beginning of the file"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__future__` imports that are not located at the beginning of a\nfile.\n\n## Why is this bad?\nImports from `__future__` must be placed the beginning of the file, before any\nother statements (apart from docstrings). The use of `__future__` imports\nelsewhere is invalid and will result in a `SyntaxError`.\n\n## Example\n```python\nfrom pathlib import Path\n\nfrom __future__ import annotations\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\nfrom pathlib import Path\n```\n\n## References\n- [Python documentation: Future statements](https://docs.python.org/3/reference/simple_stmts.html#future)\n"
  },
  {
    "name": "undefined-local-with-import-star-usage",
    "code": "F405",
    "linter": "Pyflakes",
    "summary": "`{name}` may be undefined, or defined from star imports: {sources}",
    "message_formats": [
      "`{name}` may be undefined, or defined from star imports: {sources}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for names that might be undefined, but may also be defined in a\nwildcard import.\n\n## Why is this bad?\nWildcard imports (e.g., `from module import *`) make it hard to determine\nwhich symbols are available in the current namespace. If a module contains\na wildcard import, and a name in the current namespace has not been\nexplicitly defined or imported, then it's unclear whether the name is\nundefined or was imported by the wildcard import.\n\nIf the name _is_ defined in via a wildcard import, that member should be\nimported explicitly to avoid confusion.\n\nIf the name is _not_ defined in a wildcard import, it should be defined or\nimported.\n\n## Example\n```python\nfrom math import *\n\n\ndef area(radius):\n    return pi * radius**2\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\ndef area(radius):\n    return pi * radius**2\n```\n"
  },
  {
    "name": "undefined-local-with-nested-import-star-usage",
    "code": "F406",
    "linter": "Pyflakes",
    "summary": "`from {name} import *` only allowed at module level",
    "message_formats": [
      "`from {name} import *` only allowed at module level"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for the use of wildcard imports outside of the module namespace.\n\n## Why is this bad?\nThe use of wildcard imports outside of the module namespace (e.g., within\nfunctions) can lead to confusion, as the import can shadow local variables.\n\nThough wildcard imports are discouraged by [PEP 8], when necessary, they\nshould be placed in the module namespace (i.e., at the top-level of a\nmodule).\n\n## Example\n```python\ndef foo():\n    from math import *\n```\n\nUse instead:\n```python\nfrom math import *\n\n\ndef foo():\n    ...\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#imports\n"
  },
  {
    "name": "future-feature-not-defined",
    "code": "F407",
    "linter": "Pyflakes",
    "summary": "Future feature `{name}` is not defined",
    "message_formats": [
      "Future feature `{name}` is not defined"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__future__` imports that are not defined in the current Python\nversion.\n\n## Why is this bad?\nImporting undefined or unsupported members from the `__future__` module is\na `SyntaxError`.\n\n## References\n- [Python documentation: `__future__`](https://docs.python.org/3/library/__future__.html)\n"
  },
  {
    "name": "percent-format-invalid-format",
    "code": "F501",
    "linter": "Pyflakes",
    "summary": "`%`-format string has invalid format string: {message}",
    "message_formats": [
      "`%`-format string has invalid format string: {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for invalid `printf`-style format strings.\n\n## Why is this bad?\nConversion specifiers are required for `printf`-style format strings. These\nspecifiers must contain a `%` character followed by a conversion type.\n\n## Example\n```python\n\"Hello, %\" % \"world\"\n```\n\nUse instead:\n```python\n\"Hello, %s\" % \"world\"\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-expected-mapping",
    "code": "F502",
    "linter": "Pyflakes",
    "summary": "`%`-format string expected mapping but got sequence",
    "message_formats": [
      "`%`-format string expected mapping but got sequence"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for named placeholders in `printf`-style format strings without\nmapping-type values.\n\n## Why is this bad?\nWhen using named placeholders in `printf`-style format strings, the values\nmust be a map type (such as a dictionary). Otherwise, the expression will\nraise a `TypeError`.\n\n## Example\n```python\n\"%(greeting)s, %(name)s\" % (\"Hello\", \"World\")\n```\n\nUse instead:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nOr:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-expected-sequence",
    "code": "F503",
    "linter": "Pyflakes",
    "summary": "`%`-format string expected sequence but got mapping",
    "message_formats": [
      "`%`-format string expected sequence but got mapping"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of mapping-type values in `printf`-style format strings\nwithout named placeholders.\n\n## Why is this bad?\nWhen using mapping-type values (such as `dict`) in `printf`-style format\nstrings, the keys must be named. Otherwise, the expression will raise a\n`TypeError`.\n\n## Example\n```python\n\"%s, %s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nUse instead:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nOr:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-extra-named-arguments",
    "code": "F504",
    "linter": "Pyflakes",
    "summary": "`%`-format string has unused named argument(s): {message}",
    "message_formats": [
      "`%`-format string has unused named argument(s): {message}"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unused mapping keys in `printf`-style format strings.\n\n## Why is this bad?\nUnused named placeholders in `printf`-style format strings are unnecessary,\nand likely indicative of a mistake. They should be removed.\n\n## Example\n```python\n\"Hello, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\nUse instead:\n```python\n\"Hello, %(name)s\" % {\"name\": \"World\"}\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-missing-argument",
    "code": "F505",
    "linter": "Pyflakes",
    "summary": "`%`-format string is missing argument(s) for placeholder(s): {message}",
    "message_formats": [
      "`%`-format string is missing argument(s) for placeholder(s): {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for named placeholders in `printf`-style format strings that are not\npresent in the provided mapping.\n\n## Why is this bad?\nNamed placeholders that lack a corresponding value in the provided mapping\nwill raise a `KeyError`.\n\n## Example\n```python\n\"%(greeting)s, %(name)s\" % {\"name\": \"world\"}\n```\n\nUse instead:\n```python\n\"Hello, %(name)s\" % {\"name\": \"world\"}\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-mixed-positional-and-named",
    "code": "F506",
    "linter": "Pyflakes",
    "summary": "`%`-format string has mixed positional and named placeholders",
    "message_formats": [
      "`%`-format string has mixed positional and named placeholders"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `printf`-style format strings that have mixed positional and\nnamed placeholders.\n\n## Why is this bad?\nPython does not support mixing positional and named placeholders in\n`printf`-style format strings. The use of mixed placeholders will raise a\n`TypeError` at runtime.\n\n## Example\n```python\n\"%s, %(name)s\" % (\"Hello\", {\"name\": \"World\"})\n```\n\nUse instead:\n```python\n\"%s, %s\" % (\"Hello\", \"World\")\n```\n\nOr:\n```python\n\"%(greeting)s, %(name)s\" % {\"greeting\": \"Hello\", \"name\": \"World\"}\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-positional-count-mismatch",
    "code": "F507",
    "linter": "Pyflakes",
    "summary": "`%`-format string has {wanted} placeholder(s) but {got} substitution(s)",
    "message_formats": [
      "`%`-format string has {wanted} placeholder(s) but {got} substitution(s)"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `printf`-style format strings that have a mismatch between the\nnumber of positional placeholders and the number of substitution values.\n\n## Why is this bad?\nWhen a `printf`-style format string is provided with too many or too few\nsubstitution values, it will raise a `TypeError` at runtime.\n\n## Example\n```python\n\"%s, %s\" % (\"Hello\", \"world\", \"!\")\n```\n\nUse instead:\n```python\n\"%s, %s\" % (\"Hello\", \"world\")\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-star-requires-sequence",
    "code": "F508",
    "linter": "Pyflakes",
    "summary": "`%`-format string `*` specifier requires sequence",
    "message_formats": [
      "`%`-format string `*` specifier requires sequence"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `printf`-style format strings that use the `*` specifier with\nnon-tuple values.\n\n## Why is this bad?\nThe use of the `*` specifier with non-tuple values will raise a\n`TypeError` at runtime.\n\n## Example\n```python\nfrom math import pi\n\n\"%(n).*f\" % {\"n\": (2, pi)}\n```\n\nUse instead:\n```python\nfrom math import pi\n\n\"%.*f\" % (2, pi)  # 3.14\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "percent-format-unsupported-format-character",
    "code": "F509",
    "linter": "Pyflakes",
    "summary": "`%`-format string has unsupported format character `{char}`",
    "message_formats": [
      "`%`-format string has unsupported format character `{char}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `printf`-style format strings with invalid format characters.\n\n## Why is this bad?\nIn `printf`-style format strings, the `%` character is used to indicate\nplaceholders. If a `%` character is not followed by a valid format\ncharacter, it will raise a `ValueError` at runtime.\n\n## Example\n```python\n\"Hello, %S\" % \"world\"\n```\n\nUse instead:\n```python\n\"Hello, %s\" % \"world\"\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#printf-style-string-formatting)\n"
  },
  {
    "name": "string-dot-format-invalid-format",
    "code": "F521",
    "linter": "Pyflakes",
    "summary": "`.format` call has invalid format string: {message}",
    "message_formats": [
      "`.format` call has invalid format string: {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `str.format` calls with invalid format strings.\n\n## Why is this bad?\nInvalid format strings will raise a `ValueError`.\n\n## Example\n```python\n\"{\".format(foo)\n```\n\nUse instead:\n```python\n\"{}\".format(foo)\n```\n\n## References\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "string-dot-format-extra-named-arguments",
    "code": "F522",
    "linter": "Pyflakes",
    "summary": "`.format` call has unused named argument(s): {message}",
    "message_formats": [
      "`.format` call has unused named argument(s): {message}"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `str.format` calls with unused keyword arguments.\n\n## Why is this bad?\nUnused keyword arguments are redundant, and often indicative of a mistake.\nThey should be removed.\n\n## Example\n```python\n\"Hello, {name}\".format(greeting=\"Hello\", name=\"World\")\n```\n\nUse instead:\n```python\n\"Hello, {name}\".format(name=\"World\")\n```\n\n## References\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "string-dot-format-extra-positional-arguments",
    "code": "F523",
    "linter": "Pyflakes",
    "summary": "`.format` call has unused arguments at position(s): {message}",
    "message_formats": [
      "`.format` call has unused arguments at position(s): {message}"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `str.format` calls with unused positional arguments.\n\n## Why is this bad?\nUnused positional arguments are redundant, and often indicative of a mistake.\nThey should be removed.\n\n## Example\n```python\n\"Hello, {0}\".format(\"world\", \"!\")\n```\n\nUse instead:\n```python\n\"Hello, {0}\".format(\"world\")\n```\n\n## References\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "string-dot-format-missing-arguments",
    "code": "F524",
    "linter": "Pyflakes",
    "summary": "`.format` call is missing argument(s) for placeholder(s): {message}",
    "message_formats": [
      "`.format` call is missing argument(s) for placeholder(s): {message}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `str.format` calls with placeholders that are missing arguments.\n\n## Why is this bad?\nIn `str.format` calls, omitting arguments for placeholders will raise a\n`KeyError` at runtime.\n\n## Example\n```python\n\"{greeting}, {name}\".format(name=\"World\")\n```\n\nUse instead:\n```python\n\"{greeting}, {name}\".format(greeting=\"Hello\", name=\"World\")\n```\n\n## References\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "string-dot-format-mixing-automatic",
    "code": "F525",
    "linter": "Pyflakes",
    "summary": "`.format` string mixes automatic and manual numbering",
    "message_formats": [
      "`.format` string mixes automatic and manual numbering"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `str.format` calls that mix automatic and manual numbering.\n\n## Why is this bad?\nIn `str.format` calls, mixing automatic and manual numbering will raise a\n`ValueError` at runtime.\n\n## Example\n```python\n\"{0}, {}\".format(\"Hello\", \"World\")\n```\n\nUse instead:\n```python\n\"{0}, {1}\".format(\"Hello\", \"World\")\n```\n\nOr:\n```python\n\"{}, {}\".format(\"Hello\", \"World\")\n```\n\n## References\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "f-string-missing-placeholders",
    "code": "F541",
    "linter": "Pyflakes",
    "summary": "f-string without any placeholders",
    "message_formats": [
      "f-string without any placeholders"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for f-strings that do not contain any placeholder expressions.\n\n## Why is this bad?\nF-strings are a convenient way to format strings, but they are not\nnecessary if there are no placeholder expressions to format. In this\ncase, a regular string should be used instead, as an f-string without\nplaceholders can be confusing for readers, who may expect such a\nplaceholder to be present.\n\nAn f-string without any placeholders could also indicate that the\nauthor forgot to add a placeholder expression.\n\n## Example\n```python\nf\"Hello, world!\"\n```\n\nUse instead:\n```python\n\"Hello, world!\"\n```\n\n## References\n- [PEP 498](https://www.python.org/dev/peps/pep-0498/)\n"
  },
  {
    "name": "multi-value-repeated-key-literal",
    "code": "F601",
    "linter": "Pyflakes",
    "summary": "Dictionary key literal `{name}` repeated",
    "message_formats": [
      "Dictionary key literal `{name}` repeated"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for dictionary literals that associate multiple values with the\nsame key.\n\n## Why is this bad?\nDictionary keys should be unique. If a key is associated with multiple values,\nthe earlier values will be overwritten. Including multiple values for the\nsame key in a dictionary literal is likely a mistake.\n\n## Example\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n    \"baz\": 3,\n}\nfoo[\"baz\"]  # 3\n```\n\nUse instead:\n```python\nfoo = {\n    \"bar\": 1,\n    \"baz\": 2,\n}\nfoo[\"baz\"]  # 2\n```\n\n## References\n- [Python documentation: Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\n"
  },
  {
    "name": "multi-value-repeated-key-variable",
    "code": "F602",
    "linter": "Pyflakes",
    "summary": "Dictionary key `{name}` repeated",
    "message_formats": [
      "Dictionary key `{name}` repeated"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for dictionary keys that are repeated with different values.\n\n## Why is this bad?\nDictionary keys should be unique. If a key is repeated with a different\nvalue, the first values will be overwritten and the key will correspond to\nthe last value. This is likely a mistake.\n\n## Example\n```python\nfoo = {\n    bar: 1,\n    baz: 2,\n    baz: 3,\n}\nfoo[baz]  # 3\n```\n\nUse instead:\n```python\nfoo = {\n    bar: 1,\n    baz: 2,\n}\nfoo[baz]  # 2\n```\n\n## References\n- [Python documentation: Dictionaries](https://docs.python.org/3/tutorial/datastructures.html#dictionaries)\n"
  },
  {
    "name": "expressions-in-star-assignment",
    "code": "F621",
    "linter": "Pyflakes",
    "summary": "Too many expressions in star-unpacking assignment",
    "message_formats": [
      "Too many expressions in star-unpacking assignment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of too many expressions in starred assignment statements.\n\n## Why is this bad?\nIn assignment statements, starred expressions can be used to unpack iterables.\n\nIn Python 3, no more than 1 << 8 assignments are allowed before a starred\nexpression, and no more than 1 << 24 expressions are allowed after a starred\nexpression.\n"
  },
  {
    "name": "multiple-starred-expressions",
    "code": "F622",
    "linter": "Pyflakes",
    "summary": "Two starred expressions in assignment",
    "message_formats": [
      "Two starred expressions in assignment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of multiple starred expressions in assignment statements.\n\n## Why is this bad?\nIn assignment statements, starred expressions can be used to unpack iterables.\nIncluding more than one starred expression on the left-hand-side of an\nassignment will cause a `SyntaxError`, as it is unclear which expression\nshould receive the remaining values.\n\n## Example\n```python\n*foo, *bar, baz = (1, 2, 3)\n```\n\n## References\n- [PEP 3132](https://peps.python.org/pep-3132/)\n"
  },
  {
    "name": "assert-tuple",
    "code": "F631",
    "linter": "Pyflakes",
    "summary": "Assert test is a non-empty tuple, which is always `True`",
    "message_formats": [
      "Assert test is a non-empty tuple, which is always `True`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `assert` statements that use non-empty tuples as test\nconditions.\n\n## Why is this bad?\nNon-empty tuples are always `True`, so an `assert` statement with a\nnon-empty tuple as its test condition will always pass. This is likely a\nmistake.\n\n## Example\n```python\nassert (some_condition,)\n```\n\nUse instead:\n```python\nassert some_condition\n```\n\n## References\n- [Python documentation: The `assert` statement](https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement)\n"
  },
  {
    "name": "is-literal",
    "code": "F632",
    "linter": "Pyflakes",
    "summary": "Use `==` to compare constant literals",
    "message_formats": [
      "Use `==` to compare constant literals",
      "Use `!=` to compare constant literals"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `is` and `is not` comparisons against constant literals, like\nintegers and strings.\n\n## Why is this bad?\nThe `is` and `is not` comparators operate on identity, in that they check\nwhether two objects are the same object. If the objects are not the same\nobject, the comparison will always be `False`. Using `is` and `is not` with\nconstant literals often works \"by accident\", but are not guaranteed to produce\nthe expected result.\n\nAs of Python 3.8, using `is` and `is not` with constant literals will produce\na `SyntaxWarning`.\n\nInstead, use `==` and `!=` to compare constant literals, which will compare\nthe values of the objects instead of their identities.\n\n## Example\n```python\nx = 200\nif x is 200:\n    print(\"It's 200!\")\n```\n\nUse instead:\n```python\nx = 200\nif x == 200:\n    print(\"It's 200!\")\n```\n\n## References\n- [Python documentation: Identity comparisons](https://docs.python.org/3/reference/expressions.html#is-not)\n- [Python documentation: Value comparisons](https://docs.python.org/3/reference/expressions.html#value-comparisons)\n- [_Why does Python log a SyntaxWarning for is with literals?_ by Adam Johnson](https://adamj.eu/tech/2020/01/21/why-does-python-3-8-syntaxwarning-for-is-literal/)\n"
  },
  {
    "name": "invalid-print-syntax",
    "code": "F633",
    "linter": "Pyflakes",
    "summary": "Use of `>>` is invalid with `print` function",
    "message_formats": [
      "Use of `>>` is invalid with `print` function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `print` statements that use the `>>` syntax.\n\n## Why is this bad?\nIn Python 2, the `print` statement can be used with the `>>` syntax to\nprint to a file-like object. This `print >> sys.stderr` syntax is\ndeprecated in Python 3.\n\nInstead, use the `file` keyword argument to the `print` function, the\n`sys.stderr.write` function, or the `logging` module.\n\n## Example\n```python\nfrom __future__ import print_function\nimport sys\n\nprint >> sys.stderr, \"Hello, world!\"\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\", file=sys.stderr)\n```\n\nOr:\n```python\nimport sys\n\nsys.stderr.write(\"Hello, world!\\n\")\n```\n\nOr:\n```python\nimport logging\n\nlogging.error(\"Hello, world!\")\n```\n\n## References\n- [Python documentation: `print`](https://docs.python.org/3/library/functions.html#print)\n"
  },
  {
    "name": "if-tuple",
    "code": "F634",
    "linter": "Pyflakes",
    "summary": "If test is a tuple, which is always `True`",
    "message_formats": [
      "If test is a tuple, which is always `True`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `if statements that use non-empty tuples as test conditions.\n\n## Why is this bad?\nNon-empty tuples are always `True`, so an `if` statement with a non-empty\ntuple as its test condition will always pass. This is likely a mistake.\n\n## Example\n```python\nif (False,):\n    print(\"This will always run\")\n```\n\nUse instead:\n```python\nif False:\n    print(\"This will never run\")\n```\n\n## References\n- [Python documentation: The `if` statement](https://docs.python.org/3/reference/compound_stmts.html#the-if-statement)\n"
  },
  {
    "name": "break-outside-loop",
    "code": "F701",
    "linter": "Pyflakes",
    "summary": "`break` outside loop",
    "message_formats": [
      "`break` outside loop"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `break` statements outside of loops.\n\n## Why is this bad?\nThe use of a `break` statement outside of a `for` or `while` loop will\nraise a `SyntaxError`.\n\n## Example\n```python\ndef foo():\n    break\n```\n\n## References\n- [Python documentation: `break`](https://docs.python.org/3/reference/simple_stmts.html#the-break-statement)\n"
  },
  {
    "name": "continue-outside-loop",
    "code": "F702",
    "linter": "Pyflakes",
    "summary": "`continue` not properly in loop",
    "message_formats": [
      "`continue` not properly in loop"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `continue` statements outside of loops.\n\n## Why is this bad?\nThe use of a `continue` statement outside of a `for` or `while` loop will\nraise a `SyntaxError`.\n\n## Example\n```python\ndef foo():\n    continue  # SyntaxError\n```\n\n## References\n- [Python documentation: `continue`](https://docs.python.org/3/reference/simple_stmts.html#the-continue-statement)\n"
  },
  {
    "name": "yield-outside-function",
    "code": "F704",
    "linter": "Pyflakes",
    "summary": "`{keyword}` statement outside of a function",
    "message_formats": [
      "`{keyword}` statement outside of a function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `yield` and `yield from` statements outside of functions.\n\n## Why is this bad?\nThe use of a `yield` or `yield from` statement outside of a function will\nraise a `SyntaxError`.\n\n## Example\n```python\nclass Foo:\n    yield 1\n```\n\n## References\n- [Python documentation: `yield`](https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement)\n"
  },
  {
    "name": "return-outside-function",
    "code": "F706",
    "linter": "Pyflakes",
    "summary": "`return` statement outside of a function/method",
    "message_formats": [
      "`return` statement outside of a function/method"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `return` statements outside of functions.\n\n## Why is this bad?\nThe use of a `return` statement outside of a function will raise a\n`SyntaxError`.\n\n## Example\n```python\nclass Foo:\n    return 1\n```\n\n## References\n- [Python documentation: `return`](https://docs.python.org/3/reference/simple_stmts.html#the-return-statement)\n"
  },
  {
    "name": "default-except-not-last",
    "code": "F707",
    "linter": "Pyflakes",
    "summary": "An `except` block as not the last exception handler",
    "message_formats": [
      "An `except` block as not the last exception handler"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `except` blocks that handle all exceptions, but are not the last\n`except` block in a `try` statement.\n\n## Why is this bad?\nWhen an exception is raised within a `try` block, the `except` blocks are\nevaluated in order, and the first matching block is executed. If an `except`\nblock handles all exceptions, but isn't the last block, Python will raise a\n`SyntaxError`, as the following blocks would never be executed.\n\n## Example\n```python\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except:\n        print(\"An exception occurred.\")\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    else:\n        return reciprocal\n```\n\nUse instead:\n```python\ndef reciprocal(n):\n    try:\n        reciprocal = 1 / n\n    except ZeroDivisionError:\n        print(\"Cannot divide by zero.\")\n    except:\n        print(\"An exception occurred.\")\n    else:\n        return reciprocal\n```\n\n## References\n- [Python documentation: `except` clause](https://docs.python.org/3/reference/compound_stmts.html#except-clause)\n"
  },
  {
    "name": "forward-annotation-syntax-error",
    "code": "F722",
    "linter": "Pyflakes",
    "summary": "Syntax error in forward annotation: `{body}`",
    "message_formats": [
      "Syntax error in forward annotation: `{body}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for forward annotations that include invalid syntax.\n\n\n## Why is this bad?\nIn Python, type annotations can be quoted as strings literals to enable\nreferences to types that have not yet been defined, known as \"forward\nreferences\".\n\nHowever, these quoted annotations must be valid Python expressions. The use\nof invalid syntax in a quoted annotation won't raise a `SyntaxError`, but\nwill instead raise an error when type checking is performed.\n\n## Example\n```python\ndef foo() -> \"/\":\n    ...\n```\n\n## References\n- [PEP 563](https://www.python.org/dev/peps/pep-0563/)\n"
  },
  {
    "name": "redefined-while-unused",
    "code": "F811",
    "linter": "Pyflakes",
    "summary": "Redefinition of unused `{name}` from line {line}",
    "message_formats": [
      "Redefinition of unused `{name}` from line {line}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for variable definitions that redefine (or \"shadow\") unused\nvariables.\n\n## Why is this bad?\nRedefinitions of unused names are unnecessary and often indicative of a\nmistake.\n\n## Example\n```python\nimport foo\nimport bar\nimport foo  # Redefinition of unused `foo` from line 1\n```\n\nUse instead:\n```python\nimport foo\nimport bar\n```\n"
  },
  {
    "name": "undefined-name",
    "code": "F821",
    "linter": "Pyflakes",
    "summary": "Undefined name `{name}`",
    "message_formats": [
      "Undefined name `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of undefined names.\n\n## Why is this bad?\nAn undefined name is likely to raise `NameError` at runtime.\n\n## Example\n```python\ndef double():\n    return n * 2  # raises `NameError` if `n` is undefined when `double` is called\n```\n\nUse instead:\n```python\ndef double(n):\n    return n * 2\n```\n\n## References\n- [Python documentation: Naming and binding](https://docs.python.org/3/reference/executionmodel.html#naming-and-binding)\n"
  },
  {
    "name": "undefined-export",
    "code": "F822",
    "linter": "Pyflakes",
    "summary": "Undefined name `{name}` in `__all__`",
    "message_formats": [
      "Undefined name `{name}` in `__all__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undefined names in `__all__`.\n\n## Why is this bad?\nIn Python, the `__all__` variable is used to define the names that are\nexported when a module is imported as a wildcard (e.g.,\n`from foo import *`). The names in `__all__` must be defined in the module,\nbut are included as strings.\n\nIncluding an undefined name in `__all__` is likely to raise `NameError` at\nruntime, when the module is imported.\n\n## Example\n```python\nfrom foo import bar\n\n\n__all__ = [\"bar\", \"baz\"]  # undefined name `baz` in `__all__`\n```\n\nUse instead:\n```python\nfrom foo import bar, baz\n\n\n__all__ = [\"bar\", \"baz\"]\n```\n\n## References\n- [Python documentation: `__all__`](https://docs.python.org/3/tutorial/modules.html#importing-from-a-package)\n"
  },
  {
    "name": "undefined-local",
    "code": "F823",
    "linter": "Pyflakes",
    "summary": "Local variable `{name}` referenced before assignment",
    "message_formats": [
      "Local variable `{name}` referenced before assignment"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for undefined local variables.\n\n## Why is this bad?\nReferencing a local variable before it has been assigned will raise\nan `UnboundLocalError` at runtime.\n\n## Example\n```python\nx = 1\n\n\ndef foo():\n    x += 1\n```\n\nUse instead:\n```python\nx = 1\n\n\ndef foo():\n    global x\n    x += 1\n```\n"
  },
  {
    "name": "unused-variable",
    "code": "F841",
    "linter": "Pyflakes",
    "summary": "Local variable `{name}` is assigned to but never used",
    "message_formats": [
      "Local variable `{name}` is assigned to but never used"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the presence of unused variables in function scopes.\n\n## Why is this bad?\nA variable that is defined but not used is likely a mistake, and should\nbe removed to avoid confusion.\n\nIf a variable is intentionally defined-but-not-used, it should be\nprefixed with an underscore, or some other value that adheres to the\n[`dummy-variable-rgx`] pattern.\n\n## Example\n```python\ndef foo():\n    x = 1\n    y = 2\n    return x\n```\n\nUse instead:\n```python\ndef foo():\n    x = 1\n    return x\n```\n\n## Options\n- `dummy-variable-rgx`\n"
  },
  {
    "name": "unused-annotation",
    "code": "F842",
    "linter": "Pyflakes",
    "summary": "Local variable `{name}` is annotated but never used",
    "message_formats": [
      "Local variable `{name}` is annotated but never used"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for local variables that are annotated but never used.\n\n## Why is this bad?\nAnnotations are used to provide type hints to static type checkers. If a\nvariable is annotated but never used, the annotation is unnecessary.\n\n## Example\n```python\ndef foo():\n    bar: int\n```\n\n## References\n- [PEP 484](https://peps.python.org/pep-0484/)\n"
  },
  {
    "name": "raise-not-implemented",
    "code": "F901",
    "linter": "Pyflakes",
    "summary": "`raise NotImplemented` should be `raise NotImplementedError`",
    "message_formats": [
      "`raise NotImplemented` should be `raise NotImplementedError`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `raise` statements that raise `NotImplemented`.\n\n## Why is this bad?\n`NotImplemented` is an exception used by binary special methods to indicate\nthat an operation is not implemented with respect to a particular type.\n\n`NotImplemented` should not be raised directly. Instead, raise\n`NotImplementedError`, which is used to indicate that the method is\nabstract or not implemented in the derived class.\n\n## Example\n```python\nclass Foo:\n    def bar(self):\n        raise NotImplemented\n```\n\nUse instead:\n```python\nclass Foo:\n    def bar(self):\n        raise NotImplementedError\n```\n\n## References\n- [Python documentation: `NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented)\n- [Python documentation: `NotImplementedError`](https://docs.python.org/3/library/exceptions.html#NotImplementedError)\n"
  },
  {
    "name": "eval",
    "code": "PGH001",
    "linter": "pygrep-hooks",
    "summary": "No builtin `eval()` allowed",
    "message_formats": [
      "No builtin `eval()` allowed"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of the builtin `eval()` function.\n\n## Why is this bad?\nThe `eval()` function is insecure as it enables arbitrary code execution.\n\n## Example\n```python\ndef foo():\n    x = eval(input(\"Enter a number: \"))\n    ...\n```\n\nUse instead:\n```python\ndef foo():\n    x = input(\"Enter a number: \")\n    ...\n```\n\n## References\n- [Python documentation: `eval`](https://docs.python.org/3/library/functions.html#eval)\n- [_Eval really is dangerous_ by Ned Batchelder](https://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html)\n"
  },
  {
    "name": "deprecated-log-warn",
    "code": "PGH002",
    "linter": "pygrep-hooks",
    "summary": "`warn` is deprecated in favor of `warning`",
    "message_formats": [
      "`warn` is deprecated in favor of `warning`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for usages of the deprecated `warn` method from the `logging` module.\n\n## Why is this bad?\nThe `warn` method is deprecated. Use `warning` instead.\n\n## Example\n```python\nimport logging\n\n\ndef foo():\n    logging.warn(\"Something happened\")\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef foo():\n    logging.warning(\"Something happened\")\n```\n\n## References\n- [Python documentation: `logger.Logger.warning`](https://docs.python.org/3/library/logging.html#logging.Logger.warning)\n"
  },
  {
    "name": "blanket-type-ignore",
    "code": "PGH003",
    "linter": "pygrep-hooks",
    "summary": "Use specific rule codes when ignoring type issues",
    "message_formats": [
      "Use specific rule codes when ignoring type issues"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for `type: ignore` annotations that suppress all type warnings, as\nopposed to targeting specific type warnings.\n\n## Why is this bad?\nSuppressing all warnings can hide issues in the code.\n\nBlanket `type: ignore` annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which warnings are intended\nto be suppressed.\n\n## Example\n```python\nfrom foo import secrets  # type: ignore\n```\n\nUse instead:\n```python\nfrom foo import secrets  # type: ignore[attr-defined]\n```\n\n## References\n- [mypy](https://mypy.readthedocs.io/en/stable/common_issues.html#spurious-errors-and-locally-silencing-the-checker)\n"
  },
  {
    "name": "blanket-noqa",
    "code": "PGH004",
    "linter": "pygrep-hooks",
    "summary": "Use specific rule codes when using `noqa`",
    "message_formats": [
      "Use specific rule codes when using `noqa`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nCheck for `noqa` annotations that suppress all diagnostics, as opposed to\ntargeting specific diagnostics.\n\n## Why is this bad?\nSuppressing all diagnostics can hide issues in the code.\n\nBlanket `noqa` annotations are also more difficult to interpret and\nmaintain, as the annotation does not clarify which diagnostics are intended\nto be suppressed.\n\n## Example\n```python\nfrom .base import *  # noqa\n```\n\nUse instead:\n```python\nfrom .base import *  # noqa: F403\n```\n\n## References\n- [Ruff documentation](https://beta.ruff.rs/docs/configuration/#error-suppression)\n"
  },
  {
    "name": "invalid-mock-access",
    "code": "PGH005",
    "linter": "pygrep-hooks",
    "summary": "Mock method should be called: `{name}`",
    "message_formats": [
      "Mock method should be called: `{name}`",
      "Non-existent mock method: `{name}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for common mistakes when using mock objects.\n\n## Why is this bad?\nThe `mock` module exposes an assertion API that can be used to verify that\nmock objects undergo expected interactions. This rule checks for common\nmistakes when using this API.\n\nFor example, it checks for mock attribute accesses that should be replaced\nwith mock method calls.\n\n## Example\n```python\nmy_mock.assert_called\n```\n\nUse instead:\n```python\nmy_mock.assert_called()\n```\n"
  },
  {
    "name": "single-string-slots",
    "code": "PLC0205",
    "linter": "Pylint",
    "summary": "Class `__slots__` should be a non-string iterable",
    "message_formats": [
      "Class `__slots__` should be a non-string iterable"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for single strings assigned to `__slots__`.\n\n## Why is this bad?\nIn Python, the `__slots__` attribute allows you to explicitly define the\nattributes (instance variables) that a class can have. By default, Python\nuses a dictionary to store an object's attributes, which incurs some memory\noverhead. However, when `__slots__` is defined, Python uses a more compact\ninternal structure to store the object's attributes, resulting in memory\nsavings.\n\nAny string iterable may be assigned to `__slots__` (most commonly, a\n`tuple` of strings). If a string is assigned to `__slots__`, it is\ninterpreted as a single attribute name, rather than an iterable of attribute\nnames. This can cause confusion, as users that iterate over the `__slots__`\nvalue may expect to iterate over a sequence of attributes, but would instead\niterate over the characters of the string.\n\nTo use a single string attribute in `__slots__`, wrap the string in an\niterable container type, like a `tuple`.\n\n## Example\n```python\nclass Person:\n    __slots__: str = \"name\"\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n```\n\nUse instead:\n```python\nclass Person:\n    __slots__: tuple[str, ...] = (\"name\",)\n\n    def __init__(self, name: str) -> None:\n        self.name = name\n```\n\n## References\n- [Python documentation: `__slots__`](https://docs.python.org/3/reference/datamodel.html#slots)\n"
  },
  {
    "name": "iteration-over-set",
    "code": "PLC0208",
    "linter": "Pylint",
    "summary": "Use a sequence type instead of a `set` when iterating over values",
    "message_formats": [
      "Use a sequence type instead of a `set` when iterating over values"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for iterations over `set` literals.\n\n## Why is this bad?\nIterating over a `set` is less efficient than iterating over a sequence\ntype, like `list` or `tuple`.\n\n## Example\n```python\nfor number in {1, 2, 3}:\n    ...\n```\n\nUse instead:\n```python\nfor number in (1, 2, 3):\n    ...\n```\n\n## References\n- [Python documentation: `set`](https://docs.python.org/3/library/stdtypes.html#set)\n"
  },
  {
    "name": "useless-import-alias",
    "code": "PLC0414",
    "linter": "Pylint",
    "summary": "Import alias does not rename original package",
    "message_formats": [
      "Import alias does not rename original package"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for import aliases that do not rename the original package.\n\n## Why is this bad?\nThe import alias is redundant and should be removed to avoid confusion.\n\n## Example\n```python\nimport numpy as numpy\n```\n\nUse instead:\n```python\nimport numpy as np\n```\n"
  },
  {
    "name": "compare-to-empty-string",
    "code": "PLC1901",
    "linter": "Pylint",
    "summary": "`{existing}` can be simplified to `{replacement}` as an empty string is falsey",
    "message_formats": [
      "`{existing}` can be simplified to `{replacement}` as an empty string is falsey"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons to empty strings.\n\n## Why is this bad?\nAn empty string is falsy, so it is unnecessary to compare it to `\"\"`. If\nthe value can be something else Python considers falsy, such as `None` or\n`0` or another empty container, then the code is not equivalent.\n\n## Example\n```python\ndef foo(x):\n    if x == \"\":\n        print(\"x is empty\")\n```\n\nUse instead:\n```python\ndef foo(x):\n    if not x:\n        print(\"x is empty\")\n```\n\n## References\n- [Python documentation: Truth Value Testing](https://docs.python.org/3/library/stdtypes.html#truth-value-testing)\n"
  },
  {
    "name": "unnecessary-direct-lambda-call",
    "code": "PLC3002",
    "linter": "Pylint",
    "summary": "Lambda expression called directly. Execute the expression inline instead.",
    "message_formats": [
      "Lambda expression called directly. Execute the expression inline instead."
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for unnecessary direct calls to lambda expressions.\n\n## Why is this bad?\nCalling a lambda expression directly is unnecessary. The expression can be\nexecuted inline instead to improve readability.\n\n## Example\n```python\narea = (lambda r: 3.14 * r**2)(radius)\n```\n\nUse instead:\n```python\narea = 3.14 * radius**2\n```\n\n## References\n- [Python documentation: Lambdas](https://docs.python.org/3/reference/expressions.html#lambda)\n"
  },
  {
    "name": "yield-in-init",
    "code": "PLE0100",
    "linter": "Pylint",
    "summary": "`__init__` method is a generator",
    "message_formats": [
      "`__init__` method is a generator"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__init__` methods that are turned into generators by the\ninclusion of `yield` or `yield from` expressions.\n\n## Why is this bad?\nThe `__init__` method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\nThe `__init__` method has to return `None`. By including a `yield` or\n`yield from` expression in an `__init__`, the method will return a\ngenerator object when called at runtime, resulting in a runtime error.\n\n## Example\n```python\nclass InitIsGenerator:\n    def __init__(self, i):\n        yield i\n```\n\n## References\n- [CodeQL: `py-init-method-is-generator`](https://codeql.github.com/codeql-query-help/python/py-init-method-is-generator/)\n"
  },
  {
    "name": "return-in-init",
    "code": "PLE0101",
    "linter": "Pylint",
    "summary": "Explicit return in `__init__`",
    "message_formats": [
      "Explicit return in `__init__`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__init__` methods that return values.\n\n## Why is this bad?\nThe `__init__` method is the constructor for a given Python class,\nresponsible for initializing, rather than creating, new objects.\n\nThe `__init__` method has to return `None`. Returning any value from\nan `__init__` method will result in a runtime error.\n\n## Example\n```python\nclass Example:\n    def __init__(self):\n        return []\n```\n\nUse instead:\n```python\nclass Example:\n    def __init__(self):\n        self.value = []\n```\n\n## References\n- [CodeQL: `py-explicit-return-in-init`](https://codeql.github.com/codeql-query-help/python/py-explicit-return-in-init/)\n"
  },
  {
    "name": "continue-in-finally",
    "code": "PLE0116",
    "linter": "Pylint",
    "summary": "`continue` not supported inside `finally` clause",
    "message_formats": [
      "`continue` not supported inside `finally` clause"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `continue` statements inside `finally`\n\n## Why is this bad?\n`continue` statements were not allowed within `finally` clauses prior to\nPython 3.8. Using a `continue` statement within a `finally` clause can\ncause a `SyntaxError`.\n\n## Example\n```python\nwhile True:\n    try:\n        pass\n    finally:\n        continue\n```\n\nUse instead:\n```python\nwhile True:\n    try:\n        pass\n    except Exception:\n        pass\n    else:\n        continue\n```\n\n## Options\n- `target-version`\n"
  },
  {
    "name": "nonlocal-without-binding",
    "code": "PLE0117",
    "linter": "Pylint",
    "summary": "Nonlocal name `{name}` found without binding",
    "message_formats": [
      "Nonlocal name `{name}` found without binding"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `nonlocal` names without bindings.\n\n## Why is this bad?\n`nonlocal` names must be bound to a name in an outer scope.\n\n## Example\n```python\nclass Foo:\n    def get_bar(self):\n        nonlocal bar\n        ...\n```\n\nUse instead:\n```python\nclass Foo:\n    bar = 1\n\n    def get_bar(self):\n        nonlocal bar\n        ...\n```\n\n## References\n- [Python documentation: The `nonlocal` statement](https://docs.python.org/3/reference/simple_stmts.html#nonlocal)\n- [PEP 3104](https://peps.python.org/pep-3104/)\n"
  },
  {
    "name": "load-before-global-declaration",
    "code": "PLE0118",
    "linter": "Pylint",
    "summary": "Name `{name}` is used prior to global declaration on line {line}",
    "message_formats": [
      "Name `{name}` is used prior to global declaration on line {line}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of names that are declared as `global` prior to the\nrelevant `global` declaration.\n\n## Why is this bad?\nThe `global` declaration applies to the entire scope. Using a name that's\ndeclared as `global` in a given scope prior to the relevant `global`\ndeclaration is a syntax error.\n\n## Example\n```python\ncounter = 1\n\n\ndef increment():\n    print(f\"Adding 1 to {counter}\")\n    global counter\n    counter += 1\n```\n\nUse instead:\n```python\ncounter = 1\n\n\ndef increment():\n    global counter\n    print(f\"Adding 1 to {counter}\")\n    counter += 1\n```\n\n## References\n- [Python documentation: The `global` statement](https://docs.python.org/3/reference/simple_stmts.html#the-global-statement)\n"
  },
  {
    "name": "duplicate-bases",
    "code": "PLE0241",
    "linter": "Pylint",
    "summary": "Duplicate base `{base}` for class `{class}`",
    "message_formats": [
      "Duplicate base `{base}` for class `{class}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for duplicate base classes in class definitions.\n\n## Why is this bad?\nIncluding duplicate base classes will raise a `TypeError` at runtime.\n\n## Example\n```python\nclass Foo:\n    pass\n\n\nclass Bar(Foo, Foo):\n    pass\n```\n\nUse instead:\n```python\nclass Foo:\n    pass\n\n\nclass Bar(Foo):\n    pass\n```\n\n## References\n- [Python documentation: Class definitions](https://docs.python.org/3/reference/compound_stmts.html#class-definitions)\n"
  },
  {
    "name": "unexpected-special-method-signature",
    "code": "PLE0302",
    "linter": "Pylint",
    "summary": "The special method `{}` expects {}, {} {} given",
    "message_formats": [
      "The special method `{}` expects {}, {} {} given"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for \"special\" methods that have an unexpected method signature.\n\n## Why is this bad?\n\"Special\" methods, like `__len__`, are expected to adhere to a specific,\nstandard function signature. Implementing a \"special\" method using a\nnon-standard function signature can lead to unexpected and surprising\nbehavior for users of a given class.\n\n## Example\n```python\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self, index):  # __len__ does not except an index parameter\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n```\n\nUse instead:\n```python\nclass Bookshelf:\n    def __init__(self):\n        self._books = [\"Foo\", \"Bar\", \"Baz\"]\n\n    def __len__(self):\n        return len(self._books)\n\n    def __getitem__(self, index):\n        return self._books[index]\n```\n\n## References\n- [Python documentation: Data model](https://docs.python.org/3/reference/datamodel.html)\n"
  },
  {
    "name": "invalid-str-return-type",
    "code": "PLE0307",
    "linter": "Pylint",
    "summary": "`__str__` does not return `str`",
    "message_formats": [
      "`__str__` does not return `str`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `__str__` implementations that return a type other than `str`.\n\n## Why is this bad?\nThe `__str__` method should return a `str` object. Returning a different\ntype may cause unexpected behavior.\n"
  },
  {
    "name": "invalid-all-object",
    "code": "PLE0604",
    "linter": "Pylint",
    "summary": "Invalid object in `__all__`, must contain only strings",
    "message_formats": [
      "Invalid object in `__all__`, must contain only strings"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the inclusion of invalid objects in `__all__`.\n\n## Why is this bad?\nIn Python, `__all__` should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\nAssigning anything other than a `tuple` or `list` of strings to `__all__`\nis invalid.\n\n## Example\n```python\n__all__ = [Foo, 1, None]\n```\n\nUse instead:\n```python\n__all__ = [\"Foo\", \"Bar\", \"Baz\"]\n```\n\n## References\n- [Python documentation: The `import` statement](https://docs.python.org/3/reference/simple_stmts.html#the-import-statement)\n"
  },
  {
    "name": "invalid-all-format",
    "code": "PLE0605",
    "linter": "Pylint",
    "summary": "Invalid format for `__all__`, must be `tuple` or `list`",
    "message_formats": [
      "Invalid format for `__all__`, must be `tuple` or `list`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for invalid assignments to `__all__`.\n\n## Why is this bad?\nIn Python, `__all__` should contain a sequence of strings that represent\nthe names of all \"public\" symbols exported by a module.\n\nAssigning anything other than a `tuple` or `list` of strings to `__all__`\nis invalid.\n\n## Example\n```python\n__all__ = \"Foo\"\n```\n\nUse instead:\n```python\n__all__ = (\"Foo\",)\n```\n\n## References\n- [Python documentation: The `import` statement](https://docs.python.org/3/reference/simple_stmts.html#the-import-statement)\n"
  },
  {
    "name": "await-outside-async",
    "code": "PLE1142",
    "linter": "Pylint",
    "summary": "`await` should be used within an async function",
    "message_formats": [
      "`await` should be used within an async function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `await` outside of `async` functions.\n\n## Why is this bad?\nUsing `await` outside of an `async` function is a syntax error.\n\n## Example\n```python\nimport asyncio\n\n\ndef foo():\n    await asyncio.sleep(1)\n```\n\nUse instead:\n```python\nimport asyncio\n\n\nasync def foo():\n    await asyncio.sleep(1)\n```\n\n## References\n- [Python documentation: Await expression](https://docs.python.org/3/reference/expressions.html#await)\n- [PEP 492](https://peps.python.org/pep-0492/#await-expression)\n"
  },
  {
    "name": "logging-too-many-args",
    "code": "PLE1205",
    "linter": "Pylint",
    "summary": "Too many arguments for `logging` format string",
    "message_formats": [
      "Too many arguments for `logging` format string"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for too many positional arguments for a `logging` format string.\n\n## Why is this bad?\nA `TypeError` will be raised if the statement is run.\n\n## Example\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"Error occurred: %s\", type(e), e)\n    raise\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n```\n"
  },
  {
    "name": "logging-too-few-args",
    "code": "PLE1206",
    "linter": "Pylint",
    "summary": "Not enough arguments for `logging` format string",
    "message_formats": [
      "Not enough arguments for `logging` format string"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for too few positional arguments for a `logging` format string.\n\n## Why is this bad?\nA `TypeError` will be raised if the statement is run.\n\n## Example\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", e)\n    raise\n```\n\nUse instead:\n```python\nimport logging\n\ntry:\n    function()\nexcept Exception as e:\n    logging.error(\"%s error occurred: %s\", type(e), e)\n    raise\n```\n"
  },
  {
    "name": "bad-string-format-type",
    "code": "PLE1307",
    "linter": "Pylint",
    "summary": "Format type does not match argument type",
    "message_formats": [
      "Format type does not match argument type"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for mismatched argument types in \"old-style\" format strings.\n\n## Why is this bad?\nThe format string is not checked at compile time, so it is easy to\nintroduce bugs by mistyping the format string.\n\n## Example\n```python\nprint(\"%d\" % \"1\")\n```\n\nUse instead:\n```python\nprint(\"%d\" % 1)\n```\n"
  },
  {
    "name": "bad-str-strip-call",
    "code": "PLE1310",
    "linter": "Pylint",
    "summary": "String `{strip}` call contains duplicate characters (did you mean `{removal}`?)",
    "message_formats": [
      "String `{strip}` call contains duplicate characters (did you mean `{removal}`?)",
      "String `{strip}` call contains duplicate characters"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks duplicate characters in `str#strip` calls.\n\n## Why is this bad?\nAll characters in `str#strip` calls are removed from both the leading and\ntrailing ends of the string. Including duplicate characters in the call\nis redundant and often indicative of a mistake.\n\nIn Python 3.9 and later, you can use `str#removeprefix` and\n`str#removesuffix` to remove an exact prefix or suffix from a string,\nrespectively, which should be preferred when possible.\n\n## Example\n```python\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"bar baz \")\n```\n\nUse instead:\n```python\n# Evaluates to \"foo\".\n\"bar foo baz\".strip(\"abrz \")  # \"foo\"\n```\n\nOr:\n```python\n# Evaluates to \"foo\".\n\"bar foo baz\".removeprefix(\"bar \").removesuffix(\" baz\")\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `str.strip`](https://docs.python.org/3/library/stdtypes.html?highlight=strip#str.strip)\n"
  },
  {
    "name": "invalid-envvar-value",
    "code": "PLE1507",
    "linter": "Pylint",
    "summary": "Invalid type for initial `os.getenv` argument; expected `str`",
    "message_formats": [
      "Invalid type for initial `os.getenv` argument; expected `str`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `os.getenv` calls with an invalid `key` argument.\n\n## Why is this bad?\n`os.getenv` only supports strings as the first argument (`key`).\n\nIf the provided argument is not a string, `os.getenv` will throw a\n`TypeError` at runtime.\n\n## Example\n```python\nos.getenv(1)\n```\n\nUse instead:\n```python\nos.getenv(\"1\")\n```\n"
  },
  {
    "name": "yield-from-in-async-function",
    "code": "PLE1700",
    "linter": "Pylint",
    "summary": "`yield from` statement in async function; use `async for` instead",
    "message_formats": [
      "`yield from` statement in async function; use `async for` instead"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `yield from` in async functions.\n\n## Why is this bad?\nPython doesn't support the use of `yield from` in async functions, and will\nraise a `SyntaxError` in such cases.\n\nInstead, considering refactoring the code to use an `async for` loop instead.\n\n## Example\n```python\nasync def numbers():\n    yield from [1, 2, 3, 4, 5]\n```\n\nUse instead:\n```python\nasync def numbers():\n    async for number in [1, 2, 3, 4, 5]:\n        yield number\n```\n"
  },
  {
    "name": "bidirectional-unicode",
    "code": "PLE2502",
    "linter": "Pylint",
    "summary": "Contains control characters that can permit obfuscated code",
    "message_formats": [
      "Contains control characters that can permit obfuscated code"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for bidirectional unicode characters.\n\n## Why is this bad?\nThe interaction between bidirectional unicode characters and the\nsurrounding code can be surprising to those that are unfamiliar\nwith right-to-left writing systems.\n\nIn some cases, bidirectional unicode characters can also be used to\nobfuscate code and introduce or mask security vulnerabilities.\n\n## Example\n```python\ns = \"\" * 100  #  \"\" is assigned\nprint(s)  # prints a 100-character string\n```\n\n## References\n- [PEP 672](https://peps.python.org/pep-0672/#bidirectional-text)\n"
  },
  {
    "name": "invalid-character-backspace",
    "code": "PLE2510",
    "linter": "Pylint",
    "summary": "Invalid unescaped character backspace, use \"\\b\" instead",
    "message_formats": [
      "Invalid unescaped character backspace, use \"\\b\" instead"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that contain the control character `BS`.\n\n## Why is this bad?\nControl characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\b` sequence in lieu of the `BS` control character, the\nstring will contain the same value, but will render visibly in all editors.\n\n## Example\n```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\b\"\n```\n"
  },
  {
    "name": "invalid-character-sub",
    "code": "PLE2512",
    "linter": "Pylint",
    "summary": "Invalid unescaped character SUB, use \"\\x1A\" instead",
    "message_formats": [
      "Invalid unescaped character SUB, use \"\\x1A\" instead"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that contain the raw control character `SUB`.\n\n## Why is this bad?\nControl characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\x1A` sequence in lieu of the `SUB` control character, the\nstring will contain the same value, but will render visibly in all editors.\n\n## Example\n```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\x1A\"\n```\n"
  },
  {
    "name": "invalid-character-esc",
    "code": "PLE2513",
    "linter": "Pylint",
    "summary": "Invalid unescaped character ESC, use \"\\x1B\" instead",
    "message_formats": [
      "Invalid unescaped character ESC, use \"\\x1B\" instead"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that contain the raw control character `ESC`.\n\n## Why is this bad?\nControl characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\x1B` sequence in lieu of the `SUB` control character, the\nstring will contain the same value, but will render visibly in all editors.\n\n## Example\n```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\x1B\"\n```\n"
  },
  {
    "name": "invalid-character-nul",
    "code": "PLE2514",
    "linter": "Pylint",
    "summary": "Invalid unescaped character NUL, use \"\\0\" instead",
    "message_formats": [
      "Invalid unescaped character NUL, use \"\\0\" instead"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that contain the raw control character `NUL` (0 byte).\n\n## Why is this bad?\nControl characters are displayed differently by different text editors and\nterminals.\n\nBy using the `\\0` sequence in lieu of the `NUL` control character, the\nstring will contain the same value, but will render visibly in all editors.\n\n## Example\n```python\nx = \"\"\n```\n\nUse instead:\n```python\nx = \"\\0\"\n```\n"
  },
  {
    "name": "invalid-character-zero-width-space",
    "code": "PLE2515",
    "linter": "Pylint",
    "summary": "Invalid unescaped character zero-width-space, use \"\\u200B\" instead",
    "message_formats": [
      "Invalid unescaped character zero-width-space, use \"\\u200B\" instead"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for strings that contain the zero width space character.\n\n## Why is this bad?\nThis character is rendered invisibly in some text editors and terminals.\n\nBy using the `\\u200B` sequence, the string will contain the same value,\nbut will render visibly in all editors.\n\n## Example\n```python\nx = \"Dear Sir/Madam\"\n```\n\nUse instead:\n```python\nx = \"Dear Sir\\u200B/\\u200BMadam\"  # zero width space\n```\n"
  },
  {
    "name": "comparison-with-itself",
    "code": "PLR0124",
    "linter": "Pylint",
    "summary": "Name compared with itself, consider replacing `{left} {} {right}`",
    "message_formats": [
      "Name compared with itself, consider replacing `{left} {} {right}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for operations that compare a name to itself.\n\n## Why is this bad?\nComparing a name to itself always results in the same value, and is likely\na mistake.\n\n## Example\n```python\nfoo == foo\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n"
  },
  {
    "name": "comparison-of-constant",
    "code": "PLR0133",
    "linter": "Pylint",
    "summary": "Two constants compared in a comparison, consider replacing `{left_constant} {} {right_constant}`",
    "message_formats": [
      "Two constants compared in a comparison, consider replacing `{left_constant} {} {right_constant}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for comparisons between constants.\n\n## Why is this bad?\nComparing two constants will always resolve to the same value, so the\ncomparison is redundant. Instead, the expression should be replaced\nwith the result of the comparison.\n\n## Example\n```python\nfoo = 1 == 1\n```\n\nUse instead:\n```python\nfoo = True\n```\n\n## References\n- [Python documentation: Comparisons](https://docs.python.org/3/reference/expressions.html#comparisons)\n"
  },
  {
    "name": "property-with-parameters",
    "code": "PLR0206",
    "linter": "Pylint",
    "summary": "Cannot have defined parameters for properties",
    "message_formats": [
      "Cannot have defined parameters for properties"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for property definitions that accept function parameters.\n\n## Why is this bad?\nProperties cannot be called with parameters.\n\nIf you need to pass parameters to a property, create a method with the\ndesired parameters and call that method instead.\n\n## Example\n```python\nclass Cat:\n    @property\n    def purr(self, volume):\n        ...\n```\n\nUse instead:\n```python\nclass Cat:\n    @property\n    def purr(self):\n        ...\n\n    def purr_volume(self, volume):\n        ...\n```\n\n## References\n- [Python documentation: `property`](https://docs.python.org/3/library/functions.html#property)\n"
  },
  {
    "name": "manual-from-import",
    "code": "PLR0402",
    "linter": "Pylint",
    "summary": "Use `from {module} import {name}` in lieu of alias",
    "message_formats": [
      "Use `from {module} import {name}` in lieu of alias"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for submodule imports that are aliased to the submodule name.\n\n## Why is this bad?\nUsing the `from` keyword to import the submodule is more concise and\nreadable.\n\n## Example\n```python\nimport concurrent.futures as futures\n```\n\nUse instead:\n```python\nfrom concurrent import futures\n```\n\n## References\n- [Python documentation: Submodules](https://docs.python.org/3/reference/import.html#submodules)\n"
  },
  {
    "name": "too-many-return-statements",
    "code": "PLR0911",
    "linter": "Pylint",
    "summary": "Too many return statements ({returns} > {max_returns})",
    "message_formats": [
      "Too many return statements ({returns} > {max_returns})"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions or methods with too many return statements.\n\nBy default, this rule allows up to six return statements, as configured by\nthe `pylint.max-returns` option.\n\n## Why is this bad?\nFunctions or methods with many return statements are harder to understand\nand maintain, and often indicative of complex logic.\n\n## Example\n```python\ndef capital(country: str) -> str | None:\n    if country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    else:\n        return None\n```\n\nUse instead:\n```python\ndef capital(country: str) -> str | None:\n    capitals = {\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n    }\n    return capitals.get(country)\n```\n\n## Options\n- `pylint.max-returns`\n"
  },
  {
    "name": "too-many-branches",
    "code": "PLR0912",
    "linter": "Pylint",
    "summary": "Too many branches ({branches} > {max_branches})",
    "message_formats": [
      "Too many branches ({branches} > {max_branches})"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions or methods with too many branches.\n\nBy default, this rule allows up to 12 branches. This can be configured\nusing the `max-branches` option.\n\n## Why is this bad?\nFunctions or methods with many branches are harder to understand\nand maintain than functions or methods with fewer branches.\n\n## Example\n```python\ndef capital(country):\n    if country == \"Australia\":\n        return \"Canberra\"\n    elif country == \"Brazil\":\n        return \"Brasilia\"\n    elif country == \"Canada\":\n        return \"Ottawa\"\n    elif country == \"England\":\n        return \"London\"\n    elif country == \"France\":\n        return \"Paris\"\n    elif country == \"Germany\":\n        return \"Berlin\"\n    elif country == \"Poland\":\n        return \"Warsaw\"\n    elif country == \"Romania\":\n        return \"Bucharest\"\n    elif country == \"Spain\":\n        return \"Madrid\"\n    elif country == \"Thailand\":\n        return \"Bangkok\"\n    elif country == \"Turkey\":\n        return \"Ankara\"\n    elif country == \"United States\":\n        return \"Washington\"\n    else:\n        return \"Unknown\"  # 13th branch\n```\n\nUse instead:\n```python\ndef capital(country):\n    capitals = {\n        \"Australia\": \"Canberra\",\n        \"Brazil\": \"Brasilia\",\n        \"Canada\": \"Ottawa\",\n        \"England\": \"London\",\n        \"France\": \"Paris\",\n        \"Germany\": \"Berlin\",\n        \"Poland\": \"Warsaw\",\n        \"Romania\": \"Bucharest\",\n        \"Spain\": \"Madrid\",\n        \"Thailand\": \"Bangkok\",\n        \"Turkey\": \"Ankara\",\n        \"United States\": \"Washington\",\n    }\n    city = capitals.get(country, \"Unknown\")\n    return city\n```\n\n## References\n- [Ruff configuration documentation](https://beta.ruff.rs/docs/settings/#max-branches)\n"
  },
  {
    "name": "too-many-arguments",
    "code": "PLR0913",
    "linter": "Pylint",
    "summary": "Too many arguments to function call ({c_args} > {max_args})",
    "message_formats": [
      "Too many arguments to function call ({c_args} > {max_args})"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function definitions that include too many arguments.\n\nBy default, this rule allows up to five arguments, as configured by the\n`pylint.max-args` option.\n\n## Why is this bad?\nFunctions with many arguments are harder to understand, maintain, and call.\nConsider refactoring functions with many arguments into smaller functions\nwith fewer arguments, or using objects to group related arguments.\n\n## Example\n```python\ndef calculate_position(x_pos, y_pos, z_pos, x_vel, y_vel, z_vel, time):\n    new_x = x_pos + x_vel * time\n    new_y = y_pos + y_vel * time\n    new_z = z_pos + z_vel * time\n    return new_x, new_y, new_z\n```\n\nUse instead:\n```python\nfrom typing import NamedTuple\n\n\nclass Vector(NamedTuple):\n    x: float\n    y: float\n    z: float\n\n\ndef calculate_position(pos: Vector, vel: Vector, time: float) -> Vector:\n    return Vector(*(p + v * time for p, v in zip(pos, vel)))\n```\n\n## Options\n- `pylint.max-args`\n"
  },
  {
    "name": "too-many-statements",
    "code": "PLR0915",
    "linter": "Pylint",
    "summary": "Too many statements ({statements} > {max_statements})",
    "message_formats": [
      "Too many statements ({statements} > {max_statements})"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for functions or methods with too many statements.\n\nBy default, this rule allows up to 50 statements, as configured by the\n`pylint.max-statements` option.\n\n## Why is this bad?\nFunctions or methods with many statements are harder to understand\nand maintain.\n\nInstead, consider refactoring the function or method into smaller\nfunctions or methods, or identifying generalizable patterns and\nreplacing them with generic logic or abstractions.\n\n## Example\n```python\ndef is_even(number: int) -> bool:\n    if number == 0:\n        return True\n    elif number == 1:\n        return False\n    elif number == 2:\n        return True\n    elif number == 3:\n        return False\n    elif number == 4:\n        return True\n    elif number == 5:\n        return False\n    else:\n        ...\n```\n\nUse instead:\n```python\ndef is_even(number: int) -> bool:\n    return number % 2 == 0\n```\n\n## Options\n- `pylint.max-statements`\n"
  },
  {
    "name": "repeated-isinstance-calls",
    "code": "PLR1701",
    "linter": "Pylint",
    "summary": "Merge `isinstance` calls: `{expr}`",
    "message_formats": [
      "Merge `isinstance` calls: `{expr}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for repeated `isinstance` calls on the same object.\n\n## Why is this bad?\nRepeated `isinstance` calls on the same object can be merged into a\nsingle call.\n\n## Example\n```python\ndef is_number(x):\n    return isinstance(x, int) or isinstance(x, float) or isinstance(x, complex)\n```\n\nUse instead:\n```python\ndef is_number(x):\n    return isinstance(x, (int, float, complex))\n```\n\nOr, for Python 3.10 and later:\n\n```python\ndef is_number(x):\n    return isinstance(x, int | float | complex)\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `isinstance`](https://docs.python.org/3/library/functions.html#isinstance)\n"
  },
  {
    "name": "useless-return",
    "code": "PLR1711",
    "linter": "Pylint",
    "summary": "Useless `return` statement at end of function",
    "message_formats": [
      "Useless `return` statement at end of function"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for functions that end with an unnecessary `return` or\n`return None`, and contain no other `return` statements.\n\n## Why is this bad?\nPython implicitly assumes a `None` return at the end of a function, making\nit unnecessary to explicitly write `return None`.\n\n## Example\n```python\ndef f():\n    print(5)\n    return None\n```\n\nUse instead:\n```python\ndef f():\n    print(5)\n```\n"
  },
  {
    "name": "sys-exit-alias",
    "code": "PLR1722",
    "linter": "Pylint",
    "summary": "Use `sys.exit()` instead of `{name}`",
    "message_formats": [
      "Use `sys.exit()` instead of `{name}`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of the `exit()` and `quit()`.\n\n## Why is this bad?\n`exit` and `quit` come from the `site` module, which is typically imported\nautomatically during startup. However, it is not _guaranteed_ to be\nimported, and so using these functions may result in a `NameError` at\nruntime. Generally, these constants are intended to be used in an interactive\ninterpreter, and not in programs.\n\nPrefer `sys.exit()`, as the `sys` module is guaranteed to exist in all\ncontexts.\n\n## Example\n```python\nif __name__ == \"__main__\":\n    exit()\n```\n\nUse instead:\n```python\nimport sys\n\nif __name__ == \"__main__\":\n    sys.exit()\n```\n\n## References\n- [Python documentation: Constants added by the `site` module](https://docs.python.org/3/library/constants.html#constants-added-by-the-site-module)\n"
  },
  {
    "name": "magic-value-comparison",
    "code": "PLR2004",
    "linter": "Pylint",
    "summary": "Magic value used in comparison, consider replacing {value} with a constant variable",
    "message_formats": [
      "Magic value used in comparison, consider replacing {value} with a constant variable"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of unnamed numerical constants (\"magic\") values in\ncomparisons.\n\n## Why is this bad?\nThe use of \"magic\" values can make code harder to read and maintain, as\nreaders will have to infer the meaning of the value from the context.\nSuch values are discouraged by [PEP 8].\n\nFor convenience, this rule excludes a variety of common values from the\n\"magic\" value definition, such as `0`, `1`, `\"\"`, and `\"__main__\"`.\n\n## Example\n```python\ndef calculate_discount(price: float) -> float:\n    return price * (1 - 0.2)\n```\n\nUse instead:\n```python\nDISCOUNT_RATE = 0.2\n\n\ndef calculate_discount(price: float) -> float:\n    return price * (1 - DISCOUNT_RATE)\n```\n\n[PEP 8]: https://peps.python.org/pep-0008/#constants\n"
  },
  {
    "name": "collapsible-else-if",
    "code": "PLR5501",
    "linter": "Pylint",
    "summary": "Use `elif` instead of `else` then `if`, to reduce indentation",
    "message_formats": [
      "Use `elif` instead of `else` then `if`, to reduce indentation"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` blocks that consist of a single `if` statement.\n\n## Why is this bad?\nIf an `else` block contains a single `if` statement, it can be collapsed\ninto an `elif`, thus reducing the indentation level.\n\n## Example\n```python\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    else:\n        if value < 0:\n            print(\"Number is negative.\")\n        else:\n            print(\"Number is zero.\")\n```\n\nUse instead:\n```python\ndef check_sign(value: int) -> None:\n    if value > 0:\n        print(\"Number is positive.\")\n    elif value < 0:\n        print(\"Number is negative.\")\n    else:\n        print(\"Number is zero.\")\n```\n\n## References\n- [Python documentation: `if` Statements](https://docs.python.org/3/tutorial/controlflow.html#if-statements)\n"
  },
  {
    "name": "useless-else-on-loop",
    "code": "PLW0120",
    "linter": "Pylint",
    "summary": "`else` clause on loop without a `break` statement; remove the `else` and de-indent all the code inside it",
    "message_formats": [
      "`else` clause on loop without a `break` statement; remove the `else` and de-indent all the code inside it"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `else` clauses on loops without a `break` statement.\n\n## Why is this bad?\nWhen a loop includes an `else` statement, the code inside the `else` clause\nwill be executed if the loop terminates \"normally\" (i.e., without a\n`break`).\n\nIf a loop _always_ terminates \"normally\" (i.e., does _not_ contain a\n`break`), then the `else` clause is redundant, as the code inside the\n`else` clause will always be executed.\n\nIn such cases, the code inside the `else` clause can be moved outside the\nloop entirely, and the `else` clause can be removed.\n\n## Example\n```python\nfor item in items:\n    print(item)\nelse:\n    print(\"All items printed\")\n```\n\nUse instead:\n```python\nfor item in items:\n    print(item)\nprint(\"All items printed\")\n```\n\n## References\n- [Python documentation: `break` and `continue` Statements, and `else` Clauses on Loops](https://docs.python.org/3/tutorial/controlflow.html#break-and-continue-statements-and-else-clauses-on-loops)\n"
  },
  {
    "name": "assert-on-string-literal",
    "code": "PLW0129",
    "linter": "Pylint",
    "summary": "Asserting on an empty string literal will never pass",
    "message_formats": [
      "Asserting on an empty string literal will never pass",
      "Asserting on a non-empty string literal will always pass",
      "Asserting on a string literal may have unintended results"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `assert` statements that use a string literal as the first\nargument.\n\n## Why is this bad?\nAn `assert` on a non-empty string literal will always pass, while an\n`assert` on an empty string literal will always fail.\n\n## Example\n```python\nassert \"always true\"\n```\n"
  },
  {
    "name": "named-expr-without-context",
    "code": "PLW0131",
    "linter": "Pylint",
    "summary": "Named expression used without context",
    "message_formats": [
      "Named expression used without context"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of named expressions (e.g., `a := 42`) that can be\nreplaced by regular assignment statements (e.g., `a = 42`).\n\n## Why is this bad?\nWhile a top-level named expression is syntactically and semantically valid,\nit's less clear than a regular assignment statement. Named expressions are\nintended to be used in comprehensions and generator expressions, where\nassignment statements are not allowed.\n\n## Example\n```python\n(a := 42)\n```\n\nUse instead:\n```python\na = 42\n```\n"
  },
  {
    "name": "import-self",
    "code": "PLW0406",
    "linter": "Pylint",
    "summary": "Module `{name}` imports itself",
    "message_formats": [
      "Module `{name}` imports itself"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for import statements that import the current module.\n\n## Why is this bad?\nImporting a module from itself is a circular dependency.\n\n## Example\n```python\n# file: this_file.py\nfrom this_file import foo\n\n\ndef foo():\n    ...\n```\n"
  },
  {
    "name": "global-variable-not-assigned",
    "code": "PLW0602",
    "linter": "Pylint",
    "summary": "Using global for `{name}` but no assignment is done",
    "message_formats": [
      "Using global for `{name}` but no assignment is done"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `global` variables that are not assigned a value in the current\nscope.\n\n## Why is this bad?\nThe `global` keyword allows an inner scope to modify a variable declared\nin the outer scope. If the variable is not modified within the inner scope,\nthere is no need to use `global`.\n\n## Example\n```python\nDEBUG = True\n\n\ndef foo():\n    global DEBUG\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n```\n\nUse instead:\n```python\nDEBUG = True\n\n\ndef foo():\n    if DEBUG:\n        print(\"foo() called\")\n    ...\n```\n\n## References\n- [Python documentation: The `global` statement](https://docs.python.org/3/reference/simple_stmts.html#the-global-statement)\n"
  },
  {
    "name": "global-statement",
    "code": "PLW0603",
    "linter": "Pylint",
    "summary": "Using the global statement to update `{name}` is discouraged",
    "message_formats": [
      "Using the global statement to update `{name}` is discouraged"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for the use of `global` statements to update identifiers.\n\n## Why is this bad?\nPylint discourages the use of `global` variables as global mutable\nstate is a common source of bugs and confusing behavior.\n\n## Example\n```python\nvar = 1\n\n\ndef foo():\n    global var  # [global-statement]\n    var = 10\n    print(var)\n\n\nfoo()\nprint(var)\n```\n\nUse instead:\n```python\nvar = 1\n\n\ndef foo():\n    print(var)\n    return 10\n\n\nvar = foo()\nprint(var)\n```\n"
  },
  {
    "name": "binary-op-exception",
    "code": "PLW0711",
    "linter": "Pylint",
    "summary": "Exception to catch is the result of a binary `and` operation",
    "message_formats": [
      "Exception to catch is the result of a binary `and` operation",
      "Exception to catch is the result of a binary `or` operation"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `except` clauses that attempt to catch multiple\nexceptions with a binary operation (`and` or `or`).\n\n## Why is this bad?\nA binary operation will not catch multiple exceptions. Instead, the binary\noperation will be evaluated first, and the result of _that_ operation will\nbe caught (for an `or` operation, this is typically the first exception in\nthe list). This is almost never the desired behavior.\n\n## Example\n```python\ntry:\n    pass\nexcept A or B:\n    pass\n```\n\nUse instead:\n```python\ntry:\n    pass\nexcept (A, B):\n    pass\n```\n"
  },
  {
    "name": "invalid-envvar-default",
    "code": "PLW1508",
    "linter": "Pylint",
    "summary": "Invalid type for environment variable default; expected `str` or `None`",
    "message_formats": [
      "Invalid type for environment variable default; expected `str` or `None`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `env.getenv` calls with invalid default values.\n\n## Why is this bad?\nIf an environment variable is set, `env.getenv` will return its value as\na string. If the environment variable is _not_ set, `env.getenv` will\nreturn `None`, or the default value if one is provided.\n\nIf the default value is not a string or `None`, then it will be\ninconsistent with the return type of `env.getenv`, which can lead to\nconfusing behavior.\n\n## Example\n```python\nint(env.getenv(\"FOO\", 1))\n```\n\nUse instead:\n```python\nint(env.getenv(\"FOO\", \"1\"))\n```\n"
  },
  {
    "name": "redefined-loop-name",
    "code": "PLW2901",
    "linter": "Pylint",
    "summary": "Outer {outer_kind} variable `{name}` overwritten by inner {inner_kind} target",
    "message_formats": [
      "Outer {outer_kind} variable `{name}` overwritten by inner {inner_kind} target",
      "{outer_kind} variable `{name}` overwritten by {inner_kind} target"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for variables defined in `for` loops and `with` statements that\nget overwritten within the body, for example by another `for` loop or\n`with` statement or by direct assignment.\n\n## Why is this bad?\nRedefinition of a loop variable inside the loop's body causes its value\nto differ from the original loop iteration for the remainder of the\nblock, in a way that will likely cause bugs.\n\nIn Python, unlike many other languages, `for` loops and `with`\nstatements don't define their own scopes. Therefore, a nested loop that\nuses the same target variable name as an outer loop will reuse the same\nactual variable, and the value from the last iteration will \"leak out\"\ninto the remainder of the enclosing loop.\n\nWhile this mistake is easy to spot in small examples, it can be hidden\nin larger blocks of code where the definition and redefinition of the\nvariable may not be visible at the same time.\n\n## Example\n```python\nfor i in range(10):\n    i = 9\n    print(i)  # prints 9 every iteration\n\nfor i in range(10):\n    for i in range(10):  # original value overwritten\n        pass\n    print(i)  # also prints 9 every iteration\n\nwith path1.open() as f:\n    with path2.open() as f:\n        f = path2.open()\n    print(f.readline())  # prints a line from path2\n```\n"
  },
  {
    "name": "nested-min-max",
    "code": "PLW3301",
    "linter": "Pylint",
    "summary": "Nested `{}` calls can be flattened",
    "message_formats": [
      "Nested `{}` calls can be flattened"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for nested `min` and `max` calls.\n\n## Why is this bad?\nNested `min` and `max` calls can be flattened into a single call to improve\nreadability.\n\n## Example\n```python\nminimum = min(1, 2, min(3, 4, 5))\nmaximum = max(1, 2, max(3, 4, 5))\ndiff = maximum - minimum\n```\n\nUse instead:\n```python\nminimum = min(1, 2, 3, 4, 5)\nmaximum = max(1, 2, 3, 4, 5)\ndiff = maximum - minimum\n```\n\n## References\n- [Python documentation: `min`](https://docs.python.org/3/library/functions.html#min)\n- [Python documentation: `max`](https://docs.python.org/3/library/functions.html#max)\n"
  },
  {
    "name": "useless-metaclass-type",
    "code": "UP001",
    "linter": "pyupgrade",
    "summary": "`__metaclass__ = type` is implied",
    "message_formats": [
      "`__metaclass__ = type` is implied"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the use of `__metaclass__ = type` in class definitions.\n\n## Why is this bad?\nSince Python 3, `__metaclass__ = type` is implied and can thus be omitted.\n\n## Example\n```python\nclass Foo:\n    __metaclass__ = type\n```\n\nUse instead:\n```python\nclass Foo:\n    ...\n```\n\n## References\n- [PEP 3115](https://www.python.org/dev/peps/pep-3115/)\n"
  },
  {
    "name": "type-of-primitive",
    "code": "UP003",
    "linter": "pyupgrade",
    "summary": "Use `{}` instead of `type(...)`",
    "message_formats": [
      "Use `{}` instead of `type(...)`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of `type` that take a primitive as an argument.\n\n## Why is this bad?\n`type()` returns the type of a given object. A type of a primitive can\nalways be known in advance and accessed directly, which is more concise\nand explicit than using `type()`.\n\n## Example\n```python\ntype(1)\n```\n\nUse instead:\n```python\nint\n```\n\n## References\n- [Python documentation: `type()`](https://docs.python.org/3/library/functions.html#type)\n- [Python documentation: Built-in types](https://docs.python.org/3/library/stdtypes.html)\n"
  },
  {
    "name": "useless-object-inheritance",
    "code": "UP004",
    "linter": "pyupgrade",
    "summary": "Class `{name}` inherits from `object`",
    "message_formats": [
      "Class `{name}` inherits from `object`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for classes that inherit from `object`.\n\n## Why is this bad?\nSince Python 3, all classes inherit from `object` by default, so `object` can\nbe omitted from the list of base classes.\n\n## Example\n```python\nclass Foo(object):\n    ...\n```\n\nUse instead:\n```python\nclass Foo:\n    ...\n```\n\n## References\n- [PEP 3115](https://www.python.org/dev/peps/pep-3115/)\n"
  },
  {
    "name": "deprecated-unittest-alias",
    "code": "UP005",
    "linter": "pyupgrade",
    "summary": "`{alias}` is deprecated, use `{target}`",
    "message_formats": [
      "`{alias}` is deprecated, use `{target}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of deprecated methods from the `unittest` module.\n\n## Why is this bad?\nThe `unittest` module has deprecated aliases for some of its methods.\nThe aliases may be removed in future versions of Python. Instead,\nuse their non-deprecated counterparts.\n\n## Example\n```python\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEquals(1, 1)\n```\n\nUse instead:\n```python\nfrom unittest import TestCase\n\n\nclass SomeTest(TestCase):\n    def test_something(self):\n        self.assertEqual(1, 1)\n```\n\n## References\n- [Python documentation: Deprecated aliases](https://docs.python.org/3/library/unittest.html#deprecated-aliases)\n"
  },
  {
    "name": "non-pep585-annotation",
    "code": "UP006",
    "linter": "pyupgrade",
    "summary": "Use `{to}` instead of `{from}` for type annotation",
    "message_formats": [
      "Use `{to}` instead of `{from}` for type annotation"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the use of generics that can be replaced with standard library\nvariants based on [PEP 585].\n\n## Why is this bad?\n[PEP 585] enabled collections in the Python standard library (like `list`)\nto be used as generics directly, instead of importing analogous members\nfrom the `typing` module (like `typing.List`).\n\nWhen available, the [PEP 585] syntax should be used instead of importing\nmembers from the `typing` module, as it's more concise and readable.\nImporting those members from `typing` is considered deprecated as of PEP\n585.\n\n## Example\n```python\nfrom typing import List\n\nfoo: List[int] = [1, 2, 3]\n```\n\nUse instead:\n```python\nfoo: list[int] = [1, 2, 3]\n```\n\n## Options\n- `target-version`\n\n[PEP 585]: https://peps.python.org/pep-0585/\n"
  },
  {
    "name": "non-pep604-annotation",
    "code": "UP007",
    "linter": "pyupgrade",
    "summary": "Use `X | Y` for type annotations",
    "message_formats": [
      "Use `X | Y` for type annotations"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nCheck for type annotations that can be rewritten based on [PEP 604] syntax.\n\n## Why is this bad?\n[PEP 604] introduced a new syntax for union type annotations based on the\n`|` operator. This syntax is more concise and readable than the previous\n`typing.Union` and `typing.Optional` syntaxes.\n\n## Example\n```python\nfrom typing import Union\n\nfoo: Union[int, str] = 1\n```\n\nUse instead:\n```python\nfoo: int | str = 1\n```\n\n## Options\n- `target-version`\n\n[PEP 604]: https://peps.python.org/pep-0604/\n"
  },
  {
    "name": "super-call-with-parameters",
    "code": "UP008",
    "linter": "pyupgrade",
    "summary": "Use `super()` instead of `super(__class__, self)`",
    "message_formats": [
      "Use `super()` instead of `super(__class__, self)`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `super` calls that pass redundant arguments.\n\n## Why is this bad?\nIn Python 3, `super` can be invoked without any arguments when: (1) the\nfirst argument is `__class__`, and (2) the second argument is equivalent to\nthe first argument of the enclosing method.\n\nWhen possible, omit the arguments to `super` to make the code more concise\nand maintainable.\n\n## Example\n```python\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super(B, self).foo()\n```\n\nUse instead:\n```python\nclass A:\n    def foo(self):\n        pass\n\n\nclass B(A):\n    def bar(self):\n        super().foo()\n```\n\n## References\n- [Python documentation: `super`](https://docs.python.org/3/library/functions.html#super)\n- [super/MRO, Python's most misunderstood feature.](https://www.youtube.com/watch?v=X1PQ7zzltz4)\n"
  },
  {
    "name": "utf8-encoding-declaration",
    "code": "UP009",
    "linter": "pyupgrade",
    "summary": "UTF-8 encoding declaration is unnecessary",
    "message_formats": [
      "UTF-8 encoding declaration is unnecessary"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary UTF-8 encoding declarations.\n\n## Why is this bad?\n[PEP 3120] makes UTF-8 the default encoding, so a UTF-8 encoding\ndeclaration is unnecessary.\n\n## Example\n```python\n# -*- coding: utf-8 -*-\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```\n\n[PEP 3120]: https://peps.python.org/pep-3120/\n"
  },
  {
    "name": "unnecessary-future-import",
    "code": "UP010",
    "linter": "pyupgrade",
    "summary": "Unnecessary `__future__` import `{import}` for target Python version",
    "message_formats": [
      "Unnecessary `__future__` import `{import}` for target Python version",
      "Unnecessary `__future__` imports {imports} for target Python version"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary `__future__` imports.\n\n## Why is this bad?\nThe `__future__` module is used to enable features that are not yet\navailable in the current Python version. If a feature is already\navailable in the minimum supported Python version, importing it\nfrom `__future__` is unnecessary and should be removed to avoid\nconfusion.\n\n## Example\n```python\nfrom __future__ import print_function\n\nprint(\"Hello, world!\")\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `__future__`  Future statement definitions](https://docs.python.org/3/library/__future__.html)\n"
  },
  {
    "name": "lru-cache-without-parameters",
    "code": "UP011",
    "linter": "pyupgrade",
    "summary": "Unnecessary parentheses to `functools.lru_cache`",
    "message_formats": [
      "Unnecessary parentheses to `functools.lru_cache`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary parentheses on `functools.lru_cache` decorators.\n\n## Why is this bad?\nSince Python 3.8, `functools.lru_cache` can be used as a decorator without\ntrailing parentheses, as long as no arguments are passed to it.\n\n## Example\n```python\nimport functools\n\n\n@functools.lru_cache()\ndef foo():\n    ...\n```\n\nUse instead:\n```python\nimport functools\n\n\n@functools.lru_cache\ndef foo():\n    ...\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `@functools.lru_cache`](https://docs.python.org/3/library/functools.html#functools.lru_cache)\n- [Let lru_cache be used as a decorator with no arguments](https://github.com/python/cpython/issues/80953)\n"
  },
  {
    "name": "unnecessary-encode-utf8",
    "code": "UP012",
    "linter": "pyupgrade",
    "summary": "Unnecessary call to `encode` as UTF-8",
    "message_formats": [
      "Unnecessary call to `encode` as UTF-8"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary calls to `encode` as UTF-8.\n\n## Why is this bad?\nUTF-8 is the default encoding in Python, so there is no need to call\n`encode` when UTF-8 is the desired encoding. Instead, use a bytes literal.\n\n## Example\n```python\n\"foo\".encode(\"utf-8\")\n```\n\nUse instead:\n```python\nb\"foo\"\n```\n\n## References\n- [Python documentation: `str.encode`](https://docs.python.org/3/library/stdtypes.html#str.encode)\n"
  },
  {
    "name": "convert-typed-dict-functional-to-class",
    "code": "UP013",
    "linter": "pyupgrade",
    "summary": "Convert `{name}` from `TypedDict` functional to class syntax",
    "message_formats": [
      "Convert `{name}` from `TypedDict` functional to class syntax"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `TypedDict` declarations that use functional syntax.\n\n## Why is this bad?\n`TypedDict` subclasses can be defined either through a functional syntax\n(`Foo = TypedDict(...)`) or a class syntax (`class Foo(TypedDict): ...`).\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax.\n\n## Example\n```python\nfrom typing import TypedDict\n\nFoo = TypedDict(\"Foo\", {\"a\": int, \"b\": str})\n```\n\nUse instead:\n```python\nfrom typing import TypedDict\n\n\nclass Foo(TypedDict):\n    a: int\n    b: str\n```\n\n## References\n- [Python documentation: `typing.TypedDict`](https://docs.python.org/3/library/typing.html#typing.TypedDict)\n"
  },
  {
    "name": "convert-named-tuple-functional-to-class",
    "code": "UP014",
    "linter": "pyupgrade",
    "summary": "Convert `{name}` from `NamedTuple` functional to class syntax",
    "message_formats": [
      "Convert `{name}` from `NamedTuple` functional to class syntax"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for `NamedTuple` declarations that use functional syntax.\n\n## Why is this bad?\n`NamedTuple` subclasses can be defined either through a functional syntax\n(`Foo = NamedTuple(...)`) or a class syntax (`class Foo(NamedTuple): ...`).\n\nThe class syntax is more readable and generally preferred over the\nfunctional syntax, which exists primarily for backwards compatibility\nwith `collections.namedtuple`.\n\n## Example\n```python\nfrom typing import NamedTuple\n\nFoo = NamedTuple(\"Foo\", [(\"a\", int), (\"b\", str)])\n```\n\nUse instead:\n```python\nfrom typing import NamedTuple\n\n\nclass Foo(NamedTuple):\n    a: int\n    b: str\n```\n\n## References\n- [Python documentation: `typing.NamedTuple`](https://docs.python.org/3/library/typing.html#typing.NamedTuple)\n"
  },
  {
    "name": "redundant-open-modes",
    "code": "UP015",
    "linter": "pyupgrade",
    "summary": "Unnecessary open mode parameters",
    "message_formats": [
      "Unnecessary open mode parameters",
      "Unnecessary open mode parameters, use \"{replacement}\""
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for redundant `open` mode parameters.\n\n## Why is this bad?\nRedundant `open` mode parameters are unnecessary and should be removed to\navoid confusion.\n\n## Example\n```python\nwith open(\"foo.txt\", \"r\") as f:\n    ...\n```\n\nUse instead:\n```python\nwith open(\"foo.txt\") as f:\n    ...\n```\n\n## References\n- [Python documentation: `open`](https://docs.python.org/3/library/functions.html#open)\n"
  },
  {
    "name": "datetime-timezone-utc",
    "code": "UP017",
    "linter": "pyupgrade",
    "summary": "Use `datetime.UTC` alias",
    "message_formats": [
      "Use `datetime.UTC` alias"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of `datetime.timezone.utc`.\n\n## Why is this bad?\nAs of Python 3.11, `datetime.UTC` is an alias for `datetime.timezone.utc`.\nThe alias is more readable and generally preferred over the full path.\n\n## Example\n```python\nimport datetime\n\ndatetime.timezone.utc\n```\n\nUse instead:\n```python\nimport datetime\n\ndatetime.UTC\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `datetime.UTC`](https://docs.python.org/3/library/datetime.html#datetime.UTC)\n"
  },
  {
    "name": "native-literals",
    "code": "UP018",
    "linter": "pyupgrade",
    "summary": "Unnecessary call to `{literal_type}`",
    "message_formats": [
      "Unnecessary call to `{literal_type}`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary calls to `str` and `bytes`.\n\n## Why is this bad?\nThe `str` and `bytes` constructors can be replaced with string and bytes\nliterals, which are more readable and idiomatic.\n\n## Example\n```python\nstr(\"foo\")\n```\n\nUse instead:\n```python\n\"foo\"\n```\n\n## References\n- [Python documentation: `str`](https://docs.python.org/3/library/stdtypes.html#str)\n- [Python documentation: `bytes`](https://docs.python.org/3/library/stdtypes.html#bytes)\n"
  },
  {
    "name": "typing-text-str-alias",
    "code": "UP019",
    "linter": "pyupgrade",
    "summary": "`typing.Text` is deprecated, use `str`",
    "message_formats": [
      "`typing.Text` is deprecated, use `str`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of `typing.Text`.\n\n## Why is this bad?\n`typing.Text` is an alias for `str`, and only exists for Python 2\ncompatibility. As of Python 3.11, `typing.Text` is deprecated. Use `str`\ninstead.\n\n## Example\n```python\nfrom typing import Text\n\nfoo: Text = \"bar\"\n```\n\nUse instead:\n```python\nfoo: str = \"bar\"\n```\n\n## References\n- [Python documentation: `typing.Text`](https://docs.python.org/3/library/typing.html#typing.Text)\n"
  },
  {
    "name": "open-alias",
    "code": "UP020",
    "linter": "pyupgrade",
    "summary": "Use builtin `open`",
    "message_formats": [
      "Use builtin `open`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of `io.open`.\n\n## Why is this bad?\nIn Python 3, `io.open` is an alias for `open`. Prefer using `open` directly,\nas it is more idiomatic.\n\n## Example\n```python\nimport io\n\nwith io.open(\"file.txt\") as f:\n    ...\n```\n\nUse instead:\n```python\nwith open(\"file.txt\") as f:\n    ...\n```\n\n## References\n- [Python documentation: `io.open`](https://docs.python.org/3/library/io.html#io.open)\n"
  },
  {
    "name": "replace-universal-newlines",
    "code": "UP021",
    "linter": "pyupgrade",
    "summary": "`universal_newlines` is deprecated, use `text`",
    "message_formats": [
      "`universal_newlines` is deprecated, use `text`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `subprocess.run` that set the `universal_newlines`\nkeyword argument.\n\n## Why is this bad?\nAs of Python 3.7, the `universal_newlines` keyword argument has been\nrenamed to `text`, and now exists for backwards compatibility. The\n`universal_newlines` keyword argument may be removed in a future version of\nPython. Prefer `text`, which is more explicit and readable.\n\n## Example\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], universal_newlines=True)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], text=True)\n```\n\n## References\n- [Python 3.7 release notes](https://docs.python.org/3/whatsnew/3.7.html#subprocess)\n- [Python documentation: `subprocess.run`](https://docs.python.org/3/library/subprocess.html#subprocess.run)\n"
  },
  {
    "name": "replace-stdout-stderr",
    "code": "UP022",
    "linter": "pyupgrade",
    "summary": "Sending `stdout` and `stderr` to `PIPE` is deprecated, use `capture_output`",
    "message_formats": [
      "Sending `stdout` and `stderr` to `PIPE` is deprecated, use `capture_output`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `subprocess.run` that send `stdout` and `stderr` to a\npipe.\n\n## Why is this bad?\nAs of Python 3.7, `subprocess.run` has a `capture_output` keyword argument\nthat can be set to `True` to capture `stdout` and `stderr` outputs. This is\nequivalent to setting `stdout` and `stderr` to `subprocess.PIPE`, but is\nmore explicit and readable.\n\n## Example\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n```\n\nUse instead:\n```python\nimport subprocess\n\nsubprocess.run([\"foo\"], capture_output=True)\n```\n\n## References\n- [Python 3.7 release notes](https://docs.python.org/3/whatsnew/3.7.html#subprocess)\n- [Python documentation: `subprocess.run`](https://docs.python.org/3/library/subprocess.html#subprocess.run)\n"
  },
  {
    "name": "deprecated-c-element-tree",
    "code": "UP023",
    "linter": "pyupgrade",
    "summary": "`cElementTree` is deprecated, use `ElementTree`",
    "message_formats": [
      "`cElementTree` is deprecated, use `ElementTree`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of the `xml.etree.cElementTree` module.\n\n## Why is this bad?\nIn Python 3.3, `xml.etree.cElementTree` was deprecated in favor of\n`xml.etree.ElementTree`.\n\n## Example\n```python\nfrom xml.etree import cElementTree\n```\n\nUse instead:\n```python\nfrom xml.etree import ElementTree\n```\n\n## References\n- [Python documentation: `xml.etree.ElementTree`](https://docs.python.org/3/library/xml.etree.elementtree.html)\n"
  },
  {
    "name": "os-error-alias",
    "code": "UP024",
    "linter": "pyupgrade",
    "summary": "Replace aliased errors with `OSError`",
    "message_formats": [
      "Replace aliased errors with `OSError`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of exceptions that alias `OSError`.\n\n## Why is this bad?\n`OSError` is the builtin error type used for exceptions that relate to the\noperating system.\n\nIn Python 3.3, a variety of other exceptions, like `WindowsError` were\naliased to `OSError`. These aliases remain in place for compatibility with\nolder versions of Python, but may be removed in future versions.\n\nPrefer using `OSError` directly, as it is more idiomatic and future-proof.\n\n## Example\n```python\nraise IOError\n```\n\nUse instead:\n```python\nraise OSError\n```\n\n## References\n- [Python documentation: `OSError`](https://docs.python.org/3/library/exceptions.html#OSError)\n"
  },
  {
    "name": "unicode-kind-prefix",
    "code": "UP025",
    "linter": "pyupgrade",
    "summary": "Remove unicode literals from strings",
    "message_formats": [
      "Remove unicode literals from strings"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of the Unicode kind prefix (`u`) in strings.\n\n## Why is this bad?\nIn Python 3, all strings are Unicode by default. The Unicode kind prefix is\nunnecessary and should be removed to avoid confusion.\n\n## Example\n```python\nu\"foo\"\n```\n\nUse instead:\n```python\n\"foo\"\n```\n\n## References\n- [Python documentation: Unicode HOWTO](https://docs.python.org/3/howto/unicode.html)\n"
  },
  {
    "name": "deprecated-mock-import",
    "code": "UP026",
    "linter": "pyupgrade",
    "summary": "`mock` is deprecated, use `unittest.mock`",
    "message_formats": [
      "`mock` is deprecated, use `unittest.mock`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for imports of the `mock` module that should be replaced with\n`unittest.mock`.\n\n## Why is this bad?\nSince Python 3.3, `mock` has been a part of the standard library as\n`unittest.mock`. The `mock` package is deprecated; use `unittest.mock`\ninstead.\n\n## Example\n```python\nimport mock\n```\n\nUse instead:\n```python\nfrom unittest import mock\n```\n\n## References\n- [Python documentation: `unittest.mock`](https://docs.python.org/3/library/unittest.mock.html)\n- [PyPI: `mock`](https://pypi.org/project/mock/)\n"
  },
  {
    "name": "unpacked-list-comprehension",
    "code": "UP027",
    "linter": "pyupgrade",
    "summary": "Replace unpacked list comprehension with a generator expression",
    "message_formats": [
      "Replace unpacked list comprehension with a generator expression"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for list comprehensions that are immediately unpacked.\n\n## Why is this bad?\nThere is no reason to use a list comprehension if the result is immediately\nunpacked. Instead, use a generator expression, which is more efficient as\nit avoids allocating an intermediary list.\n\n## Example\n```python\na, b, c = [foo(x) for x in items]\n```\n\nUse instead:\n```python\na, b, c = (foo(x) for x in items)\n```\n\n## References\n- [Python documentation: Generator expressions](https://docs.python.org/3/reference/expressions.html#generator-expressions)\n- [Python documentation: List comprehensions](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)\n"
  },
  {
    "name": "yield-in-for-loop",
    "code": "UP028",
    "linter": "pyupgrade",
    "summary": "Replace `yield` over `for` loop with `yield from`",
    "message_formats": [
      "Replace `yield` over `for` loop with `yield from`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `for` loops that can be replaced with `yield from` expressions.\n\n## Why is this bad?\nIf a `for` loop only contains a `yield` statement, it can be replaced with a\n`yield from` expression, which is more concise and idiomatic.\n\n## Example\n```python\nfor x in foo:\n    yield x\n```\n\nUse instead:\n```python\nyield from foo\n```\n\n## References\n- [Python documentation: The `yield` statement](https://docs.python.org/3/reference/simple_stmts.html#the-yield-statement)\n- [PEP 380](https://peps.python.org/pep-0380/)\n"
  },
  {
    "name": "unnecessary-builtin-import",
    "code": "UP029",
    "linter": "pyupgrade",
    "summary": "Unnecessary builtin import: `{import}`",
    "message_formats": [
      "Unnecessary builtin import: `{import}`",
      "Unnecessary builtin imports: {imports}"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for unnecessary imports of builtins.\n\n## Why is this bad?\nBuiltins are always available. Importing them is unnecessary and should be\nremoved to avoid confusion.\n\n## Example\n```python\nfrom builtins import str\n\nstr(1)\n```\n\nUse instead:\n```python\nstr(1)\n```\n\n## References\n- [Python documentation: The Python Standard Library](https://docs.python.org/3/library/index.html)\n"
  },
  {
    "name": "format-literals",
    "code": "UP030",
    "linter": "pyupgrade",
    "summary": "Use implicit references for positional format fields",
    "message_formats": [
      "Use implicit references for positional format fields"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for unnecessary positional indices in format strings.\n\n## Why is this bad?\nIn Python 3.1 and later, format strings can use implicit positional\nreferences. For example, `\"{0}, {1}\".format(\"Hello\", \"World\")` can be\nrewritten as `\"{}, {}\".format(\"Hello\", \"World\")`.\n\nIf the positional indices appear exactly in-order, they can be omitted\nin favor of automatic indices to improve readability.\n\n## Example\n```python\n\"{0}, {1}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\nUse instead:\n```python\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\n## References\n- [Python documentation: Format String Syntax](https://docs.python.org/3/library/string.html#format-string-syntax)\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "printf-string-formatting",
    "code": "UP031",
    "linter": "pyupgrade",
    "summary": "Use format specifiers instead of percent format",
    "message_formats": [
      "Use format specifiers instead of percent format"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `printf`-style string formatting.\n\n## Why is this bad?\n`printf`-style string formatting has a number of quirks, and leads to less\nreadable code than using `str.format` calls or f-strings. In general, prefer\nthe newer `str.format` and f-strings constructs over `printf`-style string\nformatting.\n\n## Example\n```python\n\"%s, %s\" % (\"Hello\", \"World\")  # \"Hello, World\"\n```\n\nUse instead:\n```python\n\"{}, {}\".format(\"Hello\", \"World\")  # \"Hello, World\"\n```\n\n## References\n- [Python documentation: `printf`-style String Formatting](https://docs.python.org/3/library/stdtypes.html#old-string-formatting)\n- [Python documentation: `str.format`](https://docs.python.org/3/library/stdtypes.html#str.format)\n"
  },
  {
    "name": "f-string",
    "code": "UP032",
    "linter": "pyupgrade",
    "summary": "Use f-string instead of `format` call",
    "message_formats": [
      "Use f-string instead of `format` call"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `str#format` calls that can be replaced with f-strings.\n\n## Why is this bad?\nf-strings are more readable and generally preferred over `str#format`\ncalls.\n\n## Example\n```python\n\"{}\".format(foo)\n```\n\nUse instead:\n```python\nf\"{foo}\"\n```\n\n## References\n- [Python documentation: f-strings](https://docs.python.org/3/reference/lexical_analysis.html#f-strings)\n"
  },
  {
    "name": "lru-cache-with-maxsize-none",
    "code": "UP033",
    "linter": "pyupgrade",
    "summary": "Use `@functools.cache` instead of `@functools.lru_cache(maxsize=None)`",
    "message_formats": [
      "Use `@functools.cache` instead of `@functools.lru_cache(maxsize=None)`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `functools.lru_cache` that set `maxsize=None`.\n\n## Why is this bad?\nSince Python 3.9, `functools.cache` can be used as a drop-in replacement\nfor `functools.lru_cache(maxsize=None)`. When possible, prefer\n`functools.cache` as it is more readable and idiomatic.\n\n## Example\n```python\nimport functools\n\n\n@functools.lru_cache(maxsize=None)\ndef foo():\n    ...\n```\n\nUse instead:\n```python\nimport functools\n\n\n@functools.cache\ndef foo():\n    ...\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `@functools.cache`](https://docs.python.org/3/library/functools.html#functools.cache)\n"
  },
  {
    "name": "extraneous-parentheses",
    "code": "UP034",
    "linter": "pyupgrade",
    "summary": "Avoid extraneous parentheses",
    "message_formats": [
      "Avoid extraneous parentheses"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for extraneous parentheses.\n\n## Why is this bad?\nExtraneous parentheses are redundant, and can be removed to improve\nreadability while retaining identical semantics.\n\n## Example\n```python\nprint((\"Hello, world\"))\n```\n\nUse instead:\n```python\nprint(\"Hello, world\")\n```\n"
  },
  {
    "name": "deprecated-import",
    "code": "UP035",
    "linter": "pyupgrade",
    "summary": "Import from `{target}` instead: {names}",
    "message_formats": [
      "Import from `{target}` instead: {names}",
      "`{module}.{member}` is deprecated, use `{target}` instead"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of deprecated imports based on the minimum supported\nPython version.\n\n## Why is this bad?\nDeprecated imports may be removed in future versions of Python, and\nshould be replaced with their new equivalents.\n\nNote that, in some cases, it may be preferable to continue importing\nmembers from `typing_extensions` even after they're added to the Python\nstandard library, as `typing_extensions` can backport bugfixes and\noptimizations from later Python versions. This rule thus avoids flagging\nimports from `typing_extensions` in such cases.\n\n## Example\n```python\nfrom collections import Sequence\n```\n\nUse instead:\n```python\nfrom collections.abc import Sequence\n```\n"
  },
  {
    "name": "outdated-version-block",
    "code": "UP036",
    "linter": "pyupgrade",
    "summary": "Version block is outdated for minimum Python version",
    "message_formats": [
      "Version block is outdated for minimum Python version"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for conditional blocks gated on `sys.version_info` comparisons\nthat are outdated for the minimum supported Python version.\n\n## Why is this bad?\nIn Python, code can be conditionally executed based on the active\nPython version by comparing against the `sys.version_info` tuple.\n\nIf a code block is only executed for Python versions older than the\nminimum supported version, it should be removed.\n\n## Example\n```python\nimport sys\n\nif sys.version_info < (3, 0):\n    print(\"py2\")\nelse:\n    print(\"py3\")\n```\n\nUse instead:\n```python\nprint(\"py3\")\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `sys.version_info`](https://docs.python.org/3/library/sys.html#sys.version_info)\n"
  },
  {
    "name": "quoted-annotation",
    "code": "UP037",
    "linter": "pyupgrade",
    "summary": "Remove quotes from type annotation",
    "message_formats": [
      "Remove quotes from type annotation"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for the presence of unnecessary quotes in type annotations.\n\n## Why is this bad?\nIn Python, type annotations can be quoted to avoid forward references.\nHowever, if `from __future__ import annotations` is present, Python\nwill always evaluate type annotations in a deferred manner, making\nthe quotes unnecessary.\n\n## Example\n```python\nfrom __future__ import annotations\n\n\ndef foo(bar: \"Bar\") -> \"Bar\":\n    ...\n```\n\nUse instead:\n```python\nfrom __future__ import annotations\n\n\ndef foo(bar: Bar) -> Bar:\n    ...\n```\n\n## References\n- [PEP 563](https://peps.python.org/pep-0563/)\n- [Python documentation: `__future__`](https://docs.python.org/3/library/__future__.html#module-__future__)\n"
  },
  {
    "name": "non-pep604-isinstance",
    "code": "UP038",
    "linter": "pyupgrade",
    "summary": "Use `X | Y` in `{}` call instead of `(X, Y)`",
    "message_formats": [
      "Use `X | Y` in `{}` call instead of `(X, Y)`"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `isinstance` and `issubclass` that take a tuple\nof types for comparison.\n\n## Why is this bad?\nSince Python 3.10, `isinstance` and `issubclass` can be passed a\n`|`-separated union of types, which is more concise and consistent\nwith the union operator introduced in [PEP 604].\n\n## Example\n```python\nisinstance(x, (int, float))\n```\n\nUse instead:\n```python\nisinstance(x, int | float)\n```\n\n## Options\n- `target-version`\n\n## References\n- [Python documentation: `isinstance`](https://docs.python.org/3/library/functions.html#isinstance)\n- [Python documentation: `issubclass`](https://docs.python.org/3/library/functions.html#issubclass)\n\n[PEP 604]: https://peps.python.org/pep-0604/\n"
  },
  {
    "name": "unnecessary-class-parentheses",
    "code": "UP039",
    "linter": "pyupgrade",
    "summary": "Unnecessary parentheses after class definition",
    "message_formats": [
      "Unnecessary parentheses after class definition"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for class definitions that include unnecessary parentheses after\nthe class name.\n\n## Why is this bad?\nIf a class definition doesn't have any bases, the parentheses are\nunnecessary.\n\n## Examples\n```python\nclass Foo():\n    ...\n```\n\nUse instead:\n```python\nclass Foo:\n    ...\n```\n"
  },
  {
    "name": "ambiguous-unicode-character-string",
    "code": "RUF001",
    "linter": "Ruff-specific rules",
    "summary": "String contains ambiguous {}. Did you mean {}?",
    "message_formats": [
      "String contains ambiguous {}. Did you mean {}?"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for ambiguous unicode characters in strings.\n\n## Why is this bad?\nThe use of ambiguous unicode characters can confuse readers and cause\nsubtle bugs.\n\n## Example\n```python\nprint(\"ello, world!\")  # \"\" is the Greek eta (`U+0397`).\n```\n\nUse instead:\n```python\nprint(\"Hello, world!\")  # \"H\" is the Latin capital H (`U+0048`).\n```\n"
  },
  {
    "name": "ambiguous-unicode-character-docstring",
    "code": "RUF002",
    "linter": "Ruff-specific rules",
    "summary": "Docstring contains ambiguous {}. Did you mean {}?",
    "message_formats": [
      "Docstring contains ambiguous {}. Did you mean {}?"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for ambiguous unicode characters in docstrings.\n\n## Why is this bad?\nThe use of ambiguous unicode characters can confuse readers and cause\nsubtle bugs.\n\n## Example\n```python\n\"\"\"A lovely docstring (with a `U+FF09` parenthesis.\"\"\"\n```\n\nUse instead:\n```python\n\"\"\"A lovely docstring (with no strange parentheses).\"\"\"\n```\n"
  },
  {
    "name": "ambiguous-unicode-character-comment",
    "code": "RUF003",
    "linter": "Ruff-specific rules",
    "summary": "Comment contains ambiguous {}. Did you mean {}?",
    "message_formats": [
      "Comment contains ambiguous {}. Did you mean {}?"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for ambiguous unicode characters in comments.\n\n## Why is this bad?\nThe use of ambiguous unicode characters can confuse readers and cause\nsubtle bugs.\n\n## Example\n```python\nfoo()  # nqa  # \"\" is Cyrillic (`U+043E`)\n```\n\nUse instead:\n```python\nfoo()  # noqa  # \"o\" is Latin (`U+006F`)\n```\n"
  },
  {
    "name": "collection-literal-concatenation",
    "code": "RUF005",
    "linter": "Ruff-specific rules",
    "summary": "Consider `{expr}` instead of concatenation",
    "message_formats": [
      "Consider `{expr}` instead of concatenation"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for uses of the `+` operator to concatenate collections.\n\n## Why is this bad?\nIn Python, the `+` operator can be used to concatenate collections (e.g.,\n`x + y` to concatenate the lists `x` and `y`).\n\nHowever, collections can be concatenated more efficiently using the\nunpacking operator (e.g., `[*x, *y]` to concatenate `x` and `y`).\n\nPrefer the unpacking operator to concatenate collections, as it is more\nreadable and flexible. The `*` operator can unpack any iterable, whereas\n `+` operates only on particular sequences which, in many cases, must be of\nthe same type.\n\n## Example\n```python\nfoo = [2, 3, 4]\nbar = [1] + foo + [5, 6]\n```\n\nUse instead:\n```python\nfoo = [2, 3, 4]\nbar = [1, *foo, 5, 6]\n```\n\n## References\n- [PEP 448  Additional Unpacking Generalizations](https://peps.python.org/pep-0448/)\n- [Python documentation: Sequence Types  `list`, `tuple`, `range`](https://docs.python.org/3/library/stdtypes.html#sequence-types-list-tuple-range)\n"
  },
  {
    "name": "asyncio-dangling-task",
    "code": "RUF006",
    "linter": "Ruff-specific rules",
    "summary": "Store a reference to the return value of `asyncio.{method}`",
    "message_formats": [
      "Store a reference to the return value of `asyncio.{method}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `asyncio.create_task` and `asyncio.ensure_future` calls\nthat do not store a reference to the returned result.\n\n## Why is this bad?\nPer the `asyncio` documentation, the event loop only retains a weak\nreference to tasks. If the task returned by `asyncio.create_task` and\n`asyncio.ensure_future` is not stored in a variable, or a collection,\nor otherwise referenced, it may be garbage collected at any time. This\ncan lead to unexpected and inconsistent behavior, as your tasks may or\nmay not run to completion.\n\n## Example\n```python\nimport asyncio\n\nfor i in range(10):\n    # This creates a weak reference to the task, which may be garbage\n    # collected at any time.\n    asyncio.create_task(some_coro(param=i))\n```\n\nUse instead:\n```python\nimport asyncio\n\nbackground_tasks = set()\n\nfor i in range(10):\n    task = asyncio.create_task(some_coro(param=i))\n\n    # Add task to the set. This creates a strong reference.\n    background_tasks.add(task)\n\n    # To prevent keeping references to finished tasks forever,\n    # make each task remove its own reference from the set after\n    # completion:\n    task.add_done_callback(background_tasks.discard)\n```\n\n## References\n- [_The Heisenbug lurking in your async code_](https://textual.textualize.io/blog/2023/02/11/the-heisenbug-lurking-in-your-async-code/)\n- [The Python Standard Library](https://docs.python.org/3/library/asyncio-task.html#asyncio.create_task)\n"
  },
  {
    "name": "pairwise-over-zipped",
    "code": "RUF007",
    "linter": "Ruff-specific rules",
    "summary": "Prefer `itertools.pairwise()` over `zip()` when iterating over successive pairs",
    "message_formats": [
      "Prefer `itertools.pairwise()` over `zip()` when iterating over successive pairs"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for use of `zip()` to iterate over successive pairs of elements.\n\n## Why is this bad?\nWhen iterating over successive pairs of elements, prefer\n`itertools.pairwise()` over `zip()`.\n\n`itertools.pairwise()` is more readable and conveys the intent of the code\nmore clearly.\n\n## Example\n```python\nletters = \"ABCD\"\nzip(letters, letters[1:])  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n```\n\nUse instead:\n```python\nfrom itertools import pairwise\n\nletters = \"ABCD\"\npairwise(letters)  # (\"A\", \"B\"), (\"B\", \"C\"), (\"C\", \"D\")\n```\n\n## References\n- [Python documentation: `itertools.pairwise`](https://docs.python.org/3/library/itertools.html#itertools.pairwise)\n"
  },
  {
    "name": "mutable-dataclass-default",
    "code": "RUF008",
    "linter": "Ruff-specific rules",
    "summary": "Do not use mutable default values for dataclass attributes",
    "message_formats": [
      "Do not use mutable default values for dataclass attributes"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for mutable default values in dataclass attributes.\n\n## Why is this bad?\nMutable default values share state across all instances of the dataclass.\nThis can lead to bugs when the attributes are changed in one instance, as\nthose changes will unexpectedly affect all other instances.\n\nInstead of sharing mutable defaults, use the `field(default_factory=...)`\npattern.\n\nIf the default value is intended to be mutable, it should be annotated with\n`typing.ClassVar`.\n\n## Examples\n```python\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = []\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=list)\n```\n\nOr:\n```python\nfrom dataclasses import dataclass, field\nfrom typing import ClassVar\n\n\n@dataclass\nclass A:\n    mutable_default: ClassVar[list[int]] = []\n```\n"
  },
  {
    "name": "function-call-in-dataclass-default-argument",
    "code": "RUF009",
    "linter": "Ruff-specific rules",
    "summary": "Do not perform function call `{name}` in dataclass defaults",
    "message_formats": [
      "Do not perform function call `{name}` in dataclass defaults",
      "Do not perform function call in dataclass defaults"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for function calls in dataclass attribute defaults.\n\n## Why is this bad?\nFunction calls are only performed once, at definition time. The returned\nvalue is then reused by all instances of the dataclass. This can lead to\nunexpected behavior when the function call returns a mutable object, as\nchanges to the object will be shared across all instances.\n\nIf a field needs to be initialized with a mutable object, use the\n`field(default_factory=...)` pattern.\n\n## Examples\n```python\nfrom dataclasses import dataclass\n\n\ndef simple_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = simple_list()\n```\n\nUse instead:\n```python\nfrom dataclasses import dataclass, field\n\n\ndef creating_list() -> list[int]:\n    return [1, 2, 3, 4]\n\n\n@dataclass\nclass A:\n    mutable_default: list[int] = field(default_factory=creating_list)\n```\n\n## Options\n- `flake8-bugbear.extend-immutable-calls`\n"
  },
  {
    "name": "explicit-f-string-type-conversion",
    "code": "RUF010",
    "linter": "Ruff-specific rules",
    "summary": "Use explicit conversion flag",
    "message_formats": [
      "Use explicit conversion flag"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for uses of `str()`, `repr()`, and `ascii()` as explicit type\nconversions within f-strings.\n\n## Why is this bad?\nf-strings support dedicated conversion flags for these types, which are\nmore succinct and idiomatic.\n\nNote that, in many cases, calling `str()` within an f-string is\nunnecessary and can be removed entirely, as the value will be converted\nto a string automatically, the notable exception being for classes that\nimplement a custom `__format__` method.\n\n## Example\n```python\na = \"some string\"\nf\"{repr(a)}\"\n```\n\nUse instead:\n```python\na = \"some string\"\nf\"{a!r}\"\n```\n"
  },
  {
    "name": "static-key-dict-comprehension",
    "code": "RUF011",
    "linter": "Ruff-specific rules",
    "summary": "Dictionary comprehension uses static key: `{key}`",
    "message_formats": [
      "Dictionary comprehension uses static key: `{key}`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for dictionary comprehensions that use a static key, like a string\nliteral.\n\n## Why is this bad?\nUsing a static key (like a string literal) in a dictionary comprehension\nis usually a mistake, as it will result in a dictionary with only one key,\ndespite the comprehension iterating over multiple values.\n\n## Example\n```python\ndata = [\"some\", \"Data\"]\n{\"key\": value.upper() for value in data}\n```\n\nUse instead:\n```python\ndata = [\"some\", \"Data\"]\n{value: value.upper() for value in data}\n```\n"
  },
  {
    "name": "mutable-class-default",
    "code": "RUF012",
    "linter": "Ruff-specific rules",
    "summary": "Mutable class attributes should be annotated with `typing.ClassVar`",
    "message_formats": [
      "Mutable class attributes should be annotated with `typing.ClassVar`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for mutable default values in class attributes.\n\n## Why is this bad?\nMutable default values share state across all instances of the class,\nwhile not being obvious. This can lead to bugs when the attributes are\nchanged in one instance, as those changes will unexpectedly affect all\nother instances.\n\nWhen mutable value are intended, they should be annotated with\n`typing.ClassVar`.\n\n## Examples\n```python\nclass A:\n    mutable_default: list[int] = []\n```\n\nUse instead:\n```python\nfrom typing import ClassVar\n\n\nclass A:\n    mutable_default: ClassVar[list[int]] = []\n```\n"
  },
  {
    "name": "implicit-optional",
    "code": "RUF013",
    "linter": "Ruff-specific rules",
    "summary": "PEP 484 prohibits implicit `Optional`",
    "message_formats": [
      "PEP 484 prohibits implicit `Optional`"
    ],
    "autofix": "Autofix is sometimes available.",
    "explanation": "## What it does\nChecks for the use of implicit `Optional` in type annotations when the\ndefault parameter value is `None`.\n\n## Why is this bad?\nImplicit `Optional` is prohibited by [PEP 484]. It is confusing and\ninconsistent with the rest of the type system.\n\nIt's recommended to use `Optional[T]` instead. For Python 3.10 and later,\nyou can also use `T | None`.\n\n## Example\n```python\ndef foo(arg: int = None):\n    pass\n```\n\nUse instead:\n```python\nfrom typing import Optional\n\n\ndef foo(arg: Optional[int] = None):\n    pass\n```\n\nOr, for Python 3.10 and later:\n```python\ndef foo(arg: int | None = None):\n    pass\n```\n\nIf you want to use the `|` operator in Python 3.9 and earlier, you can\nuse future imports:\n```python\nfrom __future__ import annotations\n\n\ndef foo(arg: int | None = None):\n    pass\n```\n\n## Limitations\n\nType aliases are not supported and could result in false negatives.\nFor example, the following code will not be flagged:\n```python\nText = str | bytes\n\n\ndef foo(arg: Text = None):\n    pass\n```\n\n## Options\n- `target-version`\n\n[PEP 484]: https://peps.python.org/pep-0484/#union-types\n"
  },
  {
    "name": "unused-noqa",
    "code": "RUF100",
    "linter": "Ruff-specific rules",
    "summary": "Unused `noqa` directive",
    "message_formats": [
      "Unused `noqa` directive",
      "Unused `noqa` directive ({})",
      "Unused blanket `noqa` directive"
    ],
    "autofix": "Autofix is always available.",
    "explanation": "## What it does\nChecks for `noqa` directives that are no longer applicable.\n\n## Why is this bad?\nA `noqa` directive that no longer matches any diagnostic violations is\nlikely included by mistake, and should be removed to avoid confusion.\n\n## Example\n```python\nimport foo  # noqa: F401\n\n\ndef bar():\n    foo.bar()\n```\n\nUse instead:\n```python\nimport foo\n\n\ndef bar():\n    foo.bar()\n```\n\n## References\n- [Automatic `noqa` management](https://beta.ruff.rs/docs/configuration/#automatic-noqa-management)\n"
  },
  {
    "name": "invalid-pyproject-toml",
    "code": "RUF200",
    "linter": "Ruff-specific rules",
    "summary": "Failed to parse pyproject.toml: {}",
    "message_formats": [
      "Failed to parse pyproject.toml: {}"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for any pyproject.toml that does not conform to the schema from the relevant PEPs.\n\n## Why is this bad?\nYour project may contain invalid metadata or configuration without you noticing\n\n## Example\n```toml\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\"Ferris the Crab <ferris@example.org>\"]\n```\n\nUse instead:\n```toml\n[project]\nname = \"crab\"\nversion = \"1.0.0\"\nauthors = [\n  { email = \"ferris@example.org\" },\n  { name = \"Ferris the Crab\"}\n]\n```\n\n## References\n- [Specification of `[project]` in pyproject.toml](https://packaging.python.org/en/latest/specifications/declaring-project-metadata/)\n- [Specification of `[build-system]` in pyproject.toml](https://peps.python.org/pep-0518/)\n- [Draft but implemented license declaration extensions](https://peps.python.org/pep-0639)\n"
  },
  {
    "name": "raise-vanilla-class",
    "code": "TRY002",
    "linter": "tryceratops",
    "summary": "Create your own exception",
    "message_formats": [
      "Create your own exception"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for code that raises `Exception` directly.\n\n## Why is this bad?\nHandling such exceptions requires the use of `except Exception`, which\ncaptures _any_ raised exception, including failed assertions,\ndivision by zero, and more.\n\nPrefer to raise your own exception, or a more specific built-in\nexception, so that you can avoid over-capturing exceptions that you\ndon't intend to handle.\n\n## Example\n```python\ndef main_function():\n    if not cond:\n        raise Exception()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except Exception:\n        logger.error(\"Oops\")\n```\n\nUse instead:\n```python\ndef main_function():\n    if not cond:\n        raise CustomException()\n\n\ndef consumer_func():\n    try:\n        do_step()\n        prepare()\n        main_function()\n    except CustomException:\n        logger.error(\"Main function failed\")\n    except Exception:\n        logger.error(\"Oops\")\n```\n"
  },
  {
    "name": "raise-vanilla-args",
    "code": "TRY003",
    "linter": "tryceratops",
    "summary": "Avoid specifying long messages outside the exception class",
    "message_formats": [
      "Avoid specifying long messages outside the exception class"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for long exception messages that are not defined in the exception\nclass itself.\n\n## Why is this bad?\nBy formatting an exception message at the `raise` site, the exception class\nbecomes less reusable, and may now raise inconsistent messages depending on\nwhere it is raised.\n\nIf the exception message is instead defined within the exception class, it\nwill be consistent across all `raise` invocations.\n\n## Example\n```python\nclass CantBeNegative(Exception):\n    pass\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(f\"{x} is negative\")\n```\n\nUse instead:\n```python\nclass CantBeNegative(Exception):\n    def __init__(self, number):\n        super().__init__(f\"{number} is negative\")\n\n\ndef foo(x):\n    if x < 0:\n        raise CantBeNegative(x)\n```\n"
  },
  {
    "name": "type-check-without-type-error",
    "code": "TRY004",
    "linter": "tryceratops",
    "summary": "Prefer `TypeError` exception for invalid type",
    "message_formats": [
      "Prefer `TypeError` exception for invalid type"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for type checks that do not raise `TypeError`.\n\n## Why is this bad?\nThe Python documentation states that `TypeError` should be raised upon\nencountering an inappropriate type.\n\n## Example\n```python\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise ValueError(\"n must be an integer\")\n```\n\nUse instead:\n```python\ndef foo(n: int):\n    if isinstance(n, int):\n        pass\n    else:\n        raise TypeError(\"n must be an integer\")\n```\n\n## References\n- [Python documentation: `TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError)\n"
  },
  {
    "name": "reraise-no-cause",
    "code": "TRY200",
    "linter": "tryceratops",
    "summary": "Use `raise from` to specify exception cause",
    "message_formats": [
      "Use `raise from` to specify exception cause"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for exceptions that are re-raised without specifying the cause via\nthe `from` keyword.\n\n## Why is this bad?\nThe `from` keyword sets the `__cause__` attribute of the exception, which\nstores the \"cause\" of the exception. The availability of an exception\n\"cause\" is useful for debugging.\n\n## Example\n```python\ndef reciprocal(n):\n    try:\n        return 1 / n\n    except ZeroDivisionError:\n        raise ValueError\n```\n\nUse instead:\n```python\ndef reciprocal(n):\n    try:\n        return 1 / n\n    except ZeroDivisionError as exc:\n        raise ValueError from exc\n```\n\n## References\n- [Python documentation: Exception context](https://docs.python.org/3/library/exceptions.html#exception-context)\n"
  },
  {
    "name": "verbose-raise",
    "code": "TRY201",
    "linter": "tryceratops",
    "summary": "Use `raise` without specifying exception name",
    "message_formats": [
      "Use `raise` without specifying exception name"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for needless exception names in `raise` statements.\n\n## Why is this bad?\nIt's redundant to specify the exception name in a `raise` statement if the\nexception is being re-raised.\n\n## Example\n```python\ndef foo():\n    try:\n        ...\n    except ValueError as exc:\n        raise exc\n```\n\nUse instead:\n```python\ndef foo():\n    try:\n        ...\n    except ValueError:\n        raise\n```\n"
  },
  {
    "name": "try-consider-else",
    "code": "TRY300",
    "linter": "tryceratops",
    "summary": "Consider moving this statement to an `else` block",
    "message_formats": [
      "Consider moving this statement to an `else` block"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `return` statements in `try` blocks.\n\n## Why is this bad?\nThe `try`-`except` statement has an `else` clause for code that should\nrun _only_ if no exceptions were raised. Using the `else` clause is more\nexplicit than using a `return` statement inside of a `try` block.\n\n## Example\n```python\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n    except ZeroDivisionError as exc:\n        logging.exception(\"Exception occurred\")\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef reciprocal(n):\n    try:\n        rec = 1 / n\n    except ZeroDivisionError as exc:\n        logging.exception(\"Exception occurred\")\n    else:\n        print(f\"reciprocal of {n} is {rec}\")\n        return rec\n```\n\n## References\n- [Python documentation: Errors and Exceptions](https://docs.python.org/3/tutorial/errors.html)\n"
  },
  {
    "name": "raise-within-try",
    "code": "TRY301",
    "linter": "tryceratops",
    "summary": "Abstract `raise` to an inner function",
    "message_formats": [
      "Abstract `raise` to an inner function"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for `raise` statements within `try` blocks.\n\n## Why is this bad?\nRaising and catching exceptions within the same `try` block is redundant,\nas the code can be refactored to avoid the `try` block entirely.\n\nAlternatively, the `raise` can be moved within an inner function, making\nthe exception reusable across multiple call sites.\n\n## Example\n```python\ndef bar():\n    pass\n\n\ndef foo():\n    try:\n        a = bar()\n        if not a:\n            raise ValueError\n    except ValueError:\n        raise\n```\n\nUse instead:\n```python\ndef bar():\n    raise ValueError\n\n\ndef foo():\n    try:\n        a = bar()  # refactored `bar` to raise `ValueError`\n    except ValueError:\n        raise\n```\n"
  },
  {
    "name": "useless-try-except",
    "code": "TRY302",
    "linter": "tryceratops",
    "summary": "Remove exception handler; error is immediately re-raised",
    "message_formats": [
      "Remove exception handler; error is immediately re-raised"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for immediate uses of `raise` within exception handlers.\n\n## Why is this bad?\nCapturing an exception, only to immediately reraise it, has no effect.\nInstead, remove the error-handling code and let the exception propagate\nupwards without the unnecessary `try`-`except` block.\n\n## Example\n```python\ndef foo():\n    try:\n        bar()\n    except NotImplementedError:\n        raise\n```\n\nUse instead:\n```python\ndef foo():\n    bar()\n```\n"
  },
  {
    "name": "error-instead-of-exception",
    "code": "TRY400",
    "linter": "tryceratops",
    "summary": "Use `logging.exception` instead of `logging.error`",
    "message_formats": [
      "Use `logging.exception` instead of `logging.error`"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for uses of `logging.error` instead of `logging.exception` when\nlogging an exception.\n\n## Why is this bad?\n`logging.exception` logs the exception and the traceback, while\n`logging.error` only logs the exception. The former is more appropriate\nwhen logging an exception, as the traceback is often useful for debugging.\n\n## Example\n```python\nimport logging\n\n\ndef foo():\n    try:\n        raise NotImplementedError\n    except NotImplementedError:\n        logging.error(\"Exception occurred\")\n```\n\nUse instead:\n```python\nimport logging\n\n\ndef foo():\n    try:\n        raise NotImplementedError\n    except NotImplementedError as exc:\n        logging.exception(\"Exception occurred\")\n```\n\n## References\n- [Python documentation: `logging.exception`](https://docs.python.org/3/library/logging.html#logging.exception)\n"
  },
  {
    "name": "verbose-log-message",
    "code": "TRY401",
    "linter": "tryceratops",
    "summary": "Redundant exception object included in `logging.exception` call",
    "message_formats": [
      "Redundant exception object included in `logging.exception` call"
    ],
    "autofix": "Autofix is not available.",
    "explanation": "## What it does\nChecks for excessive logging of exception objects.\n\n## Why is this bad?\nWhen logging exceptions via `logging.exception`, the exception object\nis logged automatically. Including the exception object in the log\nmessage is redundant and can lead to excessive logging.\n\n## Example\n```python\ntry:\n    ...\nexcept ValueError as e:\n    logger.exception(f\"Found an error: {e}\")\n```\n\nUse instead:\n```python\ntry:\n    ...\nexcept ValueError as e:\n    logger.exception(\"Found an error\")\n```\n"
  }
]